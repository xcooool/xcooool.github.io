<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>3d_gaussian</title>
    <url>/2023/10/24/3d-gaussian/</url>
    <content><![CDATA[<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p><a href="https://zhuanlan.zhihu.com/p/655325345">https://zhuanlan.zhihu.com/p/655325345</a></p>
<img data-src="/2023/10/24/3d-gaussian/image_rd4w-wAg6S.png" class>
<p>训练的时间短，并且如果训练上51min，可以达到比Mip-NeRF360还好一点的结果。</p>
<p><strong>PSNR越高越好</strong></p>
<p>目标：</p>
<img data-src="/2023/10/24/3d-gaussian/image_BmM43BiWgA.png" class>
<p>实现结果：</p>
<img data-src="/2023/10/24/3d-gaussian/image_Nf2BMneWQb.png" class>
<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><p>SFM VS MVS：</p>
<p>缺点：对缺少信息的地方会未重建、对某些地方又会过度重建</p>
<blockquote>
<p>MVS 几何信息的使用是主要的缺点：大多数这些方法的一个主要缺点是它们使用基于多视图立体视觉 (MVS) 的几何信息。MVS 是一种通过多个视角图像重建三维几何的方法。然而，<strong>MVS 算法可能会受到图像匹配错误、视角不足或遮挡等问题</strong>的影响，导致生成的几何信息存在缺陷和不准确性。</p>
<p>使用 CNN 进行最终渲染经常导致<strong>时间上的闪烁</strong>：另一个问题是使用 CNN 进行最终渲染时经常出现时间上的闪烁。这是由于 CNN 模型的输入和网络结构导致的，在连续帧之间可能存在细微的变化和不一致性，从而导致渲染结果的可见闪烁。</p>
</blockquote>
<hr>
<h2 id="NERF"><a href="#NERF" class="headerlink" title="NERF:"></a>NERF:</h2><p>Volumetric representations 是体积化表达方法</p>
<p>NerF用了一个大型的MLP，但是速度太慢了。现在对NerF进行改进的最好的方法是：Mip-NERF360</p>
<p><a href="https://www.youtube.com/watch?v=CRlN-cYFxTk">https://www.youtube.com/watch?v=CRlN-cYFxTk</a></p>
<p>这个视频讲nerf的，讲得太好了。</p>
<p>但是我对于这个RGB和density的值，是如何通过images得到的啊？</p>
<p>训练的是个网络</p>
<p>得到的ray中，一个波动，意思就是碰到了一个颜色，往下就是说明已经穿过物体了。</p>
<hr>
<p><a href="https://www.google.com/search?q=camera+calibration+youtube&amp;sca_esv=575405473&amp;sxsrf=AM9HkKmpTyy3E1Z0POfbYtp8NSGUl1p2yA%3A1697877069456&amp;ei=TYwzZZa3G9il2roPk4qT8Ac&amp;ved=0ahUKEwjWkeP83IaCAxXYklYBHRPFBH4Q4dUDCBA&amp;uact=5&amp;oq=camera+calibration+youtube&amp;gs_lp=Egxnd3Mtd2l6LXNlcnAiGmNhbWVyYSBjYWxpYnJhdGlvbiB5b3V0dWJlMggQABjLARiABDIGEAAYBRgeSMMPUI0BWLYOcAF4AZABAJgBywKgAeQLqgEFMi01LjG4AQPIAQD4AQHCAgoQABhHGNYEGLADwgIHECMYsQIYJ8ICBRAAGIAEwgIEEAAYHsICBhAAGAgYHuIDBBgAIEGIBgGQBgo&amp;sclient=gws-wiz-serp#fpstate=ive&amp;vld=cid:4b0cdc25,vid:GUbWsXU1mac,st:0">https://www.google.com/search?q=camera+calibration+youtube&amp;sca_esv=575405473&amp;sxsrf=AM9HkKmpTyy3E1Z0POfbYtp8NSGUl1p2yA%3A1697877069456&amp;ei=TYwzZZa3G9il2roPk4qT8Ac&amp;ved=0ahUKEwjWkeP83IaCAxXYklYBHRPFBH4Q4dUDCBA&amp;uact=5&amp;oq=camera+calibration+youtube&amp;gs_lp=Egxnd3Mtd2l6LXNlcnAiGmNhbWVyYSBjYWxpYnJhdGlvbiB5b3V0dWJlMggQABjLARiABDIGEAAYBRgeSMMPUI0BWLYOcAF4AZABAJgBywKgAeQLqgEFMi01LjG4AQPIAQD4AQHCAgoQABhHGNYEGLADwgIHECMYsQIYJ8ICBRAAGIAEwgIEEAAYHsICBhAAGAgYHuIDBBgAIEGIBgGQBgo&amp;sclient=gws-wiz-serp#fpstate=ive&amp;vld=cid:4b0cdc25,vid:GUbWsXU1mac,st:0</a></p>
<h2 id="什么是Camera-Caliberation？"><a href="#什么是Camera-Caliberation？" class="headerlink" title="什么是Camera Caliberation？"></a>什么是Camera Caliberation？</h2><p>相机标定</p>
<p>目的：</p>
<p>确定空间物体表面的三维 和2D之间的对应关系</p>
<ul>
<li>世界坐标系：world coordinate 其实就是直角坐标系</li>
<li>相机坐标系：camera coordinate 也是直角坐标系，只不过原点位于镜头光心处，</li>
</ul>
<img data-src="/2023/10/24/3d-gaussian/image_NllzSecXq6.png" class>
<p>要将世界的转换为相机的</p>
<img data-src="/2023/10/24/3d-gaussian/image_QuaTZeGfvr.png" class>
<p>相机通过针孔成像原理转化为图像的</p>
<img data-src="/2023/10/24/3d-gaussian/image_3KHp1jiJ3B.png" class>
<p>还要将图像(3D)的转换为像素(2D)的:</p>
<img data-src="/2023/10/24/3d-gaussian/image_mBD9XFufai.png" class>
<p>最后 就得到了 世界的 → 2D像素的 转换矩阵</p>
<p>同时，还包括一些畸变模型</p>
<hr>
<h2 id="Alpha-blending"><a href="#Alpha-blending" class="headerlink" title="Alpha-blending"></a>Alpha-blending</h2><p><a href="https://youtube.com/watch?v=wVkLeaWQOlQ">https://youtube.com/watch?v=wVkLeaWQOlQ</a></p>
<img data-src="/2023/10/24/3d-gaussian/image_qk1eSC90hC.png" class>
<hr>
<h2 id="Rasterization"><a href="#Rasterization" class="headerlink" title="Rasterization"></a>Rasterization</h2><p><a href="https://www.youtube.com/watch?v=t7Ztio8cwqM">https://www.youtube.com/watch?v=t7Ztio8cwqM</a></p>
<p>太优雅了。</p>
<p>总结一下</p>
<ol>
<li>画轮廓线</li>
<li>插值获得color</li>
<li>填充</li>
</ol>
<hr>
<h2 id="什么是SH（Spherical-Harmonics）"><a href="#什么是SH（Spherical-Harmonics）" class="headerlink" title="什么是SH（Spherical Harmonics）?"></a>什么是SH（Spherical Harmonics）?</h2><hr>
<h2 id="x20-什么是Covariance-Matrix？"><a href="#x20-什么是Covariance-Matrix？" class="headerlink" title="&#x20;什么是Covariance Matrix？"></a>&#x20;什么是Covariance Matrix？</h2><p>协方差矩阵和高斯函数的关系？</p>
<p><a href="https://blog.csdn.net/xfijun/article/details/53822490">https://blog.csdn.net/xfijun/article/details/53822490</a></p>
<p>结论：协方差函数 决定 高斯函数的形状~</p>
<p><a href="https://blog.csdn.net/duanyule_cqu/article/details/54959897?ops_request_misc=%7B%22request%5Fid%22%3A%22169796062616800180691549%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169796062616800180691549&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-54959897-null-null.142^v96^pc_search_result_base2&amp;utm_term=协方差矩阵的计算公式&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/duanyule_cqu/article/details/54959897?ops_request_misc=%7B%22request%5Fid%22%3A%22169796062616800180691549%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169796062616800180691549&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-54959897-null-null.142^v96^pc_search_result_base2&amp;utm_term=协方差矩阵的计算公式&amp;spm=1018.2226.3001.4187</a></p>
<p>为什么协方差矩阵可以通过scale 和 rotation矩阵得到？</p>
<img data-src="/2023/10/24/3d-gaussian/image_JPkIVUHiCL.png" class>
<blockquote>
<p>协方差矩阵可以通过缩放矩阵和旋转矩阵得到的原因涉及到线性代数和矩阵运算的特性。</p>
<p>首先，我们知道协方差矩阵描述了多维随机变量之间的关系，包括各个维度之间的相关性和方差。对于一个n维随机向量X，其协方差矩阵记为Σ。</p>
<p>现在考虑对该随机向量进行线性变换。我们可以用一个缩放矩阵S来缩放向量X，然后再用一个旋转矩阵R来旋转缩放后的向量。这个变换可以表示为Y = RX，其中Y是变换后的向量。</p>
<p>我们希望找到新的随机向量Y的协方差矩阵Σ’。根据线性代数的性质，我们知道变换后的随机向量Y满足以下关系：</p>
<p>Σ’ = E[(Y - μ’)(Y - μ’)^T]</p>
<p>其中μ’是Y的均值，E[•]表示期望运算。</p>
<p>将Y代入上述公式，可以得到：</p>
<p>Σ’ = E[(RX - Rμ)(RX - Rμ)^T]</p>
<p>我们知道，对于一个随机向量X，其均值μ和协方差矩阵Σ的关系为：</p>
<p>Σ = E[(X - μ)(X - μ)^T]</p>
<p>将这个关系代入上式，得到：</p>
<p>Σ’ = E[(RX - Rμ)(RX - Rμ)^T] &#x20;<br>\= E[(RX - Rμ)(X - μ)^T R^T] &#x20;<br>\= R E[(X - μ)(X - μ)^T] R^T &#x20;<br>\= R Σ R^T</p>
<p>因此，通过对随机向量进行缩放和旋转变换，可以得到新的协方差矩阵Σ’，其与原始协方差矩阵Σ之间满足Σ’ = RΣR^T的关系。</p>
<p>这说明了协方差矩阵可以通过缩放矩阵和旋转矩阵来得到。</p>
</blockquote>
<hr>
<h2 id="Metrics：PSNR-vs-SSIM"><a href="#Metrics：PSNR-vs-SSIM" class="headerlink" title="Metrics：PSNR vs SSIM"></a>Metrics：PSNR vs SSIM</h2><h3 id="PSNR"><a href="#PSNR" class="headerlink" title="PSNR"></a>PSNR</h3><p>Peak Signal-to-Noise Ratio</p>
<p>PSNR是一种基于峰值信噪比的度量，用于衡量原始图像和压缩或失真后的图像之间的差异。它通过比较原始图像的最大可能信号范围与失真图像的均方误差来计算。PSNR的数值越高，表示失真程度越低，图像质量越好。</p>
<h3 id="SSIM"><a href="#SSIM" class="headerlink" title="SSIM"></a>SSIM</h3><p>SSIM是一种结构相似性指数，用于评估原始图像和失真图像之间的结构相似性。它基于人类视觉系统的特性，考虑了亮度、对比度和结构信息。SSIM通过比较亮度、对比度和结构相似性的三个组成部分来计算相似性指数。SSIM的取值范围为0到1，数值越接近1表示图像质量越好，相似性越高。</p>
<h3 id="Comparison"><a href="#Comparison" class="headerlink" title="Comparison"></a>Comparison</h3><p>PSNR更加注重像素级的差异和信噪比，适用于对失真程度的精确度进行量化。而SSIM更加注重人眼感知的结构相似性，适用于评估图像的感知质量。因此，在实际应用中，PSNR常用于无损压缩或图像恢复领域，而SSIM常用于有损压缩或图像增强领域。</p>
<p><a href="https://blog.csdn.net/jacke121/article/details/90749274?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=D-SSIM%20Loss&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-90749274.142%5Ev96%5Epc_search_result_base2&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/jacke121/article/details/90749274?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=D-SSIM%20Loss&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-90749274.142%5Ev96%5Epc_search_result_base2&amp;spm=1018.2226.3001.4187</a></p>
<p>传统的MSE Loss对于亮度不同的相同图像太过敏感</p>
<p>所以采用了新的Structure Similarity</p>
<p>通过三个维度：</p>
<p>亮度【均值、标量】、对比度【标准差，标量】、结构【向量】&#x20;</p>
<p>那么什么叫做Mean Structural Similarity?</p>
<p>就是用滑动窗口，每个窗口都计算一个SSIM，最后取均值，就是Mean Structural Similarity.</p>
<hr>
<p>首先了解一下什么是view transformation：</p>
<p><a href="https://www.cs.helsinki.fi/group/goa/viewing/viewtransf/viewTrans.html">https://www.cs.helsinki.fi/group/goa/viewing/viewtransf/viewTrans.html</a></p>
<hr>
<h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><img data-src="/2023/10/24/3d-gaussian/image_WuGY4TLvBu.png" class>
<ol>
<li><p>用3D高斯，代替3D点云</p>
<p>为什么？</p>
<p>因为点表示不了连续辐射场，而高斯函数可以表示continuous volumetric radiance fields&#x20;</p>
<p>好处？</p>
<ol>
<li>连续的 → 方便optimization</li>
<li>避免了计算和填补原先稀疏点云以外的empty space → 节省计算资源<br>如何？<br>采用Structure-from-motion（SFM） 得到的点初始化3D gaussians,而无需用 multiview stereo（MVS）</li>
</ol>
<img data-src="/2023/10/24/3d-gaussian/image_rUNJNKkq6G.png" class>
<img data-src="/2023/10/24/3d-gaussian/image_NJpRXwKdC_.png" class>
<p>we achieve high-quality results with only SfM points as input</p>
<p>比较SFM和MVS？</p>
<blockquote>
<p>They use stereo matching and triangulation techniques to estimate the 3D coordinates of points visible in multiple images. While <strong>SfM provides only sparse information on the scene, we obtain dense 3D data: depthmaps , pointcloud , signed distance function (SDF), or a mesh</strong>.</p>
</blockquote>
</li>
<li><p>优化高斯</p>
<ol>
<li><p>interleaved opti</p>
</li>
<li><p>anistropic covariance (各向异性协方差矩阵)</p>
<p>各向同性协方差矩阵（Isotropic Covariance Matrix）是指协方差矩阵中的所有非对角线元素都相等，对角线元素表示相应随机变量的方差。</p>
<p>各向异性协方差矩阵（Anisotropic Covariance Matrix）是指协方差矩阵中的非对角线元素不全相等，表示不同随机变量之间的协方差具有差异。</p>
<p><strong>Q.为什么要用各向异性的？</strong></p>
<img data-src="/2023/10/24/3d-gaussian/image_DY8xrdZG6H.png" class>
<p><strong>各向异性：</strong></p>
<p>一个物体从各个方向看去，外观表现都是不同的</p>
<p><strong>抛雪球</strong>（splatting）：</p>
<p>3D点云 → 抛到地面上 → 散开 → 叠加 → 2D图像<br>优化了哪些3D高斯函数的参数？<br>对一个高斯：<strong>position, 透明度 alpha,  协方差矩阵，SH，add or remove</strong></p>
<img data-src="/2023/10/24/3d-gaussian/image_QUWXoxFghe.png" class>
</li>
</ol>
<ul>
<li>对高斯的操作总共其实分为三种：<ol>
<li>remove : alpha 透明度小于xxx</li>
<li>clone：under reconstruction 的空白区域 要求 position gradient &gt; 0.0002</li>
<li>split：over reconstrution 的空白区域 要求position gradient &gt; 0.0002</li>
</ol>
</li>
</ul>
</li>
<li><p>开发了一款visibility-aware rendering&#x20;</p>
<p><strong>tile-based renderer</strong></p>
<ol>
<li>【split】划分为16 * 16的小块</li>
<li>【cull】只保留与视锥体相交，并具有99%置信区间的高斯，其他全部剔除cull，为了减少计算量</li>
<li>【reject】用了guard band在一开始就拒绝处于<strong>极端位置</strong>（those with means close to the near plane and far outside the view frustum）的高斯函数 → entreme means unstable</li>
<li>实例化高斯，并给每个高斯都赋予了一个独一无二的key，基于view depth和 ID tile</li>
<li>对这些key进行排序 ？ 怎么排序？</li>
<li>每个小块tile都对应一个列表，为了确定哪些高斯函数与这个tile相关联</li>
<li>接下去进行rasterization，为每个小块启动一个线程块thread，然后对应list中的所有高斯，都将其信息load到thread中的共享区域中</li>
<li>然后对于给定的像素pixel，线程块通过从前到后遍历列表的方式来累积颜色和𝛼值</li>
<li>当alpha值达到target的时候，终止这个pixel对应的thread，而不是小块tile的，因为一个Tile包含多个pixel</li>
<li>当一个tile中的所有pixel都达到target的时候，再终止这个小块的</li>
<li>反向传播过程中，对每个小块，从后往前遍历list中的内容</li>
</ol>
<blockquote>
<p>每个像素只有在它们的深度低于或等于前向传播过程中贡献到其颜色的最后一个点的深度时，才会开始进行点的重叠测试和处理。这是为了避免不必要的计算，只有在需要的情况下才会执行昂贵的重叠测试和点的处理。</p>
</blockquote>
<p>叫做感知渲染算法</p>
<p>各向异性抛雪球（anisotropic splatting）</p>
<p>加速训练 + 实时渲染</p>
<p>supports anisotropic splatting and both accelerates training and allows real-time rendering</p>
</li>
</ol>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p>快 且 可微 → 梯度下降</p>
]]></content>
      <categories>
        <category>3D</category>
      </categories>
      <tags>
        <tag>3D Gaussian Splatting</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithm-hw-2</title>
    <url>/2022/10/22/Algorithm-hw-2/</url>
    <content><![CDATA[<p>&lt;这两天饱受算法作业折磨…,所以出现了断更…&gt;😥</p>
<img data-src="/2022/10/22/Algorithm-hw-2/19375201+%E5%BE%90%E6%A5%9A%E9%B8%A5+%E7%AE%97%E6%B3%95%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BD%9C%E4%B8%9A_00.jpg" class>
<img data-src="/2022/10/22/Algorithm-hw-2/19375201+%E5%BE%90%E6%A5%9A%E9%B8%A5+%E7%AE%97%E6%B3%95%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BD%9C%E4%B8%9A_01.jpg" class>
<img data-src="/2022/10/22/Algorithm-hw-2/19375201+%E5%BE%90%E6%A5%9A%E9%B8%A5+%E7%AE%97%E6%B3%95%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BD%9C%E4%B8%9A_02.jpg" class>
<img data-src="/2022/10/22/Algorithm-hw-2/19375201+%E5%BE%90%E6%A5%9A%E9%B8%A5+%E7%AE%97%E6%B3%95%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BD%9C%E4%B8%9A_03.jpg" class>
<img data-src="/2022/10/22/Algorithm-hw-2/19375201+%E5%BE%90%E6%A5%9A%E9%B8%A5+%E7%AE%97%E6%B3%95%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BD%9C%E4%B8%9A_04.jpg" class>
<img data-src="/2022/10/22/Algorithm-hw-2/19375201+%E5%BE%90%E6%A5%9A%E9%B8%A5+%E7%AE%97%E6%B3%95%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BD%9C%E4%B8%9A_05.jpg" class>
<img data-src="/2022/10/22/Algorithm-hw-2/19375201+%E5%BE%90%E6%A5%9A%E9%B8%A5+%E7%AE%97%E6%B3%95%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BD%9C%E4%B8%9A_06.jpg" class>
<img data-src="/2022/10/22/Algorithm-hw-2/19375201+%E5%BE%90%E6%A5%9A%E9%B8%A5+%E7%AE%97%E6%B3%95%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BD%9C%E4%B8%9A_07.jpg" class>
<img data-src="/2022/10/22/Algorithm-hw-2/19375201+%E5%BE%90%E6%A5%9A%E9%B8%A5+%E7%AE%97%E6%B3%95%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BD%9C%E4%B8%9A_08.jpg" class>
<img data-src="/2022/10/22/Algorithm-hw-2/19375201+%E5%BE%90%E6%A5%9A%E9%B8%A5+%E7%AE%97%E6%B3%95%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BD%9C%E4%B8%9A_09.jpg" class>
<img data-src="/2022/10/22/Algorithm-hw-2/19375201+%E5%BE%90%E6%A5%9A%E9%B8%A5+%E7%AE%97%E6%B3%95%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BD%9C%E4%B8%9A_10.jpg" class>
<img data-src="/2022/10/22/Algorithm-hw-2/19375201+%E5%BE%90%E6%A5%9A%E9%B8%A5+%E7%AE%97%E6%B3%95%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BD%9C%E4%B8%9A_11.jpg" class>
<p>如有错误请指出！</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>BP神经网络</title>
    <url>/2022/10/19/BP/</url>
    <content><![CDATA[<h2 id="感知机Perceptron"><a href="#感知机Perceptron" class="headerlink" title="感知机Perceptron"></a>感知机Perceptron</h2><p>由两层神经元组成，输入层接收信号传递给输出层，输出层是M-P神经元，称为阈值逻辑单元。实际上就是阶跃函数或者是Sigmoid函数。</p>
<h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ol>
<li><p>仅仅只有输入层和输出层</p>
</li>
<li><p>不能解决非线性可分问题（例如最简单的异或问题）</p>
</li>
</ol>
<h2 id="多层功能神经元"><a href="#多层功能神经元" class="headerlink" title="多层功能神经元"></a>多层功能神经元</h2><p>是解决非线性可分问题的一种方法，称为<strong>多层前馈神经网络.</strong></p>
<p><em>前馈：并不意味着网络中的信号不能后传，而是值网络拓扑结构上不存在<strong>**环或回路</strong></em></p>
<h3 id="误差逆传播算法（BackPropagation）"><a href="#误差逆传播算法（BackPropagation）" class="headerlink" title="误差逆传播算法（BackPropagation）"></a>误差逆传播算法（BackPropagation）</h3><img data-src="/2022/10/19/BP/49ec32e3a35af24588d39b2b71a081b_UxO2iSMpR6.jpg" class>
<p>给定一个训练集，输入有<code>d</code>维，输出有<code>l</code>维，对于训练样例$(x_k,y_k)$，其神经网络的输出为$\hat{y}_k=(\hat{y}^k_1…\hat{y}^k_l)$，则</p>
<script type="math/tex; mode=display">
\hat{y}^{k}_{j}=f(\beta_j-\theta_j)</script><p>则网络在$(x_k,y_k)$上的均方误差为</p>
<script type="math/tex; mode=display">
\frac{1}{2} \sum_{j=1}^{l}\left(\hat{y}_{j}^{k}-y_{j}^{k}\right)^{2}</script><p>BP是一个基于梯度下降的迭代算法，接下来以$w_{hj}$为权重进行推导：</p>
<img data-src="/2022/10/19/BP/b391f62d45e41ea566aea6f61ba27cb_x8BeMzxDDX.jpg" class>
<h4 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h4><ol>
<li><p>在输入层和输出层之间包含隐层。</p>
</li>
<li><p>标准BP每次更新只针对一个样例，所以参数更新非常频繁，相对而言，累计误差逆传递参数更新频率要低得多</p>
</li>
<li><p>BP网络由于表达能力很强，所以经常会<strong>过拟合</strong>，即训练集误差持续降低，而测试集误差持续上升。</p>
</li>
</ol>
<h4 id="如何缓和过拟合？"><a href="#如何缓和过拟合？" class="headerlink" title="如何缓和过拟合？"></a>如何缓和过拟合？</h4><ol>
<li><p>早停：训练集误差降低，但是测试机误差升高就停止训练</p>
</li>
<li><p>正则化：在误差目标函数中增加一个用于描述网络复杂度的参数$ \lambda  $，例如将目标函数变为</p>
</li>
</ol>
<script type="math/tex; mode=display">
E=\lambda \frac{1}{m}\sum E_k+(1-\lambda)\sum w^2_i</script><p>这样使得训练过程中偏好较小的连接权和阈值。</p>
<h3 id="全局最小和局部最小"><a href="#全局最小和局部最小" class="headerlink" title="全局最小和局部最小"></a>全局最小和局部最小</h3><p><strong>如何跳出局部最小，到达全局最小？</strong></p>
<ol>
<li><p>不同参数进行初始化</p>
</li>
<li><p>模拟退火，接收次优解</p>
</li>
<li><p>随机梯度下降</p>
</li>
</ol>
<h3 id="其他神经网络"><a href="#其他神经网络" class="headerlink" title="其他神经网络"></a>其他神经网络</h3><h4 id="RBF网络"><a href="#RBF网络" class="headerlink" title="RBF网络"></a>RBF网络</h4><p>单隐层前馈神经网络，先使用<strong>径向基函数</strong>作为激活函数将输入变成线性可分的，然后通过线性的输出层实现预测和分类。</p>
<script type="math/tex; mode=display">
f(x,c_i)=e^{-\beta_i||x-c_i||^2}</script><p>但是径向基函数中的中心$c_i$需要用随机采样、聚类等方式实现；$w_i$需要BP算法来确定.</p>
<h4 id="ART网络"><a href="#ART网络" class="headerlink" title="ART网络"></a>ART网络</h4><p>胜者通吃的原则</p>
<p>除了上面还有级联相关网络、Elman网路、Boltzmann机等，具体可以查阅《机器学习》这本书</p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>BP</tag>
      </tags>
  </entry>
  <entry>
    <title>Compiler-语法分析-2</title>
    <url>/2022/10/16/Chapter2-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="Chapter2-语法分析"><a href="#Chapter2-语法分析" class="headerlink" title="Chapter2-语法分析"></a>Chapter2-语法分析</h1><h3 id="具体要求"><a href="#具体要求" class="headerlink" title="具体要求"></a>具体要求</h3><h4 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">const <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CONSTTK const</span><br><span class="line">INTTK <span class="type">int</span></span><br><span class="line">IDENFR <span class="type">a</span></span><br><span class="line"><span class="variable">ASSIGN</span> <span class="operator">=</span></span><br><span class="line">INTCON <span class="number">0</span></span><br><span class="line">&lt;Number&gt;</span><br><span class="line">&lt;PrimaryExp&gt;</span><br><span class="line">&lt;UnaryExp&gt;</span><br><span class="line">&lt;MulExp&gt;</span><br><span class="line">&lt;AddExp&gt;</span><br><span class="line">&lt;ConstExp&gt;</span><br><span class="line">&lt;ConstInitVal&gt;</span><br><span class="line">&lt;ConstDef&gt;</span><br><span class="line">SEMICN ;</span><br><span class="line">&lt;ConstDecl&gt;</span><br><span class="line">INTTK <span class="type">int</span></span><br><span class="line">MAINTK main</span><br><span class="line"><span class="title function_">LPARENT</span> <span class="params">(</span></span><br><span class="line"><span class="params">RPARENT )</span></span><br><span class="line">LBRACE &#123;</span><br><span class="line">INTTK <span class="type">int</span></span><br><span class="line">IDENFR <span class="type">f</span></span><br><span class="line"><span class="variable">ASSIGN</span> <span class="operator">=</span></span><br><span class="line">INTCON <span class="number">0</span></span><br><span class="line">&lt;Number&gt;</span><br><span class="line">&lt;PrimaryExp&gt;</span><br><span class="line">&lt;UnaryExp&gt;</span><br><span class="line">&lt;MulExp&gt;</span><br><span class="line">&lt;AddExp&gt;</span><br><span class="line">&lt;Exp&gt;</span><br><span class="line">&lt;InitVal&gt;</span><br><span class="line">&lt;VarDef&gt;</span><br><span class="line">SEMICN ;</span><br><span class="line">&lt;VarDecl&gt;</span><br><span class="line">RETURNTK <span class="keyword">return</span></span><br><span class="line">INTCON <span class="number">0</span></span><br><span class="line">&lt;Number&gt;</span><br><span class="line">&lt;PrimaryExp&gt;</span><br><span class="line">&lt;UnaryExp&gt;</span><br><span class="line">&lt;MulExp&gt;</span><br><span class="line">&lt;AddExp&gt;</span><br><span class="line">&lt;Exp&gt;</span><br><span class="line">SEMICN ;</span><br><span class="line">&lt;Stmt&gt;</span><br><span class="line">RBRACE &#125;</span><br><span class="line">&lt;Block&gt;</span><br><span class="line">&lt;MainFuncDef&gt;</span><br><span class="line">&lt;CompUnit&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其实只是在上一次词法分析的基础上，将每一个非终结符也输出，所以要构造每个非终结符的处理函数，形成一颗递归树，当然也可不不用形成递归树，但是递归树有利于之后的代码生成。</p>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><h4 id="消除左递归"><a href="#消除左递归" class="headerlink" title="消除左递归"></a>消除左递归</h4><p>消除左递归的方法主要有三种：</p>
<p>规则1：（提因子）$U::=xy|xw|…|xz$可替换为$U::=x(y|w|…|z)$</p>
<p>规则2：$U::=x|y|…|z|Uv$可替换为$U::=(x|y|…|z)\{v\}$</p>
<p>规则3：</p>
<img data-src="/2022/10/16/Chapter2-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/image_tIfPdAEwrh.png" class>
<p>我这里用的是规则三：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MulExp → UnaryExp | MulExp (<span class="string">&#x27;*&#x27;</span> | <span class="string">&#x27;/&#x27;</span> | <span class="string">&#x27;%&#x27;</span>) UnaryExp</span><br><span class="line">消除左递归：</span><br><span class="line">MulExp → UnaryExp MulExp2</span><br><span class="line">MulExp2 → (<span class="string">&#x27;*&#x27;</span> | <span class="string">&#x27;/&#x27;</span> | <span class="string">&#x27;%&#x27;</span>) UnaryExp MulExp2 | e</span><br><span class="line"></span><br><span class="line">AddExp → MulExp | AddExp (<span class="string">&#x27;+&#x27;</span> | <span class="string">&#x27;−&#x27;</span>) MulExp</span><br><span class="line">消除左递归：</span><br><span class="line">AddExp → MulExp AddExp2</span><br><span class="line">AddExp2 → (<span class="string">&#x27;+&#x27;</span> | <span class="string">&#x27;−&#x27;</span>) MulExp AddExp2 | e</span><br><span class="line"></span><br><span class="line">RelExp → AddExp | RelExp (<span class="string">&#x27;&lt;&#x27;</span> | <span class="string">&#x27;&gt;&#x27;</span> | <span class="string">&#x27;&lt;=&#x27;</span> | <span class="string">&#x27;&gt;=&#x27;</span>) AddExp</span><br><span class="line">消除左递归：</span><br><span class="line">RelExp → AddExp RelExp2</span><br><span class="line">RelExp2 → (<span class="string">&#x27;&lt;&#x27;</span> | <span class="string">&#x27;&gt;&#x27;</span> | <span class="string">&#x27;&lt;=&#x27;</span> | <span class="string">&#x27;&gt;=&#x27;</span>) AddExp RelExp2 | e</span><br><span class="line"></span><br><span class="line">EqExp → RelExp | EqExp (<span class="string">&#x27;==&#x27;</span> | <span class="string">&#x27;!=&#x27;</span>) RelExp</span><br><span class="line">消除左递归：</span><br><span class="line">EqExp → RelExp EqExp2</span><br><span class="line">EqExp2 → (<span class="string">&#x27;==&#x27;</span> | <span class="string">&#x27;!=&#x27;</span>) RelExp EqExp2 | e</span><br><span class="line"></span><br><span class="line">LAndExp → EqExp | LAndExp <span class="string">&#x27;&amp;&amp;&#x27;</span> EqExp</span><br><span class="line">消除左递归：</span><br><span class="line">LAndExp → EqExp LAndExp2</span><br><span class="line">LAndExp2 → <span class="string">&#x27;&amp;&amp;&#x27;</span> EqExp LAndExp2 | e</span><br><span class="line"></span><br><span class="line">LOrExp → LAndExp | LOrExp <span class="string">&#x27;||&#x27;</span> LAndExp</span><br><span class="line">消除左递归：</span><br><span class="line">LOrExp → LAndExp LOrExp2 </span><br><span class="line">LOrExp2 → <span class="string">&#x27;||&#x27;</span> LAndExp LOrExp2 | e</span><br></pre></td></tr></table></figure>
<p>其实后面发现用规则二其实更简单…</p>
<p>故消除左递归之后的文法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompUnit → &#123;Decl&#125; &#123;FuncDef&#125; MainFuncDef </span><br><span class="line">Decl → ConstDecl | VarDecl</span><br><span class="line">ConstDecl → <span class="string">&#x27;const&#x27;</span> BType ConstDef &#123; <span class="string">&#x27;,&#x27;</span> ConstDef &#125; <span class="string">&#x27;;&#x27;</span></span><br><span class="line">BType → <span class="string">&#x27;int&#x27;</span></span><br><span class="line">ConstDef → Ident &#123; <span class="string">&#x27;[&#x27;</span> ConstExp <span class="string">&#x27;]&#x27;</span> &#125; <span class="string">&#x27;=&#x27;</span> ConstInitVal</span><br><span class="line">ConstInitVal → ConstExp | <span class="string">&#x27;&#123;&#x27;</span> [ ConstInitVal &#123; <span class="string">&#x27;,&#x27;</span> ConstInitVal &#125; ] <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line">VarDecl → BType VarDef &#123; <span class="string">&#x27;,&#x27;</span> VarDef &#125; <span class="string">&#x27;;&#x27;</span></span><br><span class="line">VarDef → Ident &#123; <span class="string">&#x27;[&#x27;</span> ConstExp <span class="string">&#x27;]&#x27;</span> &#125;  [‘=’ InitVal]</span><br><span class="line">InitVal → Exp | <span class="string">&#x27;&#123;&#x27;</span> [ InitVal &#123; <span class="string">&#x27;,&#x27;</span> InitVal &#125; ] <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line">FuncDef → FuncType Ident <span class="string">&#x27;(&#x27;</span> [FuncFParams] <span class="string">&#x27;)&#x27;</span> Block</span><br><span class="line">MainFuncDef → <span class="string">&#x27;int&#x27;</span> <span class="string">&#x27;main&#x27;</span> <span class="string">&#x27;(&#x27;</span> <span class="string">&#x27;)&#x27;</span> Block</span><br><span class="line">FuncType → <span class="string">&#x27;void&#x27;</span> | <span class="string">&#x27;int&#x27;</span></span><br><span class="line">FuncFParams → FuncFParam &#123; <span class="string">&#x27;,&#x27;</span> FuncFParam &#125;</span><br><span class="line">FuncFParam → BType Ident [<span class="string">&#x27;[&#x27;</span> <span class="string">&#x27;]&#x27;</span> &#123; <span class="string">&#x27;[&#x27;</span> ConstExp <span class="string">&#x27;]&#x27;</span> &#125;]</span><br><span class="line">Block → <span class="string">&#x27;&#123;&#x27;</span> &#123; BlockItem &#125; <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line">BlockItem → Decl | Stmt</span><br><span class="line">Stmt → LVal <span class="string">&#x27;=&#x27;</span> Exp <span class="string">&#x27;;&#x27;</span> </span><br><span class="line">    | [Exp] <span class="string">&#x27;;&#x27;</span> </span><br><span class="line">    | Block | <span class="string">&#x27;if&#x27;</span> <span class="string">&#x27;(&#x27;</span> Cond <span class="string">&#x27;)&#x27;</span> Stmt [ <span class="string">&#x27;else&#x27;</span> Stmt ] </span><br><span class="line">    | <span class="string">&#x27;while&#x27;</span> <span class="string">&#x27;(&#x27;</span> Cond <span class="string">&#x27;)&#x27;</span> Stmt </span><br><span class="line">    | <span class="string">&#x27;break&#x27;</span> <span class="string">&#x27;;&#x27;</span> | <span class="string">&#x27;continue&#x27;</span> <span class="string">&#x27;;&#x27;</span> </span><br><span class="line">    | <span class="string">&#x27;return&#x27;</span> [Exp] <span class="string">&#x27;;&#x27;</span> </span><br><span class="line">    | LVal <span class="string">&#x27;=&#x27;</span> <span class="string">&#x27;getint&#x27;</span><span class="string">&#x27;(&#x27;</span><span class="string">&#x27;)&#x27;</span><span class="string">&#x27;;&#x27;</span> </span><br><span class="line">    | <span class="string">&#x27;printf&#x27;</span><span class="string">&#x27;(&#x27;</span>FormatString&#123;<span class="string">&#x27;,&#x27;</span>Exp&#125;<span class="string">&#x27;)&#x27;</span><span class="string">&#x27;;&#x27;</span> </span><br><span class="line">Exp → AddExp</span><br><span class="line">Cond → LOrExp</span><br><span class="line">LVal → Ident &#123;<span class="string">&#x27;[&#x27;</span> Exp <span class="string">&#x27;]&#x27;</span>&#125;</span><br><span class="line">PrimaryExp → <span class="string">&#x27;(&#x27;</span> Exp <span class="string">&#x27;)&#x27;</span> | LVal | Number</span><br><span class="line">Number → IntConst</span><br><span class="line">UnaryExp → PrimaryExp | Ident <span class="string">&#x27;(&#x27;</span> [FuncRParams] <span class="string">&#x27;)&#x27;</span>| UnaryOp UnaryExp  朝前看，因为ident有交集</span><br><span class="line">UnaryOp → <span class="string">&#x27;+&#x27;</span> | <span class="string">&#x27;−&#x27;</span> | <span class="string">&#x27;!&#x27;</span></span><br><span class="line">FuncRParams → Exp &#123; <span class="string">&#x27;,&#x27;</span> Exp &#125;</span><br><span class="line">MulExp → UnaryExp MulExp2</span><br><span class="line">MulExp2 → (<span class="string">&#x27;*&#x27;</span> | <span class="string">&#x27;/&#x27;</span> | <span class="string">&#x27;%&#x27;</span>) UnaryExp MulExp2 | e</span><br><span class="line">AddExp → MulExp AddExp2</span><br><span class="line">AddExp2 → (<span class="string">&#x27;+&#x27;</span> | <span class="string">&#x27;−&#x27;</span>) MulExp AddExp2 | e</span><br><span class="line">RelExp → AddExp RelExp2</span><br><span class="line">RelExp2 → (<span class="string">&#x27;&lt;&#x27;</span> | <span class="string">&#x27;&gt;&#x27;</span> | <span class="string">&#x27;&lt;=&#x27;</span> | <span class="string">&#x27;&gt;=&#x27;</span>) AddExp RelExp2 | e</span><br><span class="line">EqExp → RelExp EqExp2</span><br><span class="line">EqExp2 → (<span class="string">&#x27;==&#x27;</span> | <span class="string">&#x27;!=&#x27;</span>) RelExp EqExp2 | e</span><br><span class="line">LAndExp → EqExp LAndExp2</span><br><span class="line">LAndExp2 → <span class="string">&#x27;&amp;&amp;&#x27;</span> EqExp LAndExp2 | e</span><br><span class="line">LOrExp → LAndExp LOrExp2 </span><br><span class="line">LOrExp2 → <span class="string">&#x27;||&#x27;</span> LAndExp LOrExp2 | e</span><br><span class="line">ConstExp → AddExp </span><br></pre></td></tr></table></figure>
<h4 id="构建FIRST集"><a href="#构建FIRST集" class="headerlink" title="构建FIRST集"></a>构建FIRST集</h4><div class="table-container">
<table>
<thead>
<tr>
<th>Node</th>
<th>FIRST</th>
<th>ps</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>CompUnit</strong></td>
<td>{Decl,FuncDef}</td>
<td>超前判断</td>
</tr>
<tr>
<td><strong>BlockItem</strong></td>
<td>{Decl,Stmt}</td>
<td></td>
</tr>
<tr>
<td><strong>Stmt</strong></td>
<td>{Block,<code>if</code>,<code>while</code>,<code>break</code>,<code>return</code>,<code>printf</code>,LVal,Exp}</td>
<td>超前判断</td>
</tr>
<tr>
<td><strong>Decl</strong></td>
<td>{ConstDecl ,VarDecl}</td>
<td></td>
</tr>
<tr>
<td><strong>FuncDef</strong></td>
<td>{FuncType }</td>
<td></td>
</tr>
<tr>
<td><strong>VarDecl</strong></td>
<td>{BType }</td>
<td></td>
</tr>
<tr>
<td><strong>ConstInitVal</strong></td>
<td>{<code>&#123;</code>,ConstExp}</td>
<td></td>
</tr>
<tr>
<td><strong>InitVal</strong></td>
<td>{<code>&#123;</code>,Exp}</td>
<td></td>
</tr>
<tr>
<td><strong>Cond</strong></td>
<td>{LOrExp}</td>
<td></td>
</tr>
<tr>
<td><strong>LOrExp</strong></td>
<td>{LAndExp }</td>
<td></td>
</tr>
<tr>
<td><strong>LAndExp</strong></td>
<td>{EqExp }</td>
<td></td>
</tr>
<tr>
<td><strong>EqExp</strong></td>
<td>{RelExp }</td>
<td></td>
</tr>
<tr>
<td><strong>RelExp</strong></td>
<td>{AddExp }</td>
<td></td>
</tr>
<tr>
<td><strong>FuncFParams</strong></td>
<td>{FuncFParam }</td>
<td></td>
</tr>
<tr>
<td><strong>FuncFParam</strong></td>
<td>{BType }</td>
<td></td>
</tr>
<tr>
<td><strong>FuncRParams</strong></td>
<td>{Exp }</td>
<td></td>
</tr>
<tr>
<td><strong>Exp</strong></td>
<td>{AddExp}</td>
<td></td>
</tr>
<tr>
<td><strong>ConstExp</strong></td>
<td>{AddExp}</td>
<td></td>
</tr>
<tr>
<td><strong>AddExp</strong></td>
<td>{MulExp }</td>
<td></td>
</tr>
<tr>
<td><strong>MulExp</strong></td>
<td>{UnaryExp }</td>
<td></td>
</tr>
<tr>
<td><strong>UnaryExp</strong></td>
<td>{PrimaryExp,<code>IDENT</code>,UnaryOp}</td>
<td>超前判断</td>
</tr>
<tr>
<td><strong>PrimaryExp</strong></td>
<td>{<code>(</code>,LVal,Number}</td>
<td></td>
</tr>
<tr>
<td><strong>ConstDef</strong></td>
<td>{<code>IDENT</code>}</td>
<td></td>
</tr>
<tr>
<td><strong>VarDef</strong></td>
<td>{<code>IDENT</code>}</td>
<td></td>
</tr>
<tr>
<td><strong>FuncType</strong></td>
<td>{<code>void</code>,<code>int</code>}</td>
<td></td>
</tr>
<tr>
<td><strong>Block</strong></td>
<td>{<code>&#123;</code>}</td>
<td></td>
</tr>
<tr>
<td><strong>BType</strong></td>
<td>{<code>INTTK</code>}</td>
<td></td>
</tr>
<tr>
<td><strong>Number</strong></td>
<td>{<code>INTCON</code>}</td>
<td></td>
</tr>
<tr>
<td><strong>LVal</strong></td>
<td>{<code>IDENT</code>}</td>
<td></td>
</tr>
<tr>
<td><strong>UnaryOp</strong></td>
<td>{<code>+</code>，<code>-</code>，<code>！</code>}</td>
<td></td>
</tr>
<tr>
<td><strong>MulExp2</strong></td>
<td>{e,<code>*</code>,<code>/</code>,<code>%</code>}</td>
<td></td>
</tr>
<tr>
<td><strong>AddExp2</strong></td>
<td>{<code>+</code>,<code>-</code>,e}</td>
<td></td>
</tr>
<tr>
<td><strong>MainFuncDef</strong></td>
<td>{<code>int</code>}</td>
<td></td>
</tr>
<tr>
<td><strong>ConstDecl</strong></td>
<td>{<code>const</code>}</td>
<td></td>
</tr>
<tr>
<td><strong>RelExp2</strong></td>
<td>{<code>&lt;</code>,<code>&gt;</code>,<code>&lt;=</code>,<code>&gt;=</code>,e}</td>
<td></td>
</tr>
<tr>
<td><strong>EqExp2</strong></td>
<td>{<code>==</code>,<code>!=</code>,e}</td>
<td></td>
</tr>
<tr>
<td><strong>LAndExp2</strong></td>
<td>{<code>&amp;&amp;</code>,e}</td>
<td></td>
</tr>
<tr>
<td><strong>LOrExp2</strong></td>
<td>{<code>OR</code>,e}</td>
</tr>
</tbody>
</table>
</div>
<p>构建FIRST集：<strong>从下往上写</strong>！我将FIRST集写在了<code>Tag</code> 类里面，之后直接调用即可。表格中的<strong>超前判断</strong>指的是其FIRST集中有交集！！</p>
<p><code>Tag</code> 类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tag</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> ArrayList&lt;String&gt;</span><br><span class="line">            LOrExp2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;() &#123;</span><br><span class="line">                &#123;</span><br><span class="line">                    add(<span class="string">&quot;OR&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            LAndExp2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;() &#123;</span><br><span class="line">                &#123;</span><br><span class="line">                    add(<span class="string">&quot;AND&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            ...</span><br><span class="line">            ...</span><br><span class="line">            Stmt = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;() &#123;</span><br><span class="line">                &#123;</span><br><span class="line">                    add(<span class="string">&quot;IFTK&quot;</span>);</span><br><span class="line">                    add(<span class="string">&quot;WHILETK&quot;</span>);</span><br><span class="line">                    add(<span class="string">&quot;BREAKTK&quot;</span>);</span><br><span class="line">                    add(<span class="string">&quot;RETURNTK&quot;</span>);</span><br><span class="line">                    add(<span class="string">&quot;PRINTFTK&quot;</span>);</span><br><span class="line">                    add(<span class="string">&quot;SEMICN&quot;</span>);</span><br><span class="line">                    add(<span class="string">&quot;CONTINUETK&quot;</span>);</span><br><span class="line">                    addAll(Block);</span><br><span class="line">                    addAll(LVal);</span><br><span class="line">                    addAll(Exp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            ...</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure>
<p>所以<strong>从下往上</strong>写就能保证之后的FIRST能够直接调用已经写好的FIRST集，例如<code>stmt</code>里就可以用<code>addAll(Block)</code> 将Block的FIRST集全部加到<code>Stmt</code> 的FIRST集合里。所以构建FIRST集其实很简单，直接看文法构建其实也行，不过还是重新写一张表比较保险.</p>
<h4 id="递归下降法"><a href="#递归下降法" class="headerlink" title="递归下降法"></a>递归下降法</h4><p>构造一棵递归树，这颗递归树是由结点<code>Node</code>类构成的，每个结点包含自己的<code>token</code>和<code>childList</code> （用于存放其下面的孩子结点）；而<code>token</code>类包含<code>type</code>，<code>word</code>，<code>line</code>,其实就是词法分析输出的三个hashmap，用来组成Token流。</p>
<p>但是需要注意的是这些token流仅仅只是终结符结点，因此每次走到非终结符，应该自己给这个<code>node</code>填一个标签<code>token</code>上去，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">Decl</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">nDecl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="keyword">new</span> <span class="title class_">Token</span>(<span class="string">&quot;&lt;Decl&gt;&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span> (curToken.match(Tag.ConsDecl)) &#123;</span><br><span class="line">            nDecl.addChild(ConstDecl());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curToken.match(Tag.VarDecl)) &#123;</span><br><span class="line">            nDecl.addChild(VarDecl());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//错误处理:Decl</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nDecl;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>同时，递归下降的思路也如上述代码所示，如果当前令牌根据文法在某个非终结符的<code>FIRST</code>集里，则进行解析，调用相应的函数，同时也要<strong>为后续的错误处理留有余地</strong>。</p>
<p>递归下降处理程序我用的是<code>SyntaxParser</code> 的类，其类图如下所示：</p>
<img data-src="/2022/10/16/Chapter2-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/image_UtjGJ1nJiY.png" class>
<ol>
<li><p><code>inputStream</code>要在词法分析的时候就处理好，将<code>token</code>流输出，然后输入语法分析；</p>
</li>
<li><p><code>index</code>是<code>curToken</code>所处输入流中的索引，同时也可以用作<strong>超前读入</strong>；</p>
</li>
<li><p><code>stopList</code>和<code>reverseList</code>仅仅是用于输出的时候，在<code>stopList</code>里的结点不输出；在<code>reverseList</code>（消除左递归带来产生的<code>MulExp2</code>之类的结点）里的结点，输出顺序是<strong>根-孩子</strong>，其余的输出方式就是<strong>孩子-根。</strong></p>
</li>
</ol>
<p>方法部分不详述了。</p>
<h4 id="UML图总体实现"><a href="#UML图总体实现" class="headerlink" title="UML图总体实现"></a>UML图总体实现</h4><img data-src="/2022/10/16/Chapter2-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/image_o47x5NQclB.png" class>
<h3 id="注意细节"><a href="#注意细节" class="headerlink" title="注意细节"></a>注意细节</h3><ol>
<li><p>每次加入终结符之后，都要<code>nextToken()</code>获得下一个令牌.</p>
</li>
<li><p>{xxx}这种用<code>while</code>判断，注意什么时候并列判断，什么时候嵌套判断。</p>
</li>
<li><p>对于<code>Stmt</code>：先把<code>if</code>等保留字判断之后再判断<code>LVal</code>,<code>Exp</code>,<code>Block</code>。其中超前判断（<code>LVal</code>后面一定有<code>=</code>,<code>Exp</code>没有）</p>
</li>
</ol>
<hr>
<h4 id="期中注意事项（关于机房）"><a href="#期中注意事项（关于机房）" class="headerlink" title="期中注意事项（关于机房）"></a>期中注意事项（关于机房）</h4><p>Settings&#x20;</p>
<ol>
<li><p><strong>设置字体</strong></p>
<p>Editor font 15</p>
</li>
<li><p>设置自动补全<br>Keymap  设置按键<br>Duplicate &#x20;<br>Mainmenu&#x20;<br>Code &#x20;<br>Completion &#x20;<br>remove ctrl+空格 &#x20;<br>add shortcut&#x20;<br>alt+/</p>
</li>
<li><p>不能debug的问题：</p>
<p>在c/Users/Administrator/IdeaProjects中创建项目，不要在D盘创建！！</p>
</li>
</ol>
<p>明天就是期中了，FOCUS ON MYSELF！</p>
]]></content>
      <categories>
        <category>Compiler</category>
      </categories>
  </entry>
  <entry>
    <title>Compiler-建立符号表&amp;错误处理-3</title>
    <url>/2022/11/07/Compiler-%E5%BB%BA%E7%AB%8B%E7%AC%A6%E5%8F%B7%E8%A1%A8-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86-3/</url>
    <content><![CDATA[<h1 id="建立符号表和错误处理"><a href="#建立符号表和错误处理" class="headerlink" title="建立符号表和错误处理"></a>建立符号表和错误处理</h1><h3 id="类图："><a href="#类图：" class="headerlink" title="类图："></a>类图：</h3><img data-src="/2022/11/07/Compiler-%E5%BB%BA%E7%AB%8B%E7%AC%A6%E5%8F%B7%E8%A1%A8-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86-3/image_krPvZ6NiKE.png" class>
<p><strong>说明：</strong></p>
<ol>
<li><p>Compiler是程序的入口</p>
</li>
<li><p>Morpho是词法分析器（ReadFile读入testfile.txt文件）</p>
</li>
<li><p>SyntaxParser是语法分析器</p>
</li>
<li><p>SymbolTable 是符号表类</p>
</li>
<li><p>RParam 是函数实参表类</p>
</li>
<li><p>Error 是错误处理类</p>
</li>
<li><p>Node 是递归下降树构建的结点类</p>
</li>
<li><p>Symbol 是符号类</p>
</li>
<li><p>Token 是词牌类</p>
</li>
<li><p>Tag 是First集类</p>
</li>
</ol>
<h3 id="符号表类"><a href="#符号表类" class="headerlink" title="符号表类"></a>符号表类</h3><img data-src="/2022/11/07/Compiler-%E5%BB%BA%E7%AB%8B%E7%AC%A6%E5%8F%B7%E8%A1%A8-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86-3/image_Od3GLVPUlM.png" class>
<p><strong>什么时候要创建符号表？</strong></p>
<ol>
<li><p><code>CompUnit</code>时创建一个rootTable，其prev上层符号表为 <code>null</code>&#x20;</p>
</li>
<li><p><code>FuncDef</code> 函数定义时</p>
</li>
<li><p><code>MainFuncDef</code> 进入主函数int main时</p>
</li>
<li><p><code>Block</code> 扫描到<code>&#123;</code> ，且当前符号表的<code>defend</code>为<code>false</code>时</p>
</li>
</ol>
<p><strong>说明：</strong></p>
<ol>
<li><p><code>table</code>类型为<code>HashMap</code>。<code>key</code>存储<code>Symbol</code>的<code>name</code>，<code>value</code>存储对应的<code>Symbol</code>&#x20;</p>
</li>
<li><p><code>prev</code> 类型为<code>SymbolTable</code> ，上一层的符号表</p>
</li>
<li><p><code>isFunc</code> 用于判别此符号表是否为函数定义创建的表</p>
</li>
<li><p><code>position</code> 用于记录当前符号表在上一层符号表的环境位置，其值为这个符号表创建时，当前符号表<code>curTable</code> 中<code>table</code>的size()</p>
<p>（后面发现似乎并不需要这个属性，因为在错误处理的时候是递归过程中进行的）</p>
</li>
<li><p><code>existReturn</code> 用于判别当前符号表是函数时，是否存在<code>return</code> 语句。</p>
</li>
<li><p><code>defend</code> 只有在函数定义创建符号表的时候设为<code>true</code> ，当进入函数定义的<code>Block</code>中时，不必再创建一个符号表了，因为在扫描到函数名称的时候就创建过了，之后设置为<code>false</code> 意味着当前函数符号表已经进入到过其本身的<code>Block</code>中了</p>
</li>
<li><p><code>funcName</code> 和<code>funcType</code> 用于记录当前符号表(函数定义)的函数名称和函数类型.</p>
</li>
</ol>
<h3 id="符号类"><a href="#符号类" class="headerlink" title="符号类"></a>符号类</h3><img data-src="/2022/11/07/Compiler-%E5%BB%BA%E7%AB%8B%E7%AC%A6%E5%8F%B7%E8%A1%A8-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86-3/image_fHo_eToku4.png" class>
<p><strong>什么时候加入符号？</strong></p>
<ol>
<li><p><code>ConstDef</code> 常量定义</p>
</li>
<li><p><code>VarDef</code> 变量定义</p>
</li>
<li><p><code>FuncDef</code> 函数定义，加入到当前符号表中，一般是<code>rootTable</code></p>
</li>
<li><p><code>FuncFParam</code> 函数形参，加入到当前函数符号表中</p>
</li>
</ol>
<p><strong>什么时候查询符号？</strong></p>
<ol>
<li><p><code>Stmt</code> 中扫描到<code>LVal</code> 时，是否改变常量</p>
</li>
<li><p><code>LVal</code> 中查询符号（普通变量，一维数组，二维数组）的维度；</p>
</li>
<li><p><code>UnaryExp</code> 中查询符号（函数调用）的维度</p>
</li>
</ol>
<blockquote>
<p>上述2/3查询的维度最终加入当前函数的实参列表中，用于错误处理，判断函数调用实参个数和类型(维度)是否匹配</p>
</blockquote>
<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><ol>
<li><p>b类错误名字重定义：</p>
<p>🧐下面这种也算错误？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> a)</span> &#123;&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> a)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>e类错误：</strong> 函数中f(RParam)   a[Exp] 所以说</p>
<p>所以存在a(LVal加入当前函数)[Exp→LVal(<del><strong>加入当前函数</strong></del>)]</p>
<p>因此在解读LVal时不应该盲目地将当前的LVal加入当前的函数实参paramMap中，例如&#x20;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x)</span> &#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">f(a[<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">f(a(<span class="number">0</span>)[(<span class="number">1</span>)b(<span class="number">0</span>)[(<span class="number">1</span>)<span class="number">1</span>(<span class="number">0</span>)](-<span class="number">1</span>)](-<span class="number">2</span>)[(-<span class="number">1</span>)i(<span class="number">0</span>)](-<span class="number">1</span>)); </span><br><span class="line">f(a[f(a[i])][<span class="number">0</span>]); <span class="comment">//内层函数调用类型出错</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>那是不是也意味着会有</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">const <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">a[f(n)];</span><br></pre></td></tr></table></figure>
<p>但是这种没要求检测类型不匹配的问题；要求检测函数类型不匹配。</p>
<p><strong>解决方法：</strong><del><strong>每当进入’[‘中，就会有widthreal++，说明在[]内时widthreal不为0，则只有当widthreal为零的时候才加入curParam的map中</strong></del><strong>。</strong></p>
<p>上述解决方法不行，如果将widthReal设置成全局的，则嵌套调用时上一层的widthReal会丢失，所以想到的解决办法是，每当<strong>调用</strong>LVal的时候，就新建一个存储其…</p>
<p>其实发现第一种解决方法也是可行的？：</p>
<p><del><strong>每次扫描到LVal的IDENFR就设置为0,扫描到[就++,扫描到]就减一，但是如果inArray = 0 时扫描到]不要减一了，要保证其永远大于等于0，因为a[b[1]]此处inArray = -1当a[b[1]][此处inArray为零，不正确了i]</strong></del></p>
<p>总结：很简单的思路，当前curParam不等于null，<code>[</code>时inArray加一，<code>]</code>时inArray减一，只有当 <code>inArray = 0</code> 时加入当前的curParam的实参列表中即可.(inArray为全局变量.)</p>
<p>上面的还是<strong>不对</strong>….例如 <code>f(a[1][sum(a[0])])</code> 在sum函数中的a[0]就加入不到sum的实参列表中了，所以在RParam中加一个私有参数inArray，而不是全局！</p>
<p><strong>测试用例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x)</span> &#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a)</span> &#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">h</span><span class="params">()</span>&#123;;&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">int</span> v[<span class="number">3</span>], i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>( f(a[<span class="number">1</span>][sum(a[<span class="number">0</span>])]))  &#123;&#125;; <span class="comment">//e错误</span></span><br><span class="line">  <span class="keyword">if</span>( f(a[<span class="number">1</span>][sum(a[<span class="number">0</span>][<span class="number">1</span>])]))  &#123;&#125;; <span class="comment">//正确</span></span><br><span class="line">  f(h());<span class="comment">//e错误</span></span><br><span class="line">  f(a[i]);<span class="comment">//e错误</span></span><br><span class="line">  f(a[i][i+<span class="number">1</span>]);<span class="comment">//正确</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意在构造测试用例的时候：Decl和FuncDef是先后顺序。</p>
</li>
<li><p>对最终输出排序输出用TreeMap</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TreeMap</span> <span class="variable">sotrdMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(errMap);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>对于循环嵌套，多个while需要判断是否是错误的。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Compiler</category>
      </categories>
  </entry>
  <entry>
    <title>IP</title>
    <url>/2024/12/26/IP/</url>
    <content><![CDATA[<img data-src="/2024/12/26/IP/0.png" class>
<img data-src="/2024/12/26/IP/1.png" class>
]]></content>
      <categories>
        <category>CV</category>
      </categories>
      <tags>
        <tag>Research</tag>
      </tags>
  </entry>
  <entry>
    <title>Dataset Quantization</title>
    <url>/2023/12/21/Dataset-Quantization/</url>
    <content><![CDATA[<h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>现在的SOTA模型往往都是需要通过大量的数据和GPU等硬件训练资源训练得到的，包括LLM和CV。</p>
<p>于是出现了<strong>数据蒸馏</strong>,旨在合成小规模的数据集.但是这种<strong>合成的数据集</strong>在新的架构上并没有好的表现.</p>
<p>于是提出了DQ(Dataset Quantization),就是将一个很大的数据集压缩成一些小的子集,然后用这些子集训练神经网络．</p>
<p><strong>特点:</strong></p>
<ul>
<li>SOTA的数据集压缩比 compression ratio</li>
<li>在unseen network architecture上训练</li>
</ul>
<p><strong>结果：</strong></p>
<p>通过60%的ImageNet数据集+20%的Alpaca的instruction tuning data训练, 在各种vision tasks上都没有明显的性能下降.</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>深度学习网络在CV和NLP领域都表现出色，并且对数据的依赖很高．</p>
<p><em>奥,我知道了,就是先用自己的3 billion的数据集在模型训练, 然后让训练好的模型在ImageNet-1K上test,得到的就是SOTA模型．</em></p>
<p>所以就会想, 是不是数据集中的所有数据都是有用的呢?有没有冗余的数据,可以删掉并且不影响下游任务的呢?</p>
<p>下图:虽然显示了经过DQ框架之后确实压缩率很高,尤其是LLM部分，但是同样也没有说结果差了多少，还是说几乎持平？．</p>
<img data-src="/2023/12/21/Dataset-Quantization/image_SlWzGNJHUK.png" class>
<p>什么是data keep ratio?</p>
<img data-src="/2023/12/21/Dataset-Quantization/image_MMS6xhs6IA.png" class>
<p>data keep ratio就是数据保留比例,就是我压缩之后和原始数据的比例.相当于data compression ratio,就是数据压缩比.</p>
<p>下图2b中当data keep ratio为20%(很低)的时候, synthesized dataset就会丧失diversity~</p>
<img data-src="/2023/12/21/Dataset-Quantization/image_Q8zlLB9-CP.png" class>
<p>DQ和coreset selection以及dataset distillation相比,可以发现DQ能够顾全大局~所以表现比较好.</p>
<p>没太看懂的这个图的意思是什么:</p>
<img data-src="/2023/12/21/Dataset-Quantization/image__JgXbzzLIQ.png" class>
<img data-src="/2023/12/21/Dataset-Quantization/image_660hvQzmc5.png" class>
<p>意思就是根据ResNet-18架构得到的合成数据集在Swin-Tiny上的效果很差.</p>
<p>大概的思路是: (粗略地用鼠标画了一个图哈哈)</p>
<img data-src="/2023/12/21/Dataset-Quantization/image_D8b70MeDTT.png" class>
<p>如果是原本的DM（dataset matching）进行数据压缩, 需要大量的计算资源, 比如28000GPU小时才能将IN-1K压缩到60%.</p>
<p>提出的方法:</p>
<p>coreset methods  + dataset distillation</p>
<p>具体而言:</p>
<ol>
<li>将数据集划分为不重叠的bins</li>
<li>在每个bins里面采样</li>
<li>并计算其重要程度</li>
<li>训练阶段用重要的patches和预训练好的MAE模型重组数据集</li>
</ol>
<h1 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h1><h2 id="Dataset-Distillation-数据集蒸馏"><a href="#Dataset-Distillation-数据集蒸馏" class="headerlink" title="Dataset Distillation [数据集蒸馏]"></a>Dataset Distillation [数据集蒸馏]</h2><img data-src="/2023/12/21/Dataset-Quantization/image_xsXv8zsgwK.png" class>
<p>缺点:&#x20;</p>
<ol>
<li>poor-generalizability, 指的是在cross-architecture表现差</li>
<li>poor scalability,指的是随着data keep ratio的上升, 很快就饱和了,上限不够高</li>
<li>需要消耗大量的计算资源</li>
</ol>
<p>但是上面的缺点, 全部都被coreset methods解决了????</p>
<h2 id="Coreset-Methods"><a href="#Coreset-Methods" class="headerlink" title="Coreset Methods"></a>Coreset Methods</h2><p>就是核心集, 其实就是找到一个子集 , 是representative sampling.</p>
<p>缺点:</p>
<ol>
<li>在low data keep ratio下, 数据的diversity很难保证.</li>
</ol>
<h1 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h1><p>由于data matching metrics是和网络架构绑定在一起的,所以我们的目标是找到一个对模型架构不敏感的data selection strategy~</p>
<h2 id="Coreset-Selection"><a href="#Coreset-Selection" class="headerlink" title="Coreset Selection"></a>Coreset Selection</h2><p>这个方法虽然解决了DD的缺陷,但是带来了<strong>selectioni bias</strong> (在density比较高的地方更容易被选中).</p>
<p>我们接下来用theoretical的方法来分析:</p>
<p>我们选择SOTA方法(GraphCut)来分析.</p>
<p>现在有一个数据集D:</p>
<img data-src="/2023/12/21/Dataset-Quantization/image_IplQCUxgvR.png" class>
<p>我们默认要从中选出K个样本来组成一个coreset.</p>
<p>前面有提到说先要划分成non-overlapping的bins.在划分好之后,对于每一个bin的更新方法:</p>
<img data-src="/2023/12/21/Dataset-Quantization/image_TZyPpO8TEw.png" class>
<p>表示对于第1个bin而言,first k-1 sample并上xk得到S1的first k sample.</p>
<p>在初始化好S11之后,如何选择xk就成为了问题的关键. GraphCut采用的是maximize下面的式子(1):</p>
<img data-src="/2023/12/21/Dataset-Quantization/image_78pUag8zYg.png" class>
<p><strong>其实一个很简单的思想就是: 让选定的数据集具有更大的diversity.</strong></p>
<p>所以对于xk而言,要求其和Sk-1里面的所有样本差异尽可能大,并且和Sk-1的互斥集差异尽可能小, 得到的xk就是当前要找的那个样本.</p>
<p>但是上面式子的问题在于:</p>
<p>K&lt;\&lt;M,即每个bin要选择的样本数远远小于数据总量M.</p>
<p>这将导致C1 &lt;&lt; C2, 所以C2就处在了dominant position上, 最后的diversity效果也不理想.</p>
<p>哦,文中有说supposing the average feature at the origin,所以按照下图的意思,就会导致每次选的xk都会在average feature的附近,导致缺少了数据选择的diversity.</p>
<img data-src="/2023/12/21/Dataset-Quantization/image_hDdS6mk7uX.png" class>
<img data-src="/2023/12/21/Dataset-Quantization/image_UiN_lRTV25.png" class>
<p>为什么是小于等于?不是要尽可能地扩大差异化吗? 那不是应该大于?</p>
<p>而且由于M&gt;&gt;k,那所有地xk都会接近于范式2的值等于零的情况啊, 对啊, 所以diversity就很差~</p>
<p>由此得出的结论是: coreset selection带来的poor diversity的主要原因是 M&gt;&gt;k.</p>
<p>于是一个idea就是recursively(递归地)进行select. 其实就是S1选好之后, S2从D\S1中选 :&#x20;</p>
<img data-src="/2023/12/21/Dataset-Quantization/image_o9Lf2FUDLl.png" class>
<p>于是上面这个式子(2)中的限制范围被扩大了, 所以xk的选择余地更多了, 这同样意味着diversity变多了.</p>
<p>问题在于, 难道不是先划分好不重叠的bins,再进行select的? 为什么最开始的方法是从整个数据集中选? 而不是从S1的子集中选出first k sample?</p>
<p>对的, 因为这是DQ, 本文要介绍的方法, 不是coreset的做法…</p>
<p>于是有:</p>
<img data-src="/2023/12/21/Dataset-Quantization/image_rcSDdpX34e.png" class>
<p>这种recursive的方法划分数据集带来的是不一样的diversity level. 很明显, 最开始划分出的S1多样性最差, 越到后面多样性越好?&#x20;</p>
<p>真的是这样吗? 到后面的R会不会也变小?无所谓啦, R即便变小, 还是不如前面系数中的分母变小带来的影响大~</p>
<h2 id="DQ"><a href="#DQ" class="headerlink" title="DQ"></a>DQ</h2><img data-src="/2023/12/21/Dataset-Quantization/image_bVvbesw8ZG.png" class>
<p>上图就是DQ的主要方法, 其实可以看出, 由于是递归选择的, 所以一开始的选择的时候diveristy最差, S1都选在了一起, 一簇的感觉, 随着n越来越大, 被除去的数据也越来越多, 可以看到当n = N的时候, sample的点几乎遍布整个数据集, 具有很大的diversity</p>
<h3 id="1-Dataset-bin-generation"><a href="#1-Dataset-bin-generation" class="headerlink" title="1 Dataset bin generation"></a>1 Dataset bin generation</h3><p>原本是最大化这个式子:</p>
<img data-src="/2023/12/21/Dataset-Quantization/image_PY3e1tPIM4.png" class>
<p>现在是最大化这个式子:</p>
<img data-src="/2023/12/21/Dataset-Quantization/image_GGakRm345A.png" class>
<p>为什么会想到上述递归的选取方法?</p>
<p>就是因为分析了(1)式的等价式子(2):</p>
<img data-src="/2023/12/21/Dataset-Quantization/image_UiN_lRTV25.png" class>
<p>发现通过递归去除已经选好的S, 会加大bin选取的diversity~</p>
<p>文中也有提到是一个representativeness和diversity之间的一个trade-off. 其实前面也分析过, 对于S1而言, diversity最差, 但是同样也最具有representative, 对于SN而言就是反过来~</p>
<img data-src="/2023/12/21/Dataset-Quantization/9b87be336fd29017e0d9839cbdab332_FMrvnEafSX.png" class>
<p>总感觉上面的算法写的不对… 好多问题看着…&#x20;</p>
<h3 id="2-Bin-sampling"><a href="#2-Bin-sampling" class="headerlink" title="2 Bin sampling"></a>2 Bin sampling</h3><p>当划分好bins之后, 就是在每个bin中进行sampling, 然后取个并集, 最后就是synthesized dataset了.</p>
<img data-src="/2023/12/21/Dataset-Quantization/image_0xV3_deADw.png" class>
<p>g(S,p)就是一个采样函数, p表示data keep ratio.</p>
<p>除此之外, 我们还对每个样本进行分析(Masked Auto-Encoder → <strong>MAE</strong>):</p>
<ol>
<li>划分Images为patches</li>
<li>计算每个小格的weight</li>
<li>设置阈值,丢掉不重要的格子</li>
</ol>
<h1 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h1><p>终于到实验部分啦)</p>
<p>在原始数据集为CIFAR-10上, 作者用ResNet-18当作feature extractor , 然后将压缩后的数据在不同的模型(ViT, Swin, ConvNext等)上进行训练.</p>
<img data-src="/2023/12/21/Dataset-Quantization/image_c1yeLlc_Q-.png" class>
<p>上面的表格可以看出, DM在RN18训练中表现得很好, 但是一旦迁移到别的架构(R50, ViT…), 就会大幅下降. 但是DQ却仍旧能够保证相对很好的效果, 说明DQ的cross architecture的表现很好~</p>
<h3 id="超参数"><a href="#超参数" class="headerlink" title="超参数"></a>超参数</h3><p>DQ有两个超参数:</p>
<ol>
<li>是bins的数量N</li>
<li>patch drop ratio: theta</li>
</ol>
<p>在较大的data keep ratio的时候, 较大的drop ratio有利于模型的acc.</p>
<p>还有很多对比试验:</p>
<img data-src="/2023/12/21/Dataset-Quantization/image_mZuyxOCTsY.png" class>
<p>比如到底是随机丢弃, 还是设置一个阈值丢掉weight低的patch, 以及GPU的训练时间等等.</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>花了四个小时读完了这篇论文, 总之差不多了解了什么是DQ, 以及和coreset, distillation的区别以及具体的理论推导. 感觉理论部分不难, 具有很好的可解释性.&#x20;</p>
<p>但是文中也说递归也会带来computational cost, 所以说如果一开始就随机划分好N个bins,然后每个bin都具有自己的diversity和representative值, 然后给bin中的每个sample打一个diversity score(其实就是和文中这个样本相距bin中averageR的距离成正比).</p>
<p>为了将每个bin都映射成不同的diversity level(因为这样才能存在既有diversity又有representative的bins了), 可以将最开始随即划分的bins, 根据每个样本的diversity互相交换(因为要保证每个bin的样本数量都是K,是一致的, 所以是”交换”,不是”收编”)</p>
<img data-src="/2023/12/21/Dataset-Quantization/image_5xSQMuBc-C.png" class>
]]></content>
      <tags>
        <tag>Dataset Quantization</tag>
        <tag>Model Efficiency</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心算法</title>
    <url>/2022/11/09/Greedy-Algorithm/</url>
    <content><![CDATA[<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h2 id="部分背包问题"><a href="#部分背包问题" class="headerlink" title="部分背包问题"></a>部分背包问题</h2><p><strong>输入：</strong> n个物品，每个物品又vi和pi，分别表示体积和价格，背包容量是C。</p>
<p><strong>输出：</strong> 求解一个解决方案。$S=\{x_i|0 \leq x_i \leq n \}$，如果$x_i$只能选0或者1，则变成了完全背包问题。</p>
<img data-src="/2022/11/09/Greedy-Algorithm/image_APjPlE8xfR.png" class>
<p><strong>最高性价比优先</strong></p>
<p>证明贪心策略是最优解，方法：替换法（假设另外存在一个最优解）</p>
<img data-src="/2022/11/09/Greedy-Algorithm/image_oRBRScSpDx.png" class>
<p>时间复杂度：$O(nlogn)$</p>
<hr>
<h2 id="最优前缀编码问题"><a href="#最优前缀编码问题" class="headerlink" title="最优前缀编码问题"></a>最优前缀编码问题</h2><img data-src="/2022/11/09/Greedy-Algorithm/image_KzUoqMDnq1.png" class>
<img data-src="/2022/11/09/Greedy-Algorithm/image_mjuaF95KcS.png" class>
<img data-src="/2022/11/09/Greedy-Algorithm/image_k_DKNolvPS.png" class>
<h2 id="活动选择问题1"><a href="#活动选择问题1" class="headerlink" title="活动选择问题1"></a>活动选择问题1</h2><p><strong>问题描述：一个会场，如何安排举办最多的活动</strong></p>
<img data-src="/2022/11/09/Greedy-Algorithm/image_gtgIT3Wd-7.png" class>
<p><strong>策略：</strong></p>
<ol>
<li><p><strong>最短活动</strong>优先</p>
</li>
<li><p><strong>最早开始</strong>活动优先</p>
</li>
<li><p><strong>最早结束</strong>活动优先</p>
</li>
</ol>
<p>提出贪心策略→证明贪心算法就是最优解</p>
<p>如何证明？<strong>举反例</strong></p>
<img data-src="/2022/11/09/Greedy-Algorithm/image_WunvnoB7IM.png" class>
<p><strong>正确算法：最早活动优先</strong></p>
<p>如何证明这是最优解？替换算法</p>
<img data-src="/2022/11/09/Greedy-Algorithm/image_WQR3nKQJKM.png" class>
<p>时间复杂度为$O(nlogn)$，仍旧为排序算法时间复杂度。</p>
<h2 id="活动选择问题2"><a href="#活动选择问题2" class="headerlink" title="活动选择问题2"></a>活动选择问题2</h2><p>在上一个问题的基础上，使得活动的<strong>出租收益最大</strong>，相当于每个活动加了个权重。</p>
<h4 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h4><p>n个活动组成的集合$S=\{a_1,a_2,…a_n\}$,每个活动有开始时间$s_i$和结束时间$f_i$和权重$w_i$。找到一个活动的子集，使得$max\sum w_i$，同时保证活动不能冲突。</p>
<img data-src="/2022/11/09/Greedy-Algorithm/image_dfx6vuUSTy.png" class>
<p>存在<strong>重叠子问题</strong>，使用<strong>动态规划</strong>求解。</p>
<img data-src="/2022/11/09/Greedy-Algorithm/image_k1GKkxPi4V.png" class>
<img data-src="/2022/11/09/Greedy-Algorithm/image_apSln0_h52.png" class>
<img data-src="/2022/11/09/Greedy-Algorithm/image_dZb4khxonI.png" class>
<img data-src="/2022/11/09/Greedy-Algorithm/image_4y4dNIwGwP.png" class>
<p><strong>伪代码：</strong></p>
<img data-src="/2022/11/09/Greedy-Algorithm/image_BZG0j_Xhw1.png" class>
<img data-src="/2022/11/09/Greedy-Algorithm/image_s53HT29Iq5.png" class>
<img data-src="/2022/11/09/Greedy-Algorithm/image_Y10aQNR_Tt.png" class>
<p>选择活动rec[i]=1，否则为0.</p>
<p><strong>时间复杂度：</strong>$O(nlogn)$（二分查找排序时间复杂度）</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>greedy algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>LSTM-文本情感预测</title>
    <url>/2022/11/24/LSTM-%E6%96%87%E6%9C%AC%E6%83%85%E6%84%9F%E9%A2%84%E6%B5%8B/</url>
    <content><![CDATA[<h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><p>去除了停用词，分词，最后输出一个矩阵，每一行时经过处理后的单词列表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> nltk</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">train_data = pd.read_csv(<span class="string">&#x27;./train.csv&#x27;</span>, encoding=<span class="string">&#x27;ISO-8859-1&#x27;</span>)</span><br><span class="line">size_train_data = <span class="built_in">len</span>(train_data)</span><br><span class="line">tweet_text = train_data[<span class="string">&#x27;OriginalTweet&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对Tweet进行分句, 同时去除标点符号</span></span><br><span class="line">tweet_sentences = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size_train_data):</span><br><span class="line">    tweet = tweet_text[i]</span><br><span class="line">    tweets = nltk.sent_tokenize(tweet)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tweets)):</span><br><span class="line">        sentence = tweets[j]</span><br><span class="line">        tweets[j] = re.sub(<span class="string">r&#x27;[^a-zA-Z0-9\s]&#x27;</span>,<span class="string">&#x27;&#x27;</span>,string= sentence)</span><br><span class="line">        tweets[j] = tweets[j].replace(<span class="string">&quot;\r&quot;</span>,<span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;\n&quot;</span>,<span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;\t&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line">    tweet_sentences.append(tweets)</span><br></pre></td></tr></table></figure>
<h2 id="Word2vec模型训练"><a href="#Word2vec模型训练" class="headerlink" title="Word2vec模型训练"></a>Word2vec模型训练</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = Word2Vec(text_combine,vector_size = <span class="number">100</span>, window = <span class="number">5</span> , min_count = <span class="number">5</span>, epochs=<span class="number">7</span>, negative=<span class="number">10</span>,sg=<span class="number">1</span>)</span><br><span class="line">model.save(<span class="string">&#x27;./models/Word2vec_v4&#x27;</span>)  <span class="comment"># 保存模型</span></span><br></pre></td></tr></table></figure>
<h2 id="构建词典"><a href="#构建词典" class="headerlink" title="构建词典"></a>构建词典</h2><p>句子的向量表示：sentence = [word_index1,word_index2,….,word_indexn]</p>
<p>注意是用索引组成的列表表示，而不是直接用word embedding表示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> scipy <span class="keyword">as</span> sp</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> gensim.corpora <span class="keyword">import</span> Dictionary</span><br><span class="line"><span class="keyword">from</span> gensim.models <span class="keyword">import</span> Word2Vec</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">&quot;CUDA_DEVICE_ORDER&quot;</span>]=<span class="string">&quot;0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_dictionaries</span>(<span class="params">model=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    创建词语字典，返回word2vec模型中词语的索引、词向量</span></span><br><span class="line"><span class="string">    :param model:</span></span><br><span class="line"><span class="string">    :return: index, wordvec</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    gensim_dict = Dictionary()</span><br><span class="line">    <span class="comment"># doc2bow:</span></span><br><span class="line">    <span class="comment"># Bag-of-words model : BoW</span></span><br><span class="line">    <span class="comment"># 忽略文本的语法和语序,仅仅看作若干个词的集合,词是无序的.</span></span><br><span class="line">    <span class="comment"># 每个句子都可以用BoW来表示 假设又m个词:</span></span><br><span class="line">    <span class="comment"># 每个句子可以表示成:</span></span><br><span class="line">    <span class="comment"># [n1,...nm]</span></span><br><span class="line">    <span class="comment"># ni表示索引为i的词出现的次数</span></span><br><span class="line">    gensim_dict.doc2bow(model.wv.key_to_index.keys(),allow_update=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    w2index = &#123;v : k + <span class="number">1</span> <span class="keyword">for</span> k,v <span class="keyword">in</span> gensim_dict.items()&#125;</span><br><span class="line">    <span class="comment"># print(w2index)</span></span><br><span class="line">    w2vec = &#123;word : model.wv.get_vector(word) <span class="keyword">for</span> word <span class="keyword">in</span> w2index.keys()&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> w2index,w2vec</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载模型</span></span><br><span class="line">model = Word2Vec.load(<span class="string">&#x27;./models/Word2vec_v4&#x27;</span>)</span><br><span class="line">index_dict , word_vectors  = create_dictionaries(model)</span><br><span class="line"></span><br><span class="line">output = <span class="built_in">open</span>(<span class="string">&quot;dictW.pkl&quot;</span>, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">pickle.dump(index_dict, output)  <span class="comment"># 索引字典</span></span><br><span class="line">pickle.dump(word_vectors, output)  <span class="comment"># 词向量字典</span></span><br><span class="line">output.close()</span><br></pre></td></tr></table></figure>
<h2 id="LSTM神经网络训练和预测"><a href="#LSTM神经网络训练和预测" class="headerlink" title="LSTM神经网络训练和预测"></a>LSTM神经网络训练和预测</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Embedding, LSTM, Dropout, Dense</span><br><span class="line"><span class="keyword">from</span>  sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> tensorflow.compat.v2 <span class="keyword">import</span> keras</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> load_model</span><br><span class="line"><span class="comment"># import pylab as plt</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">&quot;CUDA_VISIBLE_DEVICES&quot;</span>]=<span class="string">&quot;0&quot;</span></span><br><span class="line"><span class="comment"># import pylab as plt</span></span><br><span class="line">vocab_dim = <span class="number">100</span> <span class="comment"># 向量维度</span></span><br><span class="line">maxlen = <span class="number">70</span> <span class="comment"># 文本保留的最大长度</span></span><br><span class="line">batch_size = <span class="number">32</span> <span class="comment"># 训练过程中 每次传入模型的特征向量</span></span><br><span class="line">n_epoch = <span class="number">4</span> <span class="comment">#迭代次数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开词字典</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;dictW.pkl&quot;</span>,<span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">index_dict = pickle.load(f) <span class="comment"># key:word value:index</span></span><br><span class="line">word_vectors = pickle.load(f) <span class="comment"># key: word value:vec</span></span><br><span class="line"></span><br><span class="line">n_symbols = <span class="built_in">len</span>(index_dict) + <span class="number">1</span> <span class="comment"># 索引单词的个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个n_symbols * vocab_dim 的矩阵 用于填充所有的词向量</span></span><br><span class="line">embedding_weights = np.zeros((n_symbols,vocab_dim))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> w,index <span class="keyword">in</span> index_dict.items():</span><br><span class="line">    embedding_weights[index, :] = word_vectors[w]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">text_to_index_array</span>(<span class="params">p_new_dic=<span class="literal">None</span>,p_sen=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="comment"># if p_sen != None and p_new_dic != None:</span></span><br><span class="line">        new_sentences = []</span><br><span class="line">        <span class="keyword">for</span> sen <span class="keyword">in</span> p_sen:</span><br><span class="line">            new_sen = []</span><br><span class="line">            <span class="keyword">for</span> word <span class="keyword">in</span> sen:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    <span class="comment"># 句子用单词的索引来填充</span></span><br><span class="line">                    new_sen.append(p_new_dic[word])</span><br><span class="line">                <span class="keyword">except</span>:</span><br><span class="line">                    <span class="comment"># 未出现在dict中的单词用索引0填充</span></span><br><span class="line">                    new_sen.append(<span class="number">0</span>)</span><br><span class="line">            new_sentences.append(new_sen)</span><br><span class="line">        <span class="keyword">return</span> np.array(new_sentences)</span><br><span class="line">    <span class="comment"># else:</span></span><br><span class="line">    <span class="comment">#     print(&quot;Error p_sen is not a list!&quot;)</span></span><br><span class="line">    <span class="comment">#     return None</span></span><br><span class="line"></span><br><span class="line">train_data = pd.read_csv(<span class="string">&#x27;./train.csv&#x27;</span>, encoding=<span class="string">&#x27;ISO-8859-1&#x27;</span>)</span><br><span class="line">train_label = train_data[<span class="string">&#x27;Sentiment&#x27;</span>]</span><br><span class="line"></span><br><span class="line">train_label_New = []</span><br><span class="line"><span class="keyword">for</span> label <span class="keyword">in</span> train_label:</span><br><span class="line">    labelArray = [<span class="number">0</span>] * <span class="number">5</span></span><br><span class="line">    <span class="keyword">if</span> label == <span class="string">&quot;Positive&quot;</span> :</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> label == <span class="string">&quot;Negative&quot;</span>:</span><br><span class="line">        index = <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> label == <span class="string">&quot;Neutral&quot;</span> :</span><br><span class="line">        index = <span class="number">2</span></span><br><span class="line">    <span class="keyword">elif</span> label == <span class="string">&quot;Extremely Positive&quot;</span> :</span><br><span class="line">        index = <span class="number">3</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        index = <span class="number">4</span></span><br><span class="line">    labelArray[index] = <span class="number">1</span></span><br><span class="line">    train_label_New.append(labelArray)</span><br><span class="line">train_label = train_label_New</span><br><span class="line"></span><br><span class="line">train_data = np.load(<span class="string">&quot;./sentences.npy&quot;</span>, allow_pickle=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 随机划分训练集和开发集 比例为9:1</span></span><br><span class="line">X_train , X_dev , y_train, y_dev = train_test_split(train_data,train_label,test_size=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(&quot;X_train:&quot;,X_train)</span></span><br><span class="line">X_train_new = text_to_index_array(index_dict,X_train)</span><br><span class="line">X_dev_new = text_to_index_array(index_dict,X_dev)</span><br><span class="line"></span><br><span class="line">X_train_new = keras.preprocessing.sequence.pad_sequences(X_train_new, maxlen=maxlen)</span><br><span class="line">X_dev_new = keras.preprocessing.sequence.pad_sequences(X_dev_new, maxlen=maxlen)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">y_train_new = np.array(y_train)</span><br><span class="line">y_dev_new = np.array(y_dev)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;测试集shape:&quot;</span>,X_train_new.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;开发集shape:&quot;</span>,X_dev_new.shape)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train_lstm</span>(<span class="params">p_n_symbols, p_embedding_weights, p_X_train, p_y_train, p_X_test, p_y_test, X_test_l</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;创建模型...&#x27;</span>)</span><br><span class="line">    model = Sequential()</span><br><span class="line">    model.add(Embedding(output_dim=vocab_dim,  <span class="comment"># 输出向量维度</span></span><br><span class="line">                        input_dim=p_n_symbols,  <span class="comment"># 输入向量维度</span></span><br><span class="line">                        mask_zero=<span class="literal">True</span>,         <span class="comment"># 使我们填补的0值在后续训练中不产生影响（屏蔽0值）</span></span><br><span class="line">                        weights=[p_embedding_weights],   <span class="comment"># 对数据加权</span></span><br><span class="line">                        input_length=maxlen ))      <span class="comment"># 每个特征的长度</span></span><br><span class="line"></span><br><span class="line">    model.add(LSTM(units=<span class="number">100</span>,</span><br><span class="line">                   activation=<span class="string">&#x27;sigmoid&#x27;</span>,</span><br><span class="line">                   inner_activation=<span class="string">&#x27;hard_sigmoid&#x27;</span>))</span><br><span class="line">    model.add(Dropout(<span class="number">0.5</span>))   <span class="comment"># 每次迭代丢弃50神经元 防止过拟合</span></span><br><span class="line">    model.add(Dense(units=<span class="number">512</span>,</span><br><span class="line">                    activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">    model.add(Dropout(<span class="number">0.5</span>))</span><br><span class="line">    model.add(Dense(units=<span class="number">5</span>,  <span class="comment"># 输出层1个神经元 1代表正面 0代表负面</span></span><br><span class="line">                    activation=<span class="string">&#x27;sigmoid&#x27;</span>))</span><br><span class="line">    model.summary()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;编译模型...&#x27;</span>)</span><br><span class="line">    model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;binary_crossentropy&#x27;</span>,</span><br><span class="line">                  optimizer=<span class="string">&#x27;adam&#x27;</span>,</span><br><span class="line">                  metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;训练...&quot;</span>)</span><br><span class="line">    train_history = model.fit(p_X_train, p_y_train, batch_size=batch_size, nb_epoch=n_epoch,</span><br><span class="line">              validation_data=(p_X_test, p_y_test))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;评估...&quot;</span>)</span><br><span class="line">    score, acc = model.evaluate(p_X_test, p_y_test, batch_size=batch_size)</span><br><span class="line">    label = model.predict(p_X_test)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Test score:&#x27;</span>, score)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Test accuracy:&#x27;</span>, acc)</span><br><span class="line">    <span class="comment"># for (a, b, c) in zip(p_y_test, X_test_l, label):</span></span><br><span class="line">    <span class="comment">#     print(&quot;原文为:&quot;+ &quot;&quot;.join(b))</span></span><br><span class="line">    <span class="comment">#     print(&quot;真实值:&quot;, a)</span></span><br><span class="line">    <span class="comment">#     print(&quot;预测值&quot;, c)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># show_train_history(train_history, &#x27;acc&#x27;, &#x27;val_acc&#x27;)    # 训练集准确率与验证集准确率 折线图</span></span><br><span class="line">    <span class="comment"># show_train_history(train_history, &#x27;loss&#x27;, &#x27;val_loss&#x27;)  # 训练集误差率与验证集误差率 折线图</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;保存模型&quot;&quot;&quot;</span></span><br><span class="line">    model.save(<span class="string">&#x27;./model/emotion_model_LSTM2.h5&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;模型保存成功&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_train_history</span>(<span class="params">train_history,train, velidation</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    可视化训练过程 对比</span></span><br><span class="line"><span class="string">    :param train_history:</span></span><br><span class="line"><span class="string">    :param train:</span></span><br><span class="line"><span class="string">    :param velidation:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    plt.plot(train_history.history[train])</span><br><span class="line">    plt.plot(train_history.history[velidation])</span><br><span class="line">    plt.title(<span class="string">&quot;Train History&quot;</span>)   <span class="comment">#标题</span></span><br><span class="line">    plt.xlabel(<span class="string">&#x27;Epoch&#x27;</span>)    <span class="comment">#x轴标题</span></span><br><span class="line">    plt.ylabel(train)  <span class="comment">#y轴标题</span></span><br><span class="line">    plt.legend([<span class="string">&#x27;train&#x27;</span>, <span class="string">&#x27;test&#x27;</span>], loc=<span class="string">&#x27;upper left&#x27;</span>)  <span class="comment">#图例 左上角</span></span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_max_index</span>(<span class="params">listRe</span>):</span><br><span class="line">    maxProb = <span class="number">0.0</span></span><br><span class="line">    maxProbIndex = <span class="number">0</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> re <span class="keyword">in</span> listRe:</span><br><span class="line">        <span class="keyword">if</span> re &gt; maxProb:</span><br><span class="line">            maxProb = re</span><br><span class="line">            maxProbIndex = i</span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> maxProbIndex</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">prediction</span>(<span class="params">test_data,raw_test_data</span>):</span><br><span class="line"></span><br><span class="line">    keras.backend.clear_session()</span><br><span class="line">    model = load_model(<span class="string">&#x27;./model/emotion_model_LSTM2.h5&#x27;</span>,)</span><br><span class="line">    label = model.predict(test_data)</span><br><span class="line">    file = <span class="built_in">open</span>(<span class="string">&#x27;./submission.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">    i=<span class="number">0</span></span><br><span class="line">    <span class="comment"># print(raw_test_data)</span></span><br><span class="line">    <span class="keyword">for</span> re <span class="keyword">in</span> label:</span><br><span class="line">        index = get_max_index(re)</span><br><span class="line">        <span class="comment"># file.writelines(raw_test_data[i])</span></span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> index == <span class="number">0</span>:</span><br><span class="line">            file.write(<span class="string">&quot;Positive&quot;</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">elif</span> index == <span class="number">1</span>:</span><br><span class="line">            file.write(<span class="string">&quot;Negative&quot;</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">elif</span> index == <span class="number">2</span>:</span><br><span class="line">            file.write(<span class="string">&quot;Neutral&quot;</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">elif</span> index == <span class="number">3</span>:</span><br><span class="line">            file.write(<span class="string">&quot;Extremely Positive&quot;</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            file.write(<span class="string">&quot;Extremely Negative&quot;</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">train_lstm(n_symbols, embedding_weights, X_train_new, y_train_new, X_dev_new, y_dev_new, X_dev)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测</span></span><br><span class="line">raw_test_data = np.load(<span class="string">&quot;./test_sentences1.npy&quot;</span>, allow_pickle=<span class="literal">True</span>)</span><br><span class="line">test_data = text_to_index_array(index_dict,raw_test_data)</span><br><span class="line">test_data = keras.preprocessing.sequence.pad_sequences(test_data, maxlen=maxlen)</span><br><span class="line">prediction(test_data,raw_test_data)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后的结果不是太好，只有百分之八十左右的精度，还有很多可以改良的地方。例如数据预处理的时候可以考虑停用词是否要去掉，因为问号等会对语气产生影响。</p>
<h1 id="完整报告"><a href="#完整报告" class="headerlink" title="完整报告"></a>完整报告</h1><img data-src="/2022/11/24/LSTM-%E6%96%87%E6%9C%AC%E6%83%85%E6%84%9F%E9%A2%84%E6%B5%8B/%E6%96%87%E6%9C%AC%E6%83%85%E6%84%9F%E5%88%86%E6%9E%90-%E6%8A%A5%E5%91%8A_00.jpg" class>
<img data-src="/2022/11/24/LSTM-%E6%96%87%E6%9C%AC%E6%83%85%E6%84%9F%E9%A2%84%E6%B5%8B/%E6%96%87%E6%9C%AC%E6%83%85%E6%84%9F%E5%88%86%E6%9E%90-%E6%8A%A5%E5%91%8A_01.jpg" class>
<img data-src="/2022/11/24/LSTM-%E6%96%87%E6%9C%AC%E6%83%85%E6%84%9F%E9%A2%84%E6%B5%8B/%E6%96%87%E6%9C%AC%E6%83%85%E6%84%9F%E5%88%86%E6%9E%90-%E6%8A%A5%E5%91%8A_02.jpg" class>
<img data-src="/2022/11/24/LSTM-%E6%96%87%E6%9C%AC%E6%83%85%E6%84%9F%E9%A2%84%E6%B5%8B/%E6%96%87%E6%9C%AC%E6%83%85%E6%84%9F%E5%88%86%E6%9E%90-%E6%8A%A5%E5%91%8A_03.jpg" class>
<img data-src="/2022/11/24/LSTM-%E6%96%87%E6%9C%AC%E6%83%85%E6%84%9F%E9%A2%84%E6%B5%8B/%E6%96%87%E6%9C%AC%E6%83%85%E6%84%9F%E5%88%86%E6%9E%90-%E6%8A%A5%E5%91%8A_04.jpg" class>
<img data-src="/2022/11/24/LSTM-%E6%96%87%E6%9C%AC%E6%83%85%E6%84%9F%E9%A2%84%E6%B5%8B/%E6%96%87%E6%9C%AC%E6%83%85%E6%84%9F%E5%88%86%E6%9E%90-%E6%8A%A5%E5%91%8A_05.jpg" class>
<img data-src="/2022/11/24/LSTM-%E6%96%87%E6%9C%AC%E6%83%85%E6%84%9F%E9%A2%84%E6%B5%8B/%E6%96%87%E6%9C%AC%E6%83%85%E6%84%9F%E5%88%86%E6%9E%90-%E6%8A%A5%E5%91%8A_06.jpg" class>
<img data-src="/2022/11/24/LSTM-%E6%96%87%E6%9C%AC%E6%83%85%E6%84%9F%E9%A2%84%E6%B5%8B/%E6%96%87%E6%9C%AC%E6%83%85%E6%84%9F%E5%88%86%E6%9E%90-%E6%8A%A5%E5%91%8A_07.jpg" class>
<img data-src="/2022/11/24/LSTM-%E6%96%87%E6%9C%AC%E6%83%85%E6%84%9F%E9%A2%84%E6%B5%8B/%E6%96%87%E6%9C%AC%E6%83%85%E6%84%9F%E5%88%86%E6%9E%90-%E6%8A%A5%E5%91%8A_08.jpg" class>
<img data-src="/2022/11/24/LSTM-%E6%96%87%E6%9C%AC%E6%83%85%E6%84%9F%E9%A2%84%E6%B5%8B/%E6%96%87%E6%9C%AC%E6%83%85%E6%84%9F%E5%88%86%E6%9E%90-%E6%8A%A5%E5%91%8A_09.jpg" class>
<img data-src="/2022/11/24/LSTM-%E6%96%87%E6%9C%AC%E6%83%85%E6%84%9F%E9%A2%84%E6%B5%8B/%E6%96%87%E6%9C%AC%E6%83%85%E6%84%9F%E5%88%86%E6%9E%90-%E6%8A%A5%E5%91%8A_10.jpg" class>
<img data-src="/2022/11/24/LSTM-%E6%96%87%E6%9C%AC%E6%83%85%E6%84%9F%E9%A2%84%E6%B5%8B/%E6%96%87%E6%9C%AC%E6%83%85%E6%84%9F%E5%88%86%E6%9E%90-%E6%8A%A5%E5%91%8A_11.jpg" class>
<img data-src="/2022/11/24/LSTM-%E6%96%87%E6%9C%AC%E6%83%85%E6%84%9F%E9%A2%84%E6%B5%8B/%E6%96%87%E6%9C%AC%E6%83%85%E6%84%9F%E5%88%86%E6%9E%90-%E6%8A%A5%E5%91%8A_12.jpg" class>
<img data-src="/2022/11/24/LSTM-%E6%96%87%E6%9C%AC%E6%83%85%E6%84%9F%E9%A2%84%E6%B5%8B/%E6%96%87%E6%9C%AC%E6%83%85%E6%84%9F%E5%88%86%E6%9E%90-%E6%8A%A5%E5%91%8A_13.jpg" class>
<img data-src="/2022/11/24/LSTM-%E6%96%87%E6%9C%AC%E6%83%85%E6%84%9F%E9%A2%84%E6%B5%8B/%E6%96%87%E6%9C%AC%E6%83%85%E6%84%9F%E5%88%86%E6%9E%90-%E6%8A%A5%E5%91%8A_14.jpg" class>
<img data-src="/2022/11/24/LSTM-%E6%96%87%E6%9C%AC%E6%83%85%E6%84%9F%E9%A2%84%E6%B5%8B/%E6%96%87%E6%9C%AC%E6%83%85%E6%84%9F%E5%88%86%E6%9E%90-%E6%8A%A5%E5%91%8A_15.jpg" class>
<img data-src="/2022/11/24/LSTM-%E6%96%87%E6%9C%AC%E6%83%85%E6%84%9F%E9%A2%84%E6%B5%8B/%E6%96%87%E6%9C%AC%E6%83%85%E6%84%9F%E5%88%86%E6%9E%90-%E6%8A%A5%E5%91%8A_16.jpg" class>
<img data-src="/2022/11/24/LSTM-%E6%96%87%E6%9C%AC%E6%83%85%E6%84%9F%E9%A2%84%E6%B5%8B/%E6%96%87%E6%9C%AC%E6%83%85%E6%84%9F%E5%88%86%E6%9E%90-%E6%8A%A5%E5%91%8A_17.jpg" class>
<img data-src="/2022/11/24/LSTM-%E6%96%87%E6%9C%AC%E6%83%85%E6%84%9F%E9%A2%84%E6%B5%8B/%E6%96%87%E6%9C%AC%E6%83%85%E6%84%9F%E5%88%86%E6%9E%90-%E6%8A%A5%E5%91%8A_18.jpg" class>
<img data-src="/2022/11/24/LSTM-%E6%96%87%E6%9C%AC%E6%83%85%E6%84%9F%E9%A2%84%E6%B5%8B/%E6%96%87%E6%9C%AC%E6%83%85%E6%84%9F%E5%88%86%E6%9E%90-%E6%8A%A5%E5%91%8A_19.jpg" class>
<img data-src="/2022/11/24/LSTM-%E6%96%87%E6%9C%AC%E6%83%85%E6%84%9F%E9%A2%84%E6%B5%8B/%E6%96%87%E6%9C%AC%E6%83%85%E6%84%9F%E5%88%86%E6%9E%90-%E6%8A%A5%E5%91%8A_20.jpg" class>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>LSTM</tag>
      </tags>
  </entry>
  <entry>
    <title>LBPH</title>
    <url>/2022/10/18/LBPH/</url>
    <content><![CDATA[<h3 id="算法具体流程图："><a href="#算法具体流程图：" class="headerlink" title="算法具体流程图："></a>算法具体流程图：</h3><img data-src="/2022/10/18/LBPH/9db9a31f7ac7513ffd05fe02617a2c4.jpg" class>
<p>由于LBPH运用的是局部特征算法，所以对图像明暗度的鲁棒性较好，其次，颜色对人脸识别没有影响，所以导入之后转换为灰度图像，灰度为<code>0-256</code>。</p>
<h4 id="计算LBP编码"><a href="#计算LBP编码" class="headerlink" title="计算LBP编码"></a>计算LBP编码</h4><img data-src="/2022/10/18/LBPH/e1c89d3b73c3c91dcbf72a88982a4ad.jpg" class>
<p>有经典LBP编码和圆形LBP编码，绕周围一圈八个数，如果比中间的数大，则记为1，反之为0。最后连接之后的01字符串组成一个二进制数，这个二进制数就是这个像素点对应的LBP编码。</p>
<h4 id="均匀化降维"><a href="#均匀化降维" class="headerlink" title="均匀化降维"></a>均匀化降维</h4><p>由于灰度有256维，这个矩阵会较为稀疏，所以需要将其降维到更小的维度。此处的实验室将其降维到59维度。实际上，降维的过程就是一个函数映射的过程：将256个二进制数映射到0-59个十进制数上。</p>
<p>具体实现代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getHopCounter</span>(<span class="params">self, num</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    计算二进制序列是否只变化两次</span></span><br><span class="line"><span class="string">    :param num: 数字</span></span><br><span class="line"><span class="string">    :return: 01变化次数</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    binNum = <span class="built_in">bin</span>(num)</span><br><span class="line">    binStr = <span class="built_in">str</span>(binNum)[<span class="number">2</span>:]</span><br><span class="line">    n = <span class="built_in">len</span>(binStr)</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">8</span>:</span><br><span class="line">        binStr = <span class="string">&quot;0&quot;</span> * (<span class="number">8</span> - n) + binStr</span><br><span class="line">    n = <span class="built_in">len</span>(binStr)</span><br><span class="line">    counter = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">if</span> i != n - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> binStr[i + <span class="number">1</span>] != binStr[i]:</span><br><span class="line">                counter += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> binStr[<span class="number">0</span>] != binStr[i]:</span><br><span class="line">                counter += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> counter</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createTable</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    生成均匀对应字典</span></span><br><span class="line"><span class="string">    :return: 均匀LBP特征对应字典</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    self.table = &#123;&#125;</span><br><span class="line">    temp = <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span></span><br><span class="line">    <span class="built_in">type</span>(temp)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        <span class="keyword">if</span> self.getHopCounter(i) &lt;= <span class="number">2</span>:</span><br><span class="line">            self.table[i] = temp</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;tmp&quot;</span>,temp)</span><br><span class="line">            temp += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.table[i] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> self.table</span><br></pre></td></tr></table></figure>
<p>最后256个二进制数就能够唯一地映射到59个数上。</p>
<h4 id="特征矩阵"><a href="#特征矩阵" class="headerlink" title="特征矩阵"></a>特征矩阵</h4><p>特征矩阵就是LBP编码经过降维之后的矩阵。</p>
<h4 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h4><p>实际上是一个统计的结果，即横坐标是59度的灰度，纵坐标是对应的灰度在这张图像中出现的次数，最后归一化，表示的就是这个区域的直方图。</p>
<h4 id="特征向量"><a href="#特征向量" class="headerlink" title="特征向量"></a>特征向量</h4><p>将图像分割成一小块一小块之后计算每个小区域的直方图归一化之后，排成一排，就得到了这张图像的特征向量。</p>
<h4 id="人脸识别"><a href="#人脸识别" class="headerlink" title="人脸识别"></a>人脸识别</h4><ul>
<li>可以通过计算每张图片和测试图片的直方图的欧式距离（很慢）——所以就没跑完，待改进</li>
<li>通过特征向量方法，将其进行KNN或者SVM分类之后得到结果</li>
</ul>
<h3 id="题外话：用face-recognition包和KNN分类实现"><a href="#题外话：用face-recognition包和KNN分类实现" class="headerlink" title="题外话：用face_recognition包和KNN分类实现"></a>题外话：用face_recognition包和KNN分类实现</h3><p>在<code>faces94</code>,<code>faces95</code>,<code>faces96</code>,<code>grimace</code>四个数据集上了跑了跑。这个包能够直接通过<code>face_recognition.face_encodings(image,known_face_locations=face_bounding_boxes[0])</code>得到图像编码，将这个编码进行KNN分类即可。</p>
<h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><img data-src="/2022/10/18/LBPH/6a8b3451b62ada17da2091875a19612.jpg" class>
<h3 id="难点与改进"><a href="#难点与改进" class="headerlink" title="难点与改进"></a>难点与改进</h3><h4 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h4><ol>
<li>光照问题</li>
<li>表情姿态问题</li>
<li>遮挡问题</li>
<li>年龄变化</li>
</ol>
<h4 id="改进与尝试"><a href="#改进与尝试" class="headerlink" title="改进与尝试"></a>改进与尝试</h4><ol>
<li>尝试MBLP、SURF， HOG和FHOG 特征提取算法</li>
<li>尝试深度学习等卷积神经网络特征提取</li>
<li>尝试SVM等其他分类算法</li>
<li>探究图像进行预处理（旋正，调节曝光）对结果的影响</li>
</ol>
]]></content>
      <tags>
        <tag>AI</tag>
        <tag>Face_recognition</tag>
      </tags>
  </entry>
  <entry>
    <title>MMD&amp;Adversarial Domain Adaptation</title>
    <url>/2023/03/15/MMD-Adversarial-Domain-Adaptation/</url>
    <content><![CDATA[<h1 id="MMD-amp-Adversarial-Domain-Adaptation"><a href="#MMD-amp-Adversarial-Domain-Adaptation" class="headerlink" title="MMD &amp; Adversarial Domain Adaptation"></a>MMD &amp; Adversarial Domain Adaptation</h1><h3 id="What-is-MMD"><a href="#What-is-MMD" class="headerlink" title="What is MMD?"></a><strong>What is MMD?</strong></h3><p>MMD: <strong>M</strong>aximum <strong>M</strong>ean <strong>D</strong>iscrepancy</p>
<p>&#x20;distance between two distributions</p>
<img data-src="/2023/03/15/MMD-Adversarial-Domain-Adaptation/image_WJ5STdCHK-.png" class>
<p>如何计算绿色和红色之间的distance?</p>
<p>全部计数是不可能的,只有通过sample才可以实现.</p>
<img data-src="/2023/03/15/MMD-Adversarial-Domain-Adaptation/image_qzHT-kaCSS.png" class>
<h3 id="关于Domain-Adaptation"><a href="#关于Domain-Adaptation" class="headerlink" title="关于Domain Adaptation"></a><strong>关于Domain Adaptation</strong></h3><p><a href="https://www.youtube.com/watch?v=Mnk_oUrgppM">https://www.youtube.com/watch?v=Mnk_oUrgppM</a></p>
<p>domain adaptation:</p>
<ol>
<li>target domain上只有少量的标注的数据</li>
<li>在target domain上有很多数据,但是没有label</li>
</ol>
<img data-src="/2023/03/15/MMD-Adversarial-Domain-Adaptation/image_EuovheeubU.png" class>
<p>要让target经过feature extractor之后产生的Image feature和由source image 传入之后产生的feature分不出差异.[蓝点和红点分不出差异]</p>
<h4 id="如何分不出差异"><a href="#如何分不出差异" class="headerlink" title="如何分不出差异?"></a><strong>如何分不出差异?</strong></h4><img data-src="/2023/03/15/MMD-Adversarial-Domain-Adaptation/image_4Ecg-w2Y7s.png" class>
<p>让feature extractor来骗过domain classifier</p>
<p>妙啊!!!</p>
<p>如果仅仅为了骗过domain classifier,那么对于feature extractor来说可以输出zero,这样classifier就无法分辨到底是source还是target了.</p>
<p>但是这种方法是不行的, 因为还要保证label predictor 生成的标签是正确的!!!</p>
<p><strong>feature extractor: ** 目的是让输出的image feature 经过label predictor 预测越准确越好,并且让domain的分类越错误越好</strong>[即越难分辨]**</p>
<p><strong>Label predictor:</strong> 目的是能够更精准地分辨</p>
<p><strong>Domain Classifier:</strong> 目的是让domain的分类越正确越好&#x20;</p>
<p>但是这并不是最好的做法:</p>
<p>因为现在的目标是让source和target越接近越好,但是无论是用Ld,还是-Ld,其目的都是为了将source和target分的越来越清.</p>
]]></content>
      <tags>
        <tag>AI</tag>
        <tag>ML</tag>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>Markov Logic Network-2</title>
    <url>/2022/10/12/Markov-Logic-Network-2/</url>
    <content><![CDATA[<p><strong>Markov logic networks 论文（Mach Learn 2006）</strong></p>
<p>以下笔记仅仅是对该论文的概况复述，少有自己的思考，尚存一些疑问，如果感兴趣可以自行下载论文阅读，还可以互相交流讨论☺</p>
<p><a href="https://link.springer.com/content/pdf/10.1007/s10994-006-5833-1.pdf">论文链接</a></p>
<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>将一阶逻辑（first-order logic）和概率图（probabilistic graphical models）模型相结合成一个representation.</p>
<p>MLN的大致轮廓：</p>
<ol>
<li><p>就是将每个formula公式都赋以权重，weights可以通过迭代求得.</p>
</li>
<li><p>还有一个constant的集合用来表示域中的实体集合，相当于上一节中的论据evidence.</p>
</li>
</ol>
<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><ol>
<li><p>主要介绍了其发展历史，全文概览</p>
</li>
<li><p>介绍了Markov Networks，其用途主要有MCMC，Gibbs sampling，belief propagation.</p>
</li>
<li><p>介绍了First-order logic，其实就是离散数学1谓词逻辑相关内容，包括与或非，推出，相等，全称量词，存在量词。并介绍了一些专业术语<code>ground term</code>（不包括变量的<code>term</code>）<code>ground atom</code>值得是所有的论据都是<code>ground term</code>，<code>world</code> 指的是对于每个可能的<code>ground atom</code> 都为true.</p>
</li>
</ol>
<h3 id="Markov-logic-networks"><a href="#Markov-logic-networks" class="headerlink" title="Markov logic networks"></a>Markov logic networks</h3><p>一个first-order的例子：</p>
<img data-src="/2022/10/12/Markov-Logic-Network-2/image_-kvTCoUTOo.png" class>
<h4 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h4><img data-src="/2022/10/12/Markov-Logic-Network-2/image_nEK0m0pAjj.png" class>
<p>$L$指的是由一对一对的$pairs(F_i,w_i)$组成的集合，$F_i$就是一阶逻辑的公式，$w_i$是实数，代表这个公式的权重；除此之外，还有一个有限的由常量组成的集合$C={c_1,…,c_{|C|}}$，代表证据.</p>
<p><strong>world X概率的计算方法：</strong></p>
<img data-src="/2022/10/12/Markov-Logic-Network-2/image_nds5HF2cxp.png" class>
<p>这个上一节有讲过，此处略过：</p>
<p>下图是Table1对应的MRF：</p>
<img data-src="/2022/10/12/Markov-Logic-Network-2/image_hhhsnLSgmv.png" class>
<h4 id="Assumption"><a href="#Assumption" class="headerlink" title="Assumption"></a>Assumption</h4><p>接下来文章提出了三个假设，如下图所示：</p>
<img data-src="/2022/10/12/Markov-Logic-Network-2/image_fg1Ty70nGY.png" class>
<ul>
<li><p>Unique names：一对一</p>
</li>
<li><p>Domain closure：闭包</p>
</li>
<li><p>Known functions：已知的函数值是C中的元素</p>
</li>
</ul>
<p><strong>如何证明或者说消除上面三个假设呢?</strong></p>
<ul>
<li><p>第一个假设：引入equality predicate</p>
</li>
<li><p>第二个假设：引入对unknown but finite的u的distribution</p>
</li>
<li><p>第三个假设：反证法</p>
</li>
</ul>
<p><strong>最终结论：</strong> 假设1-3在域是有限的情况下都可以被证实.</p>
<hr>
<p>之后证明了两个proposition：</p>
<blockquote>
<p>1.<em>Every probability distribution over discrete or fifinite-precision numeric<br>variables can be represented as a Markov logic network.</em></p>
<p>2.</p>
<img data-src="/2022/10/12/Markov-Logic-Network-2/image_RstzyUj8OX.png" class>
</blockquote>
<hr>
<h3 id="Inference"><a href="#Inference" class="headerlink" title="Inference"></a>Inference</h3><p><strong>如何在已知F2为真值的时候推断F1?</strong></p>
<img data-src="/2022/10/12/Markov-Logic-Network-2/image_CDfwNtmSgL.png" class>
<p>将一个KB是否包含F公式的问题转变为$P(F|L_{KB},C_{KB,F})=1$是否成立，至于$P(x|M_{L,C})$如何计算在definition部分讲过.</p>
<p>上述等式可以通过MCMC算法估计出来，但是速度太慢.作者提出了一个不是这么general的算法，分为两个阶段：</p>
<ol>
<li><strong>第一个阶段返回一个M（a ground Markov network）：</strong></li>
</ol>
<p>其中的MB指的是马尔科夫毯</p>
<blockquote>
<p>Markov blanket （马尔科夫毯子）指某个变量，在<a href="https://so.csdn.net/so/search?q=贝叶斯\&amp;spm=1001.2101.3001.7020" title="贝叶斯">贝叶斯</a>新年网络中的 父节点、子节点、以及节点配偶。</p>
<p>U是全社会，X是个人，则MB(X)就是这个人的生活圈里</p>
</blockquote>
<img data-src="/2022/10/12/Markov-Logic-Network-2/image_WzWaGp2jzw.png" class>
<p><strong>2. 第二个阶段是在M中用Gibbs sampling</strong></p>
<img data-src="/2022/10/12/Markov-Logic-Network-2/image_takE09VGmq.png" class>
<hr>
<h3 id="Learning"><a href="#Learning" class="headerlink" title="Learning"></a>Learning</h3><p>MLN的权重的学习是通过一个或多个的相关的数据库中学习的。作者基于一个假设是如果一个<code>ground atom</code> 不在这个database里面，则它就认为是假的.如果有n个可能的<code>ground atom</code> ，那么这个数据库就可以表示成一个向量$x=(x_1,x_2,…,x_l,…,x_n)$，如果这个<code>atom</code> 出现在这个数据库中则对应的xl=1，否则为零.如果第i个公式在database x中有$n_i(x)$的几率是正确的，那么</p>
<img data-src="/2022/10/12/Markov-Logic-Network-2/image_cMQoxTPrvG.png" class>
<p>但是很显然的是通过counting来计算$n_i(x)$是很难实现的事情。于是引述了以下的假说：</p>
<img data-src="/2022/10/12/Markov-Logic-Network-2/image_9IM48_AYZN.png" class>
<p><strong>什么是#P-complete？</strong></p>
<p>也叫Sharp-P-complete问题。它和NP问题的区别就是：NP是对一个问题问有没有，#P是问有多少，因此可以看出#P比NP问题要复杂。为了在不确定数据中计算某个事件发生的概率就可能需要列出所有可能的情况，这样就会产生#P-complete问题。</p>
<p>为了增加效率，作者做了如下改动：</p>
<img data-src="/2022/10/12/Markov-Logic-Network-2/image_Y986LEDzSq.png" class>
<img data-src="/2022/10/12/Markov-Logic-Network-2/image_fDeYps0tbL.png" class>
<p>主要从以下几个方面：</p>
<ol>
<li><p>第二个式子求和的时候可以忽略没在第i个公式里出现的预测函数.</p>
</li>
<li><p>对$n_i(x_{[x_l=0]})$的计算不会因为weight的改变而改变，且仅仅需要计算一次.</p>
</li>
</ol>
<h3 id="实验和结果部分"><a href="#实验和结果部分" class="headerlink" title="实验和结果部分"></a>实验和结果部分</h3><p>具体experiment和result可以看原论文😥</p>
<p>作者对只有logic或者只有概率的方法进行了对比，放个<code>precision-recall</code> 的结果图：</p>
<img data-src="/2022/10/12/Markov-Logic-Network-2/image_deZ0qGw_b2.png" class>
<p><strong>在这里介绍一下比较基础的precision和recall：</strong></p>
<p>precision就是在预测为真值的情况下，实际值为true的比率；</p>
<p>recall就是在所有真值为true的样本里，多少样本能够被预测正确；</p>
<p>如果precision高，但是recall低，意味着预测一个一个准，但是还有很多没有没有被检测出来的。</p>
<hr>
]]></content>
      <categories>
        <category>Markov Logic Network</category>
      </categories>
      <tags>
        <tag>Graph Modal</tag>
      </tags>
  </entry>
  <entry>
    <title>Markov Logic Network-1</title>
    <url>/2022/10/11/Markov-Logic-Network1/</url>
    <content><![CDATA[<p><a href="https://www.bilibili.com/video/BV17V411Z7w5/?p=2&amp;spm_id_from=333.1007.top_right_bar_window_history.content.click">李宏毅老师讲解Markov Logic Network视频</a></p>
<h3 id="相关术语："><a href="#相关术语：" class="headerlink" title="相关术语："></a>相关术语：</h3><p><strong>Grouding：</strong>replace the variables in the predicates with all possible constant（其实就是将x替换为所有可能的取值）</p>
<p><strong>Formula：</strong> 一些逻辑推论</p>
<p><strong>World：</strong> 满足所有定义的逻辑推论的结果</p>
<p>我们要做的就是在给定一些Evidence的情况下，推导出剩余满足逻辑推论的一组结果。</p>
<img data-src="/2022/10/11/Markov-Logic-Network1/image_2CRtdKa1-U.png" class>
<p>但是上述情况每一个formula的结果是只有True Or False，现实世界的逻辑推论是soft的，要复杂得多。</p>
<img data-src="/2022/10/11/Markov-Logic-Network1/image_-uADwLSDWr.png" class>
<h3 id="概率论角度："><a href="#概率论角度：" class="headerlink" title="概率论角度："></a>概率论角度：</h3><img data-src="/2022/10/11/Markov-Logic-Network1/image_ZsFAprCvoK.png" class>
<p>上图的意思是给定一个世界U，通过公式计算这个U有多少合乎逻辑。那么，由于这个世界是通过若干个formula组成的，所以对每个formula而言，通过count其为true的次数再乘以其对应的weight就能够算出这个U合乎这个formula(i)的程度了，最后求和就能算出这个世界U合乎所有逻辑的程度。</p>
<p>最后通过计算每个U出现的概率求得最可能出现的这个U。&#x20;</p>
<img data-src="/2022/10/11/Markov-Logic-Network1/image_qrFDuXAyTx.png" class>
<p>上图将所有的U都列了出来，计算其每个U出现的概率，发现Bob喜欢做研究的概率为百分之七十.</p>
<h3 id="如何将上述的问题和上一节的Graphical-Modal相结合？"><a href="#如何将上述的问题和上一节的Graphical-Modal相结合？" class="headerlink" title="如何将上述的问题和上一节的Graphical Modal相结合？"></a><strong>如何将上述的问题和上一节的Graphical Modal</strong>相结合？</h3><img data-src="/2022/10/11/Markov-Logic-Network1/image_F4s3ZULisE.png" class>
<img data-src="/2022/10/11/Markov-Logic-Network1/image_9S7Rt6yRNs.png" class>
<p><strong>结合方式：</strong></p>
<p>每个预测都当作一个Node，每个formula都当作一个factor，最后所有f概率之和相加等于这个U的score。</p>
<h3 id="Learning"><a href="#Learning" class="headerlink" title="Learning"></a>Learning</h3><p>通过SGD求得<code>P(U)</code> 的极值。</p>
<img data-src="/2022/10/11/Markov-Logic-Network1/image_QCHugx4Ph2.png" class>
]]></content>
      <categories>
        <category>Markov Logic Network</category>
      </categories>
      <tags>
        <tag>Graph Modal</tag>
      </tags>
  </entry>
  <entry>
    <title>Meta Learning</title>
    <url>/2023/03/18/Meta-Learning/</url>
    <content><![CDATA[<p><a href="https://www.bilibili.com/video/BV1w4411872t?p=1&amp;amp;vd_source=271fe543b1f65b00e3d9cee7f5b7d39a&amp;gt">李宏毅老师-Metalearning-Video</a></p>
<img data-src="/2023/03/18/Meta-Learning/image_Mqr_vzHE0W.png" class>
<script type="math/tex; mode=display">
f^{*}=F(D_{train})</script><h3 id="Machine-Learning-VS-Meta-Learning"><a href="#Machine-Learning-VS-Meta-Learning" class="headerlink" title="Machine Learning VS Meta Learning"></a><strong>Machine Learning VS Meta L</strong>earning</h3><p><strong>Machine Learning:</strong> 根据一组照片, 训练一个能够分类这张照片的<code>f</code></p>
<p><strong>Meta Learning</strong> : 根据一组任务, 训练一个能够处理这组任务的<code>F</code></p>
<p>如何<code>init</code>以及如何<code>Update</code>都是人工设计, 不是学出来的.</p>
<p>那么如何让机器学习出如何设计出<code>theta</code>?</p>
<h3 id="如何评价F的好坏"><a href="#如何评价F的好坏" class="headerlink" title="如何评价F的好坏?"></a><strong>如何评价F的好坏?</strong></h3><p>相当于评价一个老师的好坏, 我们是上帝视角, 我们给老师<code>F</code>分发n个教学任务, 老师接受到任务之后要去教学生这n个任务, 最后我们再把n份任务的试卷<code>Test</code>给学生做, 最后把这个学生在这n份任务上的表现<code>loss</code>求和就可以判断这个老师<code>F</code>的好坏了.</p>
<h3 id="测试阶段"><a href="#测试阶段" class="headerlink" title="测试阶段?"></a>测试阶段?</h3><p>相当于给这个学生分配新的没有被教过的任务, 看看他有没有能力从之前学到的任务中汲取经验, 也能够解决这个新的任务.</p>
<img data-src="/2023/03/18/Meta-Learning/image_frT4zvt9sy.png" class>
<p>类似few-shot.</p>
<p><strong>定义Loss:</strong></p>
<script type="math/tex; mode=display">
L(F)=\sum {l^{n}}</script><script type="math/tex; mode=display">
F^{*}=argmin L(F)</script><p>那么让L最小的F就是F *.</p>
<h3 id="N-ways-K-shots"><a href="#N-ways-K-shots" class="headerlink" title="N-ways K-shots"></a>N-ways K-shots</h3><p>n个classes, K个examples</p>
<h3 id="MAML"><a href="#MAML" class="headerlink" title="MAML"></a>MAML</h3><img data-src="/2023/03/18/Meta-Learning/image_VaiHVWRur0.png" class>
<p>如何minimize L?  Gradient descent!!</p>
<p>真的太秒了!!!!!&#x20;</p>
<p>对于MAML中的 <code>φ</code>这个初始值,<strong>也有好坏之分</strong>!!&#x20;</p>
<img data-src="/2023/03/18/Meta-Learning/image_uysERKDIg5.png" class>
<h4 id="例如以下两个-φ的初始值"><a href="#例如以下两个-φ的初始值" class="headerlink" title="例如以下两个 φ的初始值:"></a>例如以下两个 <code>φ</code>的初始值:</h4><img data-src="/2023/03/18/Meta-Learning/image_teH34Q59sk.png" class>
<img data-src="/2023/03/18/Meta-Learning/image_67nCMADDfm.png" class>
<p>图一的 <code>φ</code>虽然在最开始没有图二的 <code>φ</code>在两个<code>loss</code>上的小/优, 但是经过训练之后, 第一个 <code>φ</code>可以达到的最优解明显好于第二个 <code>φ</code>可以达到的最优解.  因为第二个 <code>φ</code>的<code>loss2</code>只停留在local minimun中.</p>
<p>所以,MAML find   <code>φ</code> achieving good performance <strong>after training</strong>, 然而 ML find  <code>φ</code> achieving good performance.</p>
<p><strong>只要UPDATE一次.</strong></p>
<img data-src="/2023/03/18/Meta-Learning/image_Ee7jtehker.png" class>
<p><strong>Q:没太懂,这个MAML和Model Pre-training的却比?</strong></p>
<p>为什么model pretraining 迭代之后会是水平的? 他们的目标是什么?</p>
]]></content>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title>【OpenGL】Create a triangle 1</title>
    <url>/2024/02/02/OpenGL-Create-a-triangle-1/</url>
    <content><![CDATA[<h1 id="Triangle"><a href="#Triangle" class="headerlink" title="Triangle"></a>Triangle</h1><p>// 顶点数组对象：Vertex Array Object, VAO<br>// 顶点缓冲对象：Vertex Buffer Object, VBO<br>// 元素缓冲对象：Element Buffer Object EBO</p>
<p>// 着色器：Shader<br>// 顶点数据：Vertex(3D) + RGB<br>// 图元： Primitive</p>
<img data-src="/2024/02/02/OpenGL-Create-a-triangle-1/1.png" class>
<p><strong>顶点着色器：</strong> Vertex Shader → 输入3D，输出2D</p>
<p><strong>片段着色器：</strong> 用于计算最终像素的颜色</p>
<p><strong>Alpha测试和混合（Blending）</strong>：混合的意思就是如果计算出了多个三角形，经过混合之后的像素颜色不同</p>
<p>我要做的：必须至少定义一个<strong>顶点着色器</strong>和<strong>片段着色器</strong>。</p>
<img data-src="/2024/02/02/OpenGL-Create-a-triangle-1/2.png" class>
<p>标准化设备坐标(-1,1)之间的 normalized device coordinates→  屏幕空间坐标 Screen-space coordinates</p>
<p>【标准化设备坐标】通过<code>glViewport</code>进行 <code>Viewport Tranfrom</code>转变为【屏幕空间坐标】。</p>
<p>顶点缓冲对象VBO来管理这个内存，会在GPU内存中储存大量顶点：</p>
<ul>
<li>可以一次性发动一大批数据到显卡上</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*Hello Triangle*/</span></span><br><span class="line"><span class="comment">// 顶点数组对象：Vertex Array Object, VAO</span></span><br><span class="line"><span class="comment">// 顶点缓冲对象：Vertex Buffer Object, VBO</span></span><br><span class="line"><span class="comment">// 元素缓冲对象：Element Buffer Object EBO</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 着色器：Shader</span></span><br><span class="line"><span class="comment">// 顶点数据：Vertex(3D) + RGB</span></span><br><span class="line"><span class="comment">// 图元： Primitive</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册函数 register a function</span></span><br><span class="line"><span class="comment">// 窗口改变 (window) -&gt; 视口改变(viewport) : viewport is waiting for changing from window</span></span><br><span class="line"><span class="comment">// 总结：谁waiting/被动 -&gt; 谁就call_back</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">process_input</span><span class="params">(GLFWwindow* window)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 着色器语言GLSL(OpenGL Shading Language)</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *vertexShaderSource = <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line"><span class="string">&quot;layout (location = 0) in vec3 aPos;\n&quot;</span></span><br><span class="line"><span class="string">&quot;void main()\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line"><span class="string">&quot;   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#125;\0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *fragmentShader1Source = <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line"><span class="string">&quot;out vec4 FragColor;\n&quot;</span></span><br><span class="line"><span class="string">&quot;void main()\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line"><span class="string">&quot;FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#125;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *fragmentShader2Source = <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line"><span class="string">&quot;out vec4 FragColor;\n&quot;</span></span><br><span class="line"><span class="string">&quot;void main()\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line"><span class="string">&quot;   FragColor = vec4(1.0f, 1.0f, 0.0f, 1.0f);\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#125;\n\0&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ------------------- 初始化glfw ------------------- </span></span><br><span class="line">  glfwInit();</span><br><span class="line">  <span class="comment">// 初始化版本号 -&gt; 330</span></span><br><span class="line">  glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">  glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">  glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ------------------- 初始化window ------------------- </span></span><br><span class="line">  GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, <span class="string">&quot;LearnOpenGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="comment">// 如果没有创建成功</span></span><br><span class="line">  <span class="keyword">if</span> (window == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;cant create a window&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    glfwTerminate();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//设置当前渲染上下文，其实就是告诉gl我现在要渲染的是 : window这个current context</span></span><br><span class="line">  glfwMakeContextCurrent(window);</span><br><span class="line">  glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ------------------- 初始化GLAD------------------- </span></span><br><span class="line">  <span class="keyword">if</span> (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) &#123;</span><br><span class="line">    <span class="comment">// 没有成功初始化GLAD</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;cant initialize the GLAD&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ------------- 顶点着色器 vertex shader ------</span></span><br><span class="line">  <span class="type">int</span> success;</span><br><span class="line">  <span class="type">char</span> infoLog[<span class="number">512</span>];</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> vertexShader;</span><br><span class="line">  vertexShader = glCreateShader(GL_VERTEX_SHADER);</span><br><span class="line">  glShaderSource(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">  glCompileShader(vertexShader);</span><br><span class="line">  glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">  <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">    glGetShaderInfoLog(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ERROR:SHAER::VERTEXT::COMPILATION_FAILED\n&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ---------- 片段着色器 fragment shader -------</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> fragment1Shader;</span><br><span class="line">  fragment1Shader = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line">  glShaderSource(fragment1Shader, <span class="number">1</span>, &amp;fragmentShader1Source, <span class="literal">NULL</span>);</span><br><span class="line">  glCompileShader(fragment1Shader);</span><br><span class="line">  glGetShaderiv(fragment1Shader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">  <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">    glGetShaderInfoLog(fragment1Shader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ERROR::SHAER::FRAGMENT::COMPILATION_FAILED\n&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> fragment2Shader;</span><br><span class="line">  fragment2Shader = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line">  glShaderSource(fragment2Shader, <span class="number">1</span>, &amp;fragmentShader2Source, <span class="literal">NULL</span>);</span><br><span class="line">  glCompileShader(fragment2Shader);</span><br><span class="line">  glGetShaderiv(fragment2Shader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">  <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">    glGetShaderInfoLog(fragment2Shader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ERROR::SHAER::FRAGMENT::COMPILATION_FAILED\n&quot;</span>&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ---------------- 链接着色器 ------------------</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> shader1Program, shader2Program;</span><br><span class="line">  shader1Program = glCreateProgram();</span><br><span class="line">  shader2Program = glCreateProgram();</span><br><span class="line"></span><br><span class="line">  glAttachShader(shader1Program, vertexShader);</span><br><span class="line">  glAttachShader(shader1Program, fragment1Shader);</span><br><span class="line">  glLinkProgram(shader1Program);</span><br><span class="line">  glGetProgramiv(shader1Program, GL_LINK_STATUS, &amp;success);</span><br><span class="line">  <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">    glGetProgramInfoLog(shader1Program, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  glAttachShader(shader2Program, vertexShader);</span><br><span class="line">  glAttachShader(shader2Program, fragment2Shader);</span><br><span class="line">  glLinkProgram(shader2Program);</span><br><span class="line">  glGetProgramiv(shader2Program, GL_LINK_STATUS, &amp;success);</span><br><span class="line">  <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">    glGetProgramInfoLog(shader2Program, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ------------------- 顶点数据 ---------------------</span></span><br><span class="line">  <span class="comment">// 定义一些顶点数据</span></span><br><span class="line">  <span class="type">float</span> firstTriangle[] = &#123;</span><br><span class="line">    <span class="comment">// first triangle</span></span><br><span class="line">    <span class="number">-0.9f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// left </span></span><br><span class="line">    <span class="number">-0.0f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// right</span></span><br><span class="line">    <span class="number">-0.45f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// top </span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="type">float</span> secondTriangle[] = &#123;</span><br><span class="line">    <span class="number">0.0f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">0.9f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">0.45f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// EBO (Indexed Drawing)</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> indices[] = &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>,</span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// ---------------- 定义VAO，VBO对象(gen -&gt; bind -&gt; load)----------------</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> VBOs[<span class="number">2</span>], VAOs[<span class="number">2</span>];</span><br><span class="line">  glGenVertexArrays(<span class="number">2</span>, VAOs);</span><br><span class="line">  glGenBuffers(<span class="number">2</span>, VBOs);</span><br><span class="line">  <span class="comment">// glGenBuffers(1, &amp;EBO);</span></span><br><span class="line"></span><br><span class="line">  glBindVertexArray(VAOs[<span class="number">0</span>]);</span><br><span class="line">  glBindBuffer(GL_ARRAY_BUFFER, VBOs[<span class="number">0</span>]);</span><br><span class="line">  glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(firstTriangle), firstTriangle, GL_STATIC_DRAW);</span><br><span class="line">  glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line">  glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  glBindVertexArray(VAOs[<span class="number">1</span>]);</span><br><span class="line">  glBindBuffer(GL_ARRAY_BUFFER, VBOs[<span class="number">1</span>]);</span><br><span class="line">  glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(secondTriangle), secondTriangle, GL_STATIC_DRAW);</span><br><span class="line">  glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line">  glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用一个while循环来简单渲染</span></span><br><span class="line">  <span class="keyword">while</span> (!glfwWindowShouldClose(window)) &#123;</span><br><span class="line">    <span class="comment">// 处理输入</span></span><br><span class="line">    process_input(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先设置清除缓存的color</span></span><br><span class="line">    glClearColor(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// step4. 绘制图像</span></span><br><span class="line">    glUseProgram(shader1Program);</span><br><span class="line">    glBindVertexArray(VAOs[<span class="number">0</span>]);</span><br><span class="line">    glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    glUseProgram(shader2Program);</span><br><span class="line">    glBindVertexArray(VAOs[<span class="number">1</span>]);</span><br><span class="line">    glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 颜色缓冲绘图</span></span><br><span class="line">    glfwSwapBuffers(window);</span><br><span class="line">    <span class="comment">// 监测有没有中断事件</span></span><br><span class="line">    glfwPollEvents();</span><br><span class="line">  &#125;</span><br><span class="line">  glDeleteVertexArrays(<span class="number">2</span>, VAOs);</span><br><span class="line">  glDeleteBuffers(<span class="number">2</span>, VBOs);</span><br><span class="line">  glDeleteProgram(shader1Program);</span><br><span class="line">  glDeleteProgram(shader2Program);</span><br><span class="line"></span><br><span class="line">  glfwTerminate();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">  glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">process_input</span><span class="params">(GLFWwindow* window)</span> &#123;</span><br><span class="line">  <span class="comment">// 如果用户按了ESC按键，就关闭窗口，如果没按下就会返回GLFW_RELEASE</span></span><br><span class="line">  <span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;you have press esc&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// !!!不是glfwWindowshouldclose 而是 set_xxx</span></span><br><span class="line">    glfwSetWindowShouldClose(window, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>渲染流程<ul>
<li>初始化<ul>
<li>创建window</li>
<li>初始化window</li>
<li>加载GLAD</li>
</ul>
</li>
<li>创建顶点着色器<ul>
<li>create</li>
<li>source</li>
<li>compile</li>
</ul>
</li>
<li>创建片段着色器<ul>
<li>create</li>
<li>source</li>
<li>compile</li>
</ul>
</li>
<li>链接着色器<ul>
<li>attanch</li>
<li>link</li>
<li>产生shaderProgram</li>
</ul>
</li>
<li>VAO，VBO，EBO定义和加载<ul>
<li>generate</li>
<li>bind</li>
<li>load buffer data（加载顶点数据）</li>
</ul>
</li>
<li>while循环渲染<ul>
<li>处理输入</li>
<li>清缓存</li>
<li>绘制<ul>
<li>use shaderProgram</li>
<li>bind要绘制的VAO</li>
<li>draw当前绑定的VAO中的值</li>
</ul>
</li>
</ul>
</li>
<li>delete VAO，VBO，shaderProgram…</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title>【OpenGL】Create a window 0</title>
    <url>/2024/01/30/OpenGL-Create-a-window-0/</url>
    <content><![CDATA[<h2 id="Preliminary"><a href="#Preliminary" class="headerlink" title="Preliminary"></a>Preliminary</h2><p><strong>版本： </strong>面向OpenGL3.3</p>
<p><strong>特性：</strong>对Extension的支持。</p>
<p><strong>状态机（State Machine）：</strong>OpenGL是一个很大的状态机 →  通过改变OpenGL的状态，告诉OpenGL怎么绘图，到底是画三角形还是画线段。</p>
<p><strong>对象： </strong>用C语言写的。可以把对象object看作一个风格的结构体Struct</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">object_name</span> &#123;</span></span><br><span class="line">  xxx</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Cmake：</strong>使用预定义好的CMake脚本，根据不同IDE的工程文件，生成不同的工程文件。</p>
<p>首先打开CMake，然后将<code>/glfw-3.3.9</code>作为源文件，将<code>/glfw-3.3.9/build</code>作为<code>build bineries</code>。这样生成的工程文件就在build。</p>
<blockquote>
<p>🤨什么是.sln文件？： visual studio solution file</p>
</blockquote>
<p><strong>编译：</strong><code>.sln</code> → <code>.lib</code>（库文件）</p>
<p><strong>自定义Lib和Include文件夹：</strong>但是对于</p>
<p><strong>Visual Studio创建一个C++空项目</strong></p>
<p><strong>链接第三方库</strong>：</p>
<ol>
<li>右键Demo0，然后选择VC++ Directories → 修改Library Directories 和 Include Directories.</li>
<li>Linker → 输入</li>
</ol>
<p><strong>GLAD开源库</strong></p>
<p>下载一个GLAD，然后#include<xxx></xxx></p>
<p>【<strong>DEBUG</strong>】<code>#include&lt;iostream&gt;</code>无法找到“源文件” → <a href="https://blog.csdn.net/weixin_38592956/article/details/94668920">https://blog.csdn.net/weixin_38592956/article/details/94668920</a></p>
<p>用源代码自己编译的怎么整都不行，最后用了预编译好的二进制文件，并且最后用了上面的DEBUG。</p>
<p><strong>ps:</strong></p>
<ol>
<li>不要忘记把DEBUG中的x86改成x64</li>
<li>用预编译的不是glfw3.lib，而是glfw3_mt.lib</li>
<li>不要忘记在Linker → Input中加入opengl32.lib</li>
</ol>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 注册函数 register a function</span></span><br><span class="line"><span class="comment">// 窗口改变(window) -&gt; 视口改变(viewport) : viewport is waiting for changing from window</span></span><br><span class="line"><span class="comment">// 总结：谁waiting/被动 -&gt; 谁就call_back</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process_input</span><span class="params">(GLFWwindow* window)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 初始化glfw</span></span><br><span class="line">	<span class="built_in">glfwInit</span>();</span><br><span class="line">	<span class="comment">// 初始化版本号 -&gt; 3.3</span></span><br><span class="line">	<span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">	<span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">	<span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 初始化window</span></span><br><span class="line">	GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(SCR_WIDTH, SCR_HEIGHT, <span class="string">&quot;LearnOpenGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">// 如果没有创建成功</span></span><br><span class="line">	<span class="keyword">if</span> (window == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;cant create a window&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="built_in">glfwTerminate</span>();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置当前渲染上下文，其实就是告诉gl我现在要渲染的是 : window这个current context</span></span><br><span class="line">	<span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">	<span class="built_in">glfwSetFramebufferSizeCallback</span>(window, framebuffer_size_callback);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化GLAD</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress)) &#123;</span><br><span class="line">		<span class="comment">// 没有成功初始化GLAD</span></span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;cant initialize the GLAD&quot;</span> &lt;&lt;std::endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用一个while循环来简单渲染</span></span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window)) &#123;</span><br><span class="line">		<span class="comment">// 处理输入</span></span><br><span class="line">		<span class="built_in">process_input</span>(window);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 先设置清除缓存的color</span></span><br><span class="line">		<span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">		<span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 颜色缓冲绘图</span></span><br><span class="line">		<span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">		<span class="comment">// 监测有没有中断事件</span></span><br><span class="line">		<span class="built_in">glfwPollEvents</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glfwTerminate</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process_input</span><span class="params">(GLFWwindow* window)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 如果用户按了ESC按键，就关闭窗口，如果没按下就会返回GLFW_RELEASE</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;you have press esc&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="comment">// !!!不是glfwWindowshouldclose 而是 set_xxx</span></span><br><span class="line">		<span class="built_in">glfwSetWindowShouldClose</span>(window, <span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>先要初始化glfw(引入的用于绘图的第三方库)，然后初始化window，并且在每次初始化的时候都要监测是否创建成功。</p>
<p>最后要搞清楚，什么是主动的，什么是被动的。</p>
<p>例如这里的glfwWindowShouldClose，就是OpenGL永远是主动的一方，而window是被动的，即放在参数里的。</p>
]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title>SVM</title>
    <url>/2022/10/13/SVM/</url>
    <content><![CDATA[<h3 id="类条件概率密度参数位置，形式难以确定"><a href="#类条件概率密度参数位置，形式难以确定" class="headerlink" title="类条件概率密度参数位置，形式难以确定"></a>类条件概率密度参数位置，形式难以确定</h3><h4 id="最优分类面：-将两类正确分开（error为0），且使得两侧空白区域最大（margin最大），这样可以更加鲁棒。"><a href="#最优分类面：-将两类正确分开（error为0），且使得两侧空白区域最大（margin最大），这样可以更加鲁棒。" class="headerlink" title="最优分类面： 将两类正确分开（error为0），且使得两侧空白区域最大（margin最大），这样可以更加鲁棒。"></a><strong>最优分类面：</strong> 将两类正确分开（error为0），且使得两侧空白区域最大（margin最大），这样可以更加鲁棒。</h4><h4 id="线性支持向量机："><a href="#线性支持向量机：" class="headerlink" title="线性支持向量机："></a>线性支持向量机：</h4><p>是一个二分类模型，适合于中小型数据样本、非线性、高维分类问题</p>
<img data-src="/2022/10/13/SVM/image_B4evXu73AA.png" class>
<p>在说SVM之前先引入<strong>函数间隔和几何间隔</strong>两个概念：</p>
<hr>
<h3 id="函数间隔："><a href="#函数间隔：" class="headerlink" title="函数间隔："></a><strong>函数间隔：</strong></h3><script type="math/tex; mode=display">
\^γ=y(w^Tx+b)=yf(x)</script><p>函数间隔实际上是<strong>类别标签乘上f(x）</strong>，可见该值永远是非负的。仔细想来，如果这个样本点不在超平面上，离得越远，f(x）的绝对值越大，而这个<strong>y标签</strong>，如果只有${-1,1}$中选择的话，其实相当于求f(x)的绝对值.</p>
<p>但是函数间隔存在一个问题是：成比例改变$w，b$，虽然超平面没变，但是函数间隔确成倍增加.</p>
<h3 id="几何间隔："><a href="#几何间隔：" class="headerlink" title="几何间隔："></a>几何间隔：</h3><img data-src="/2022/10/13/SVM/image_LEij8iO51d.png" class>
<p>首先$w$是超平面的法向量，则有</p>
<script type="math/tex; mode=display">
x=x_0+γ\frac{w}{||w||}</script><p>由于$x_0$在超平面上，所以$f(x_0)=0$；</p>
<p>联立上述两式</p>
<script type="math/tex; mode=display">
f(x)=f(x_0+γ\frac{w}{||w||})=f(x_0)+f(γ\frac{w}{||w||}) -b=γ||w||</script><p>$w^Tw = ||w||^2$</p>
<p>于是有$γ=\frac{f(x)}{||w||}$，则有，$~γ=yγ=\frac{\^γ}{||w||}$，可见几何间隔就是函数间隔除以w的范数。</p>
<hr>
<p>于是问题转换为$max(||w||^{-1})$</p>
<img data-src="/2022/10/13/SVM/image_E8hrSyDj9M.png" class>
<hr>
<h3 id="凸优化和拉格朗日对偶"><a href="#凸优化和拉格朗日对偶" class="headerlink" title="凸优化和拉格朗日对偶"></a>凸优化和拉格朗日对偶</h3><img data-src="/2022/10/13/SVM/image_c62oYTZzXU.png" class>
<ul>
<li><p><strong>凸集</strong>：集合中的任意两点连线上的点也在该集合中，则成为凸集（凸集∩凸集=凸集；凸集∪凸集不一定是凸集）</p>
</li>
<li><p><strong>凸优化</strong>：目标函数是凸函数，变量所属集合是凸集。<strong>对于凸优化问题来说，局部最优化解就是全局最优解</strong>。常见的凸优化问题有线性规划、半正定规划。要求$f(x)$是凸函数，$g_i(x)$是凸函数，同时$h_i(x)$是仿射函数（指的是线性函数，形式为$f(x)=ax+b$）</p>
</li>
</ul>
<p>对于一般的优化问题，对f,g,h都没有要求。</p>
<p><a href="https://www.cnblogs.com/dreamvibe/p/4349886.html">参考文章1</a></p>
<p>里面还有关于对偶函数、核函数（主要用于解救额线性不可分的情况）、解决线性不可分的讲述，十分详细.</p>
<p>SVM对应的对偶问题最终可以写成：</p>
<img data-src="/2022/10/13/SVM/image_-Q4IGPHqZT.png" class>
<hr>
<h3 id="KKT条件"><a href="#KKT条件" class="headerlink" title="KKT条件"></a>KKT条件</h3><p>KKT主要用于处理非线性优化问题，是确定极值点的<strong>充要条件</strong>。</p>
<img data-src="/2022/10/13/SVM/image_Q9AIPgjGnB.png" class>
<p><a href="https://www.bilibili.com/read/cv10510092">参考文章2</a></p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>SVM</tag>
      </tags>
  </entry>
  <entry>
    <title>KB based VQA &amp; simVQA</title>
    <url>/2023/03/15/VQA-0/</url>
    <content><![CDATA[<img data-src="/2023/03/15/VQA-0/1.jpg" class>
]]></content>
      <tags>
        <tag>AI</tag>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>Self-knowledge guided retrieval augmentation</title>
    <url>/2023/12/10/Self-knowledge-guided-retrieval-augmentation/</url>
    <content><![CDATA[<img data-src="/2023/12/10/Self-knowledge-guided-retrieval-augmentation/1.jpg" class>
]]></content>
      <tags>
        <tag>LLM</tag>
      </tags>
  </entry>
  <entry>
    <title>Visual arithmetic</title>
    <url>/2022/10/30/Visual-arithmetic/</url>
    <content><![CDATA[<img data-src="/2022/10/30/Visual-arithmetic/%E7%AC%AC%E5%8D%81%E5%91%A8%E6%B1%87%E6%8A%A5_02.jpg" class>
<img data-src="/2022/10/30/Visual-arithmetic/%E7%AC%AC%E5%8D%81%E5%91%A8%E6%B1%87%E6%8A%A5_03.jpg" class>
<img data-src="/2022/10/30/Visual-arithmetic/%E7%AC%AC%E5%8D%81%E5%91%A8%E6%B1%87%E6%8A%A5_04.jpg" class>
<img data-src="/2022/10/30/Visual-arithmetic/%E7%AC%AC%E5%8D%81%E5%91%A8%E6%B1%87%E6%8A%A5_05.jpg" class>
<img data-src="/2022/10/30/Visual-arithmetic/%E7%AC%AC%E5%8D%81%E5%91%A8%E6%B1%87%E6%8A%A5_06.jpg" class>
<img data-src="/2022/10/30/Visual-arithmetic/%E7%AC%AC%E5%8D%81%E5%91%A8%E6%B1%87%E6%8A%A5_07.jpg" class>
<img data-src="/2022/10/30/Visual-arithmetic/%E7%AC%AC%E5%8D%81%E5%91%A8%E6%B1%87%E6%8A%A5_08.jpg" class>
<img data-src="/2022/10/30/Visual-arithmetic/%E7%AC%AC%E5%8D%81%E5%91%A8%E6%B1%87%E6%8A%A5_09.jpg" class>
<img data-src="/2022/10/30/Visual-arithmetic/%E7%AC%AC%E5%8D%81%E5%91%A8%E6%B1%87%E6%8A%A5_10.jpg" class>
]]></content>
      <tags>
        <tag>AI</tag>
        <tag>NLP</tag>
        <tag>KG</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithm-DP</title>
    <url>/2022/10/17/algorithm-dp/</url>
    <content><![CDATA[<h1 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h1><h4 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a><strong>问题描述：</strong></h4><p><strong>体积固定的背包，从一组存在两个属性的（体积、价格）物品中挑选，使得总体积不超过背包容量时的最大价值。</strong></p>
<p>选择价格最高的、体积最小的、性价比最高的都无法保证得到最优解。</p>
<p>尝试蛮力枚举法（暴力出奇迹）,找出价格最大的方案。</p>
<p>&#x20; 省略掉h得到简化得到的伪代码：</p>
<img data-src="/2022/10/17/algorithm-dp/image_0kYUWOQUSB.png" class>
<p>蛮力枚举法的复杂度高，如何优化呢？</p>
<p>其对应的伪代码如下：</p>
<img data-src="/2022/10/17/algorithm-dp/image_p5j2LHwZ2O.png" class>
<p>$P[i,c]$可以解释为一个表格，其实就是<strong>空间换时间</strong>嘛！</p>
<p>其实就是自顶向下，而又自底向上的递归过程：</p>
<p><strong>是否可以不递归，直接计算出</strong>$P[i,c]$<strong>?</strong></p>
<p>妙妙子，由于$P[i,c]=max\{P[i-1,c],P[i-1,c-v_i]+p_i\}$.所以为了确定$P[i,c]$，需要知道其备忘录表格中上方的值和左上方的值。所以这个备忘录应该从左往右，从上往下，一次记录，最后表格右下角的值就是最终求得的值.</p>
<img data-src="/2022/10/17/algorithm-dp/image_tOUj9bEiYU.png" class>
<p>但是有一个问题是，最终得到了最优解，但是到底选择了哪些物品呢？</p>
<p>所以引入了一个表格$R[i,c]=\{1,0\}$用来记录决策过程。如果是选择了第i个物品，则为1，否则为0.</p>
<p><strong>方法：从右下角往前推。</strong> 如果当前为1，则查看$R[i-1,c-v_i]$的位置是1还是0；否则查看$R[i-1,c]$的位置是1还是0，以此类推。</p>
<img data-src="/2022/10/17/algorithm-dp/image_LXpqr1HEZm.png" class>
<img data-src="/2022/10/17/algorithm-dp/image_u03Z85421E.png" class>
<p>算法复杂度为$O(nc)$</p>
<p><strong>什么是动态规划</strong>：就是备忘录法、递归求解。</p>
<h3 id="动态规划的一般步骤"><a href="#动态规划的一般步骤" class="headerlink" title="动态规划的一般步骤"></a>动态规划的一般步骤</h3><ol>
<li><p>问题结构分析</p>
</li>
<li><p>递推关系建立（初始化）</p>
</li>
<li><p>自底向上计算（做好备忘录）</p>
</li>
<li><p>最优方案追踪（构建Rec数组）</p>
</li>
</ol>
<h3 id="动态规划vs分而治之"><a href="#动态规划vs分而治之" class="headerlink" title="动态规划vs分而治之"></a>动态规划vs分而治之</h3><p>动态规划：存在重叠的子问题</p>
<p>分而治之：各个子问题互相独立</p>
<hr>
<h1 id="最大子数组问题"><a href="#最大子数组问题" class="headerlink" title="最大子数组问题"></a>最大子数组问题</h1><p>之前在分治算法的时候讲过。</p>
<p>蛮力枚举的时间复杂度为$O(n^3)$</p>
<p>分而治之的时间复杂度为$O(nlogn)$</p>
<img data-src="/2022/10/17/algorithm-dp/image_cckTY9X5vu.png" class>
<h4 id="动态规划算法"><a href="#动态规划算法" class="headerlink" title="动态规划算法"></a>动态规划算法</h4><p>定义$D[i]$表示以$X[i]$开头的最大子数组和。</p>
<img data-src="/2022/10/17/algorithm-dp/image_EGa7u-HGBV.png" class>
<p>上面两种情况很显而易见，$ Rec  $数组用来记录当前i的最大子数组的结束位置.</p>
<img data-src="/2022/10/17/algorithm-dp/image_vucpS3_HIp.png" class>
<img data-src="/2022/10/17/algorithm-dp/image_rVehi-p1G2.png" class>
<p>对应的伪代码为：</p>
<img data-src="/2022/10/17/algorithm-dp/image_9mPFact8ek.png" class>
<p>可见动态规划解决最大子数组问题的时间复杂度为$O(n)$.对于找到起点和终点的方法就是先找到maxD[i]，则其对应的i就是起点，Rec[i]的值就是终点.</p>
<hr>
<h1 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h1><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p><strong>子序列：</strong> 一个序列去掉零个或多个字符所得的序列.</p>
<img data-src="/2022/10/17/algorithm-dp/image_BEOETj2Yqt.png" class>
<p>注意x序列和y序列的长度不一定相等.</p>
<p>一种方法也是蛮力枚举。由于长度长的子序列依赖于长度短的序列，所以一定存在重叠子问题.</p>
<h4 id="考虑末尾字符"><a href="#考虑末尾字符" class="headerlink" title="考虑末尾字符"></a>考虑末尾字符</h4><p>定义$C[m,n]$：X[1..m]和Y[1..n]的最大公共子序列<strong>的长度</strong></p>
<p>两种情况：</p>
<ol>
<li><strong>末尾字符不等</strong>$x[i-1]\neq y[j-1]$、</li>
</ol>
<script type="math/tex; mode=display">
C[i,j]=max\{C[i-1,j],C[i,j-1]\}</script><p>因为末尾字符不等，所以通过减去其中一个序列的末尾字符达到相等的效果，那么相当于不相等的末尾字符在求最长公共子序列时时没有用的，舍弃就好.</p>
<p>那么也有可能减去一个还是不等，但是由于这是一个<strong>递归式</strong>，所以继续递归下去.</p>
<ol>
<li><strong>末尾字符相等</strong>$x[i-1]= y[j-1]$</li>
</ol>
<script type="math/tex; mode=display">
C[i,j]=C[i-1,j-1]+1</script><p>加的1指的是最末尾的字符已经为最长公共子序列的长度贡献了1.</p>
<img data-src="/2022/10/17/algorithm-dp/image_JoGuQxYDMB.png" class>
<img data-src="/2022/10/17/algorithm-dp/image_nFI3pdsvZD.png" class>
<img data-src="/2022/10/17/algorithm-dp/image_z5g2qLqRYb.png" class>
<p>时间复杂度为$O(nm)$</p>
<hr>
<h1 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a>最长公共子串</h1><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>和最长公共子序列的区别就是：子串必须连续</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>用$C[i,j]$表示以$x_i,y_j$结尾的X[1…i],Y[1…j]的最长公共字串长度</p>
<h3 id="递归公式"><a href="#递归公式" class="headerlink" title="递归公式"></a>递归公式</h3><p><strong>两种情况：</strong></p>
<ol>
<li><p>$ x_i\neq y_j  $则$C[i,j]=0$</p>
</li>
<li><p>$x_i=y_j$则$C[i,j]=C[i-1,j-1]+1$</p>
</li>
</ol>
<p><strong>PS</strong>：由于$C[i,j]$相当于是将所有n*m个最长公共子串长度枚举出来了，所以最终问题的最优解不是$C[i,j]$的右下角，而是这个表格中的最大值，应该维护两个值，分别是最优解的位置$p_{max}$和长度$l_{max}$，用于最后最优解追踪，而不至于最后还要遍历表格n*m来找到最大值。<strong>其实相当于是利用动态规划的枚举方法。</strong></p>
<h3 id="最优方案追踪"><a href="#最优方案追踪" class="headerlink" title="最优方案追踪"></a>最优方案追踪</h3><ul>
<li><p>记录最长公共子串末尾的<strong>位置</strong></p>
</li>
<li><p>记录最长公共子串的<strong>长度</strong></p>
</li>
</ul>
<h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><p>初始化n,m,新建数组C[i,j],lm,pm，初始化C[i,j]；（看着好像都会忘记哪些要初始化，但是把总的代码写一遍就清楚了）。</p>
<p>两个for循环填C[i,j]表&#x20;</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>$O(n·m)$</p>
<hr>
<h1 id="最小编辑距离"><a href="#最小编辑距离" class="headerlink" title="最小编辑距离"></a>最小编辑距离</h1><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>输入：长度为n的字符串s和长度为m的字符串t</p>
<p>输出：一组min|编辑操作|使得s=t</p>
<h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>$D[n,m]$：字符串$s[1..n]$变为$t[1…m]$的最小编辑距离（是一个数）.</p>
<h3 id="递归公式-1"><a href="#递归公式-1" class="headerlink" title="递归公式"></a>递归公式</h3><p><strong>同样考虑末尾元素：</strong></p>
<p><strong>1.删除操作：</strong></p>
<p>将s的末尾删除</p>
<p>$ D[i,j]=D[i-1,j]+1  $（这个1代表删除操作）</p>
<p><strong>2.插入操作：</strong></p>
<p>将s的末尾插入一位t的最后一位,，相当于将s通过D[i,j-1]变成t[1..j-1]，最后在后面插入t[j]就变成t了</p>
<p>$D[i,j]=D[i,j-1]+1$（这个1 代表最后的插入操作）</p>
<p><strong>3.替换操作：</strong></p>
<p>将s的最后一位替换为t的最后一位</p>
<p>如果$s[i]=t[j]$则$D[i,j]=D[i-1][j-1]+0$</p>
<p>否则，$D[i,j]=D[i-1,j-1]+1$（这个1代表替换最后一位）</p>
<img data-src="/2022/10/17/algorithm-dp/image_8HQmyZBM7m.png" class>
<h3 id="初始化-xA"><a href="#初始化-xA" class="headerlink" title="初始化&#xA;"></a>初始化&#xA;</h3><p>初始化$D[i,0]=i;D[0,j]=j$分别对应i次删除和j次插入。</p>
<h3 id="最优方案追踪-1"><a href="#最优方案追踪-1" class="headerlink" title="最优方案追踪"></a>最优方案追踪</h3><p>D表格右下角是最优解。定义一个$Rec[i,j]$数组，记录子问题来源：$L,U,LU$分别对应删除$s[i]$，插入$t[j]$，用$t[j]$替换$s[i]$（或者无操作）</p>
<h3 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h3><ul>
<li><p><strong>初始化：</strong> n,m,新建D数组，Rec数组，初始化D和Rec数组的第一行和第一列</p>
</li>
<li><p><strong>动态规划：</strong></p>
</li>
</ul>
<img data-src="/2022/10/17/algorithm-dp/image_gR_xj0A8_V.png" class>
<ul>
<li>最优方案追踪（打印）（往往这是个递归函数）：</li>
</ul>
<p>那么，递归函数需要有结束条件，具体如下：</p>
<img data-src="/2022/10/17/algorithm-dp/image_EZeV_G9Gm0.png" class>
<p>可以发现，是<strong>先递归调用，再输出</strong>。因为这是<strong>从后往前</strong>推导的。</p>
<h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>$O(mn)$</p>
<hr>
<h1 id="钢条切割问题（区间DP-）"><a href="#钢条切割问题（区间DP-）" class="headerlink" title="钢条切割问题（区间DP ）"></a>钢条切割问题（区间DP ）</h1><h3 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h3><p>钢条长度n，价格表$p_l(1&lt;=l&lt;=n)$.</p>
<p>对于一组切割方案，求解$max\sum_{l=1}^{m}p_{c_l}$使得$\sum_{l=1}^{m}c_l=n$</p>
<h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>$C[j]$：切割长度为j的钢条可得的最大收益</p>
<h3 id="递归公式-2"><a href="#递归公式-2" class="headerlink" title="递归公式"></a>递归公式</h3><script type="math/tex; mode=display">
C[j]=max_{1\leq i\leq j-1}\{p[i]+C[j-i],p[j]\}</script><p>有最优子结构和重叠子问题，为区间动态规划，特点是取最大值max时i和j有范围，这个区间的每一种情况都要枚举，然后找出最大值。</p>
<h3 id="最优方案追踪-2"><a href="#最优方案追踪-2" class="headerlink" title="最优方案追踪"></a>最优方案追踪</h3><p>构造$rec[1..n]$：记录长度为j钢条的最优切割方案</p>
<ol>
<li><p>不切：$rec[j]=j$</p>
</li>
<li><p>切割：$rec[j]=k$（k表格切割的长度）</p>
</li>
</ol>
<p>从后往前，查找$rec[j-rec[j]]$直到为0.</p>
<h3 id="伪代码-2"><a href="#伪代码-2" class="headerlink" title="伪代码"></a>伪代码</h3><ul>
<li><p><strong>初始化</strong>：新建一维数组C[0..n],rec[0..n]</p>
</li>
<li><p><strong>动态规划</strong>：j从1→n，内层i从1到j-1的一个for循环</p>
</li>
<li><p><strong>最优方案追踪</strong>：</p>
</li>
</ul>
<h3 id="时间复杂度-xA"><a href="#时间复杂度-xA" class="headerlink" title="时间复杂度&#xA;"></a>时间复杂度&#xA;</h3><p>$O(n^2)$</p>
<hr>
<h1 id="矩阵链乘法（区间DP）"><a href="#矩阵链乘法（区间DP）" class="headerlink" title="矩阵链乘法（区间DP）"></a>矩阵链乘法（区间DP）</h1><h3 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h3><p>类似于钢条切割问题，给矩阵链加括号（分割）</p>
<h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>$D[i,j]$：对矩阵链$U_{i..j}$对应的最小标量乘法次数</p>
<h3 id="递推公式"><a href="#递推公式" class="headerlink" title="递推公式"></a>递推公式</h3><script type="math/tex; mode=display">
D[i,j]=min_{i \leq k < j}\{D[i,k]+D[k+1,j]+p_{i-1}p_kp_j\}</script><p>如果i = j则这个矩阵链只有一个矩阵，不存在乘法，所以D[i,j]=0</p>
<p>所以D表格的对角线为0，且为一个上三角（i\&lt;j）。</p>
<img data-src="/2022/10/17/algorithm-dp/image_zEjFoIlFHD.png" class>
<h3 id="最优方案追踪-3"><a href="#最优方案追踪-3" class="headerlink" title="最优方案追踪"></a>最优方案追踪</h3><p>从旋转后的金字塔的尖尖所对应的最优解开始推导：如果$rec[i,j]=k$那么相当于是子矩阵链在k的后面切了一刀；然后再分别取查找$rec[i,k]$和$rec[k+1,j]$，下图有处纰漏：</p>
<img data-src="/2022/10/17/algorithm-dp/image_iifpo7R_Cl.png" class>
<h3 id="算法实例"><a href="#算法实例" class="headerlink" title="算法实例"></a>算法实例</h3><img data-src="/2022/10/17/algorithm-dp/image_E-03vPF_fj.png" class>
<h3 id="伪代码-3"><a href="#伪代码-3" class="headerlink" title="伪代码"></a>伪代码</h3><ol>
<li><p><strong>初始化</strong></p>
</li>
<li><p><strong>动态规划</strong></p>
</li>
</ol>
<p>最外层为矩阵链的长度，从2到n</p>
<p>内层嵌套的是长度为l的子矩阵链，从1到n-l+1</p>
<p>最内层循环是k在区间上取最小值</p>
<img data-src="/2022/10/17/algorithm-dp/image_pvy4F8sInf.png" class>
<h3 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>$O(n)$</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>CarbonX</title>
    <url>/2024/11/29/carbonx/</url>
    <content><![CDATA[<img data-src="/2024/11/29/carbonx/00.jpg" class>
<img data-src="/2024/11/29/carbonx/01.jpg" class>
<img data-src="/2024/11/29/carbonx/02.jpg" class>
<img data-src="/2024/11/29/carbonx/03.jpg" class>
<img data-src="/2024/11/29/carbonx/04.jpg" class>
<img data-src="/2024/11/29/carbonx/05.jpg" class>
<img data-src="/2024/11/29/carbonx/06.jpg" class>
<img data-src="/2024/11/29/carbonx/07.jpg" class>
<img data-src="/2024/11/29/carbonx/08.jpg" class>
<img data-src="/2024/11/29/carbonx/09.jpg" class>
<img data-src="/2024/11/29/carbonx/10.jpg" class>
<img data-src="/2024/11/29/carbonx/11.jpg" class>
<img data-src="/2024/11/29/carbonx/12.jpg" class>
<img data-src="/2024/11/29/carbonx/13.jpg" class>
<img data-src="/2024/11/29/carbonx/14.jpg" class>
<img data-src="/2024/11/29/carbonx/15.jpg" class>
<img data-src="/2024/11/29/carbonx/16.jpg" class>
<img data-src="/2024/11/29/carbonx/17.jpg" class>
<img data-src="/2024/11/29/carbonx/18.jpg" class>
<img data-src="/2024/11/29/carbonx/19.jpg" class>
<img data-src="/2024/11/29/carbonx/20.jpg" class>
<img data-src="/2024/11/29/carbonx/21.jpg" class>
]]></content>
      <categories>
        <category>WEB3</category>
      </categories>
      <tags>
        <tag>web3</tag>
        <tag>blockchain</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithm-hw-3</title>
    <url>/2022/11/22/algorithmHw-3/</url>
    <content><![CDATA[<img data-src="/2022/11/22/algorithmHw-3/1.jpg" class>
<img data-src="/2022/11/22/algorithmHw-3/2.jpg" class>
<img data-src="/2022/11/22/algorithmHw-3/3.jpg" class>
<img data-src="/2022/11/22/algorithmHw-3/4.jpg" class>
<img data-src="/2022/11/22/algorithmHw-3/5.jpg" class>
<img data-src="/2022/11/22/algorithmHw-3/6.jpg" class>
<img data-src="/2022/11/22/algorithmHw-3/7.jpg" class>
<p>如有错误请指出！</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>greedy search</tag>
      </tags>
  </entry>
  <entry>
    <title>Compiler-词法分析-1</title>
    <url>/2022/10/14/chapter1-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="具体要求"><a href="#具体要求" class="headerlink" title="具体要求"></a>具体要求</h3><p>对输入的<code>testfile.txt</code> 文件逐行解析，并输出对应的单词名称和类别码，具体输出要求如下表所示：</p>
<img data-src="/2022/10/14/chapter1-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image_gCe5-FREvU.png" class>
<p>输入输出要求具体如下所示：</p>
<p><strong>输入：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> f = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> CONSTTK <span class="type">const</span></span><br><span class="line"><span class="number">1</span> INTTK <span class="type">int</span></span><br><span class="line"><span class="number">1</span> IDENFR a</span><br><span class="line"><span class="number">1</span> ASSIGN =</span><br><span class="line"><span class="number">1</span> INTCON <span class="number">0</span></span><br><span class="line"><span class="number">1</span> SEMICN ;</span><br><span class="line"><span class="number">2</span> INTTK <span class="type">int</span></span><br><span class="line"><span class="number">2</span> MAINTK main</span><br><span class="line"><span class="number">2</span> LPARENT (</span><br><span class="line"><span class="number">2</span> RPARENT )</span><br><span class="line"><span class="number">2</span> LBRACE &#123;</span><br><span class="line"><span class="number">3</span> INTTK <span class="type">int</span></span><br><span class="line"><span class="number">3</span> IDENFR f</span><br><span class="line"><span class="number">3</span> ASSIGN =</span><br><span class="line"><span class="number">3</span> INTCON <span class="number">0</span></span><br><span class="line"><span class="number">3</span> SEMICN ;</span><br><span class="line"><span class="number">4</span> RETURNTK <span class="keyword">return</span></span><br><span class="line"><span class="number">4</span> INTCON <span class="number">0</span></span><br><span class="line"><span class="number">4</span> SEMICN ;</span><br><span class="line"><span class="number">5</span> RBRACE &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中第一列为行号，第二列为类别码，第三列为token.</p>
<h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><p>通过有限自动机DFA实现对输入序列进行处理：</p>
<img data-src="/2022/10/14/chapter1-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image_kFjhbTCHr4.png" class>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>词法分析部分的类的构建我只用了一个<code>Morpho</code>，从<code>Compiler</code> 程序进入<code>Morpho</code> 类中，最后<code>Morpho</code> 能够输出对应的行号、类别码、token.</p>
<img data-src="/2022/10/14/chapter1-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image_C8uyeszCzM.png" class>
<h4 id="Morpho词法分析类："><a href="#Morpho词法分析类：" class="headerlink" title="Morpho词法分析类："></a>Morpho词法分析类：</h4><ul>
<li><p><code>HashMap&lt;Integer,String&gt; lineRawMap</code>：用于存储读入文件，key为行号，value为每行的内容，通过readFile读入</p>
</li>
<li><p><code>HashMap&lt;Integer,String&gt; typeMap</code> ：存储类别码</p>
</li>
<li><p><code>HashMap&lt;Integer,String&gt; wordMap</code> ：存储token</p>
</li>
<li><p><code>HashMap&lt;Integer,String&gt; lineMap</code> ：存储每个token对应的行号</p>
</li>
<li><p><code>lexer</code>：输出token的总数量</p>
</li>
</ul>
<p>（实际上是通过<code>lexer</code>同时维护上述三个hashmap，同增同减）</p>
<ul>
<li><p><code>int status</code> ：当前状态</p>
</li>
<li><p><code>String cache</code>：缓存器</p>
</li>
<li><p><code>pointer</code>：指针，用于扫描当前行</p>
</li>
<li><p><code>INITIAL</code>,<code>IDENT</code>,<code>INTCONST</code>,<code>FORMATSTRING</code>,<code>SINGLECHAR</code>,<code>SINGLECOMMENTS</code>,<code>MULTICOMMENTS</code>,<code>PREDOUBLECHAR</code>：状态的中间形式</p>
</li>
</ul>
<p>以上就是对这个类的属性的解释。</p>
<p>其中<code>PREDOUBLECHAR</code>指的是识别到<code>&amp;&amp;</code>和<code>||</code>的第一个字符时的状态。</p>
<p><strong>方法：</strong></p>
<ul>
<li><code>work</code> ：用于分析主程序</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123; <span class="comment">//分析总程序</span></span><br><span class="line">        readFile();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : lineRawMap.entrySet()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.pointer = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (status == SINGLECOMMENTS) &#123;</span><br><span class="line">                <span class="built_in">this</span>.status = INITIAL; <span class="comment">//指的是上一行的状态是单行注释，换行后单行注释失效，状态重回INITIAL</span></span><br><span class="line">                cache = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(status == MULTICOMMENTS) &#123; </span><br><span class="line">                cache = <span class="string">&quot;&quot;</span>; <span class="comment">//指的是上一行的状态是多行注释，换行后多行注释依然有效，状态不变，但清空cache</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//用于将上一行末尾的未经激发的token通过加一个空字符串转换掉</span></span><br><span class="line">            <span class="keyword">if</span>(cache.length() != <span class="number">0</span>) &#123;</span><br><span class="line">                transferStatus(entry.getKey() - <span class="number">1</span>,<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">                cache = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                status = INITIAL;</span><br><span class="line">                <span class="built_in">this</span>.pointer = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//扫描当前行，并进行状态转换</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">this</span>.pointer &lt; entry.getValue().length()) &#123;</span><br><span class="line">                transferStatus(entry.getKey(), entry.getValue().charAt(<span class="built_in">this</span>.pointer));</span><br><span class="line">                pointer++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(status != INITIAL) &#123;</span><br><span class="line">            transferStatus(lineRawMap.size(),<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        File f=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;output.txt&quot;</span>);</span><br><span class="line">        f.createNewFile();</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(f);</span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">printStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(fileOutputStream);</span><br><span class="line">        System.setOut(printStream);</span><br><span class="line">        ArrayList&lt;Token&gt; tokens = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; typeMap.size();i ++) &#123;</span><br><span class="line">            System.out.println(lineMap.get(i)+<span class="string">&quot; &quot;</span>+typeMap.get(i) + <span class="string">&quot; &quot;</span> + wordMap.get(i));</span><br><span class="line">            <span class="type">Token</span> <span class="variable">token</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Token</span>(typeMap.get(i),wordMap.get(i),lineMap.get(i));</span><br><span class="line">            tokens.add(token);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>transferStatus</code>：用于状态转移</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">public <span class="type">void</span> <span class="title function_">transferStatus</span><span class="params">(Integer line, Character ch)</span> &#123; <span class="comment">//状态转移</span></span><br><span class="line">        <span class="keyword">if</span> (this.status == INITIAL) &#123;</span><br><span class="line">            <span class="comment">//输入&#x27; &#x27;用于重置当前状态</span></span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27; &#x27;</span>) this.status = INITIAL; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (isLetter(ch) || ch == <span class="string">&#x27;_&#x27;</span>) &#123;</span><br><span class="line">                this.status = IDENT;</span><br><span class="line">                this.cache += ch;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (isDigit(ch)) &#123;</span><br><span class="line">                this.status = INTCONST;</span><br><span class="line">                this.cache += ch;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;&quot;&#x27;</span>) &#123;</span><br><span class="line">                this.status = FORMATSTRING;</span><br><span class="line">                cache += ch;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SingleCharMap.containsKey(ch+<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">                this.status = SINGLECHAR;</span><br><span class="line">                cache += ch;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(PreDoubleCharMap.contains(ch+<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">                this.status = PREDOUBLECHAR;</span><br><span class="line">                cache += ch;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (this.status == IDENT) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isLetter(ch) || ch == <span class="string">&#x27;_&#x27;</span> || isDigit(ch)) &#123;</span><br><span class="line">                this.status = IDENT;</span><br><span class="line">                this.cache += ch;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (reservedIdent.containsKey(cache)) &#123;</span><br><span class="line">                    <span class="comment">//保留字</span></span><br><span class="line">                    putAll(reservedIdent.get(cache), cache, line);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//标识符</span></span><br><span class="line">                    putAll(<span class="string">&quot;IDENFR&quot;</span>, cache, line);</span><br><span class="line">                &#125;</span><br><span class="line">                clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (this.status == INTCONST) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isDigit(ch)) &#123;</span><br><span class="line">                this.status = INTCONST;</span><br><span class="line">                cache += ch;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                putAll(<span class="string">&quot;INTCON&quot;</span>, cache, line);</span><br><span class="line">                clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (this.status == FORMATSTRING) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch != <span class="string">&#x27;&quot;&#x27;</span>) &#123;</span><br><span class="line">                this.status = FORMATSTRING;</span><br><span class="line">                cache += ch;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                putAll(<span class="string">&quot;STRCON&quot;</span>, cache+ch, line);</span><br><span class="line">                clear();</span><br><span class="line">                pointer++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (this.status == SINGLECHAR) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DoubleCharMap.containsKey(cache + ch)) &#123; <span class="comment">//处理的是&gt;= &lt;= != ==</span></span><br><span class="line">                putAll(DoubleCharMap.get(cache + ch), cache + ch, line);</span><br><span class="line">                cache = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                this.status = INITIAL;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((cache+ch).equals(<span class="string">&quot;//&quot;</span>)) &#123;</span><br><span class="line">                this.status = SINGLECOMMENTS;</span><br><span class="line">                cache = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((cache + ch).equals(<span class="string">&quot;/*&quot;</span>)) &#123;</span><br><span class="line">                this.status = MULTICOMMENTS;</span><br><span class="line">                cache = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                putAll(SingleCharMap.get(cache), cache, line);</span><br><span class="line">                clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (this.status == PREDOUBLECHAR)&#123;</span><br><span class="line">            <span class="keyword">if</span> (DoubleCharMap.containsKey(cache + ch)) &#123; <span class="comment">//处理的是&amp;&amp; ||</span></span><br><span class="line">                putAll(DoubleCharMap.get(cache + ch), cache + ch, line);</span><br><span class="line">                cache = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                this.status = INITIAL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (this.status == SINGLECOMMENTS) &#123;</span><br><span class="line">            cache = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (this.status == MULTICOMMENTS) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cache.length() &gt;= <span class="number">1</span> &amp;&amp; cache.charAt(cache.length() - <span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span> &amp;&amp; ch == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                cache = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                this.status = INITIAL;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                this.status = MULTICOMMENTS;</span><br><span class="line">                cache += ch;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            this.status = INITIAL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.cache = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="built_in">this</span>.status = INITIAL;</span><br><span class="line">    <span class="built_in">this</span>.pointer--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putAll</span><span class="params">(String type, String word, Integer line)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.typeMap.put(lexer, type);</span><br><span class="line">    <span class="built_in">this</span>.wordMap.put(lexer, word);</span><br><span class="line">    <span class="built_in">this</span>.lineMap.put(lexer, line);</span><br><span class="line">    lexer++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意<code>clear()</code>函数<strong>出现在每次状态转换完</strong>，因为是当前字符使得当前状态结束，所以<code>pointer</code>应该回退一格，使得当前状态重新变为<code>INITIAL</code>准备好了之后，再<strong>重新处理这个字符</strong>。</p>
<p>但是有个<strong>特殊情况</strong>FormatString，这个状态结束是遇到了<code>&quot;</code>。所以这个双引号也要加入到输出中，所以clear之后，pointer++，否则这个双引号要重新判断一遍了。</p>
<p><strong>总结一下：</strong> 就是要把cache+ch都加入进去的时候，clear()完之后要让pointer++，其余状态转换之后直接clear()即可.</p>
<h3 id="注意细节"><a href="#注意细节" class="headerlink" title="注意细节"></a>注意细节</h3><p><code>PREDOUBLECHAR</code>状态时，如果ch+cache在<code>DoubleCharMap</code>中，则放入；而且，在<code>SINGLECHAR</code> 状态时，如果ch+cache在<code>DoubleCharMap</code> 中，则同样也要加入（专指<code>==</code>等双字符）。所以<strong>总共有两条途径</strong>要用到<code>DoubleCharMap</code>&#x20;</p>
]]></content>
      <categories>
        <category>Compiler</category>
      </categories>
  </entry>
  <entry>
    <title>Graph Modal and Gibbs Sampling</title>
    <url>/2022/10/10/graph-modal/</url>
    <content><![CDATA[<h1 id="Structured-Learning-and-Gibbs-Sampling-x20"><a href="#Structured-Learning-and-Gibbs-Sampling-x20" class="headerlink" title="Structured Learning and Gibbs Sampling&#x20;"></a>Structured Learning and Gibbs Sampling&#x20;</h1><h2 id="Graphical-Modal"><a href="#Graphical-Modal" class="headerlink" title="Graphical Modal"></a>Graphical Modal</h2><h3 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h3><p><strong>Clique: 连通子图</strong></p>
<p><strong>Maximum Clique:最大连通子图</strong></p>
<h3 id="MRF"><a href="#MRF" class="headerlink" title="MRF"></a>MRF</h3><p><strong>定义：每个最大连通子图都通过一个factor和另外的相连接</strong></p>
<p><strong>MRF→Factor Graph</strong></p>
<img data-src="/2022/10/10/graph-modal/image_-9iFtQtux8.png" class>
<img data-src="/2022/10/10/graph-modal/image_aqfpF1OJ6v.png" class>
<h2 id="Training"><a href="#Training" class="headerlink" title="Training"></a><strong>Training</strong></h2><img data-src="/2022/10/10/graph-modal/image_Qm_kJ9nNyR.png" class>
<p><strong>如何将函数f描述为线性的？</strong></p>
<img data-src="/2022/10/10/graph-modal/image_OHIttIS9Yu.png" class>
<p>如果y是连续的…</p>
<p>这些函数f可以通过structured SVM求得。</p>
<img data-src="/2022/10/10/graph-modal/image_eHfwxZpf2O.png" class>
<hr>
<h2 id="Gibbs-Sampling"><a href="#Gibbs-Sampling" class="headerlink" title="Gibbs Sampling"></a>Gibbs Sampling</h2><h2 id="Inference"><a href="#Inference" class="headerlink" title="Inference"></a>Inference</h2><img data-src="/2022/10/10/graph-modal/image_OY8ZHrdWwk.png" class>
<p>定义好了factor函数之后，目标是找到一组y使得F得分之和最大。显然穷举的方法不适用。接下去是通过概率的角度考虑：</p>
<img data-src="/2022/10/10/graph-modal/image_hswehZyFnQ.png" class>
<p>由于已经得到<code>P(y|x)</code> 的概率是独立于y的，即和y没有关系，只和分子<code>F(x,y)</code> 成正比，因此目标函数可以转换为<code>argmax(P(y|x))</code>，而<code>P(y|x)</code> 是一个概率分布（横轴是x，纵轴是一组y）</p>
<img data-src="/2022/10/10/graph-modal/image_7-OELSPakr.png" class>
<img data-src="/2022/10/10/graph-modal/image_8fNl-JaD52.png" class>
<p>存在一个神奇的问题就是：<code>P(y|x)</code>和通过sampling求出的<code>y1,y2,...,yT</code> 几乎一样。Gibbs Sampling就是假设只有一个<code>y_i</code> 是未知的，其他是已知的，通过剩余的y来计算概率。</p>
<p>&#x20;接下去手算一个Gibbs Sampling:</p>
<img data-src="/2022/10/10/graph-modal/image_IWAGwGyUVL.png" class>
<img data-src="/2022/10/10/graph-modal/image_cxEVDnVlWs.png" class>
<p><strong>注意：</strong> Random sample是从一堆y中随机挑选，不一定一定挑到y2=1的，因为y2=1和y2=-1的概率差不多大。</p>
<img data-src="/2022/10/10/graph-modal/image_DYEzbRpv6p.png" class>
<img data-src="/2022/10/10/graph-modal/image_Cj5xYDdZPe.png" class>
<p>通过迭代计算结果为：</p>
<img data-src="/2022/10/10/graph-modal/image_JxEOz-idnc.png" class>
<p><strong>初始化不会影响最终结果，只会最开始的几个sample有影响，</strong> 所以对于最开始的几个Sample可以通过以下方法来调整概率，使得结果相差更大：</p>
<img data-src="/2022/10/10/graph-modal/image_4TJUMh3kUB.png" class>
<hr>
<h3 id="Markov-chain解释可以通过Gibbs-Sampling来替代P-y-x"><a href="#Markov-chain解释可以通过Gibbs-Sampling来替代P-y-x" class="headerlink" title="Markov chain解释可以通过Gibbs Sampling来替代P(y|x)"></a>Markov chain解释可以通过Gibbs Sampling来替代P(y|x)</h3><img data-src="/2022/10/10/graph-modal/image_TzGGooe9fO.png" class>
<p>可见一个人在经过10000天的旅行，他A,B,C三地的概率是稳定的，和他初始在哪个地点无关。即从在A时A→A,在B时B→A,在C时C→A的概率和等于P(A)：</p>
<img data-src="/2022/10/10/graph-modal/image_ARY5gAHZf5.png" class>
<p>😭终于讲到markov了…</p>
<p>如果任意一个<code>P(s|s&#39;)</code> 不等于零，则这个马尔科夫链存在一个稳定的概率分布，但是充分不必要条件。</p>
<img data-src="/2022/10/10/graph-modal/image_eL3SlOBpdU.png" class>
<p>可见$z^1,z^2,…,z^T$组成一个<strong>Markov chain</strong>，因为每个$z$都只和前一个状态有关。所以只需要算这个Markov chain的稳定分布 <strong>（条件是所有条件概率都不为零）</strong> 的最大值对应的z即可。</p>
]]></content>
      <categories>
        <category>Markov Logic Network</category>
      </categories>
      <tags>
        <tag>Graph Modal</tag>
      </tags>
  </entry>
  <entry>
    <title>maven+vue+springboot</title>
    <url>/2022/11/13/maven-vue-springboot/</url>
    <content><![CDATA[<h1 id="运行maven-vue-springboot项目"><a href="#运行maven-vue-springboot项目" class="headerlink" title="运行maven + vue + springboot项目"></a>运行maven + vue + springboot项目</h1><h2 id="运行步骤-后端篇"><a href="#运行步骤-后端篇" class="headerlink" title="运行步骤-后端篇"></a>运行步骤-后端篇</h2><ol>
<li><p>在pol.xml文件中  右键 点击 <code>Add as a maven project</code></p>
</li>
<li><p>配置Maven</p>

</li>
<li><p>添加database</p>
</li>
</ol>
<img data-src="/2022/11/13/maven-vue-springboot/image_q8ZVhWlIzS.png" class>
<ol>
<li>输入用户名和密码 ，test connection</li>
</ol>
<img data-src="/2022/11/13/maven-vue-springboot/image_S6VsysrENC.png" class>
<ol>
<li>新建数据库vuesbag</li>
</ol>
<img data-src="/2022/11/13/maven-vue-springboot/image_a9QffP5Fhm.png" class>
<ol>
<li>选择新建的数据库</li>
</ol>
<img data-src="/2022/11/13/maven-vue-springboot/image_pZfnsaP8xG.png" class>
<ol>
<li>执行sql文件  初始化数据库</li>
</ol>
<img data-src="/2022/11/13/maven-vue-springboot/image_DRf5TIi1j0.png" class>
<ol>
<li>点击Run mysql.sql之后选择新建的数据库</li>
</ol>
<img data-src="/2022/11/13/maven-vue-springboot/image_GO21sA6yY8.png" class>
<ol>
<li>run完之后会发现数据库已被初始化，生成了很多表</li>
</ol>
<img data-src="/2022/11/13/maven-vue-springboot/image_dNV8LYgDof.png" class>
<ol>
<li>修改src/main/resources/application.yml文件</li>
</ol>
<img data-src="/2022/11/13/maven-vue-springboot/image_GBrbU3cZDA.png" class>
<p>如图：</p>
<img data-src="/2022/11/13/maven-vue-springboot/image_ZgGqwRGpEN.png" class>
<ol>
<li>右上角运行启动类</li>
</ol>
<img data-src="/2022/11/13/maven-vue-springboot/image_lZkUoTpZTh.png" class>
<ol>
<li>运行之后发现报错：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Sun</span> <span class="title class_">Nov</span> <span class="number">13</span> <span class="number">11</span>:<span class="number">25</span>:<span class="number">54</span> <span class="variable constant_">CST</span> <span class="number">2022</span> <span class="attr">WARN</span>: <span class="title class_">Establishing</span> <span class="variable constant_">SSL</span> connection without server<span class="string">&#x27;s identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn&#x27;</span>t set. <span class="title class_">For</span> compliance <span class="keyword">with</span> existing applications not using <span class="variable constant_">SSL</span> the verifyServerCertificate property is set to <span class="string">&#x27;false&#x27;</span>. <span class="title class_">You</span> need either to explicitly disable <span class="variable constant_">SSL</span> by setting useSSL=<span class="literal">false</span>, or set useSSL=<span class="literal">true</span> and provide truststore <span class="keyword">for</span> server certificate verification.</span><br><span class="line"><span class="number">2022</span>-<span class="number">11</span>-<span class="number">13</span> <span class="number">11</span>:<span class="number">25</span>:<span class="number">55.010</span> <span class="variable constant_">ERROR</span> <span class="number">17660</span> --- [eate-<span class="number">1886236609</span>] com.<span class="property">alibaba</span>.<span class="property">druid</span>.<span class="property">pool</span>.<span class="property">DruidDataSource</span>   : create connection <span class="title class_">SQLException</span>, <span class="attr">url</span>: <span class="attr">jdbc</span>:<span class="attr">mysql</span>:<span class="comment">//localhost:3306/vuesbag?allowMultiQueries=true&amp;useUnicode=true&amp;characterEncoding=UTF-8, errorCode 0, state 08S01</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<img data-src="/2022/11/13/maven-vue-springboot/image_aAz86gRUhW.png" class>
<p><strong>解决方法：在url最后加上</strong><code>useSSL=false</code></p>
<ol>
<li>最后后端成功运行</li>
</ol>
<img data-src="/2022/11/13/maven-vue-springboot/image_vRSLjlcB5r.png" class>
<h2 id="运行步骤-前端篇"><a href="#运行步骤-前端篇" class="headerlink" title="运行步骤-前端篇"></a>运行步骤-前端篇</h2><ol>
<li>进入前端文件夹<code>npm install</code></li>
</ol>
<img data-src="/2022/11/13/maven-vue-springboot/image_NEY98EzA5E.png" class>
<h3 id="报错1"><a href="#报错1" class="headerlink" title="报错1"></a>报错1</h3><p><code>Error: Can‘t find Python executable “python“, you can set the PYTHON env variable</code></p>
<p>cmd<strong>管理员运行</strong></p>
<p><code>npm install --global --production windows-build-tools</code></p>
<hr>
<img data-src="/2022/11/13/maven-vue-springboot/image_gPXNdMXij-.png" class>
<h3 id="报错2"><a href="#报错2" class="headerlink" title="报错2"></a>报错2</h3><p>npm run dev之后报错按照这个install一下就行</p>
<img data-src="/2022/11/13/maven-vue-springboot/image_MvI7LDIIIt.png" class>
<h3 id="报错3"><a href="#报错3" class="headerlink" title="报错3"></a>报错3</h3><p>Error: Cannot find module ‘node-sass’</p>
<p><code>cnpm install node-sass@latest</code></p>
<h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>最后如果<code>npm run dev</code>还报错，则再<code>npm install</code>一下就好了。</p>
<hr>
<h2 id="运行成功截图"><a href="#运行成功截图" class="headerlink" title="运行成功截图"></a>运行成功截图</h2><img data-src="/2022/11/13/maven-vue-springboot/image_vBrB6gi_kB.png" class>
]]></content>
      <tags>
        <tag>maven</tag>
        <tag>vue</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>Multihop KG</title>
    <url>/2022/11/09/multihop/</url>
    <content><![CDATA[<img data-src="/2022/11/09/multihop/%E6%B1%87%E6%8A%A511.9_01.jpg" class>
<img data-src="/2022/11/09/multihop/%E6%B1%87%E6%8A%A511.9_02.jpg" class>
<img data-src="/2022/11/09/multihop/%E6%B1%87%E6%8A%A511.9_03.jpg" class>
<img data-src="/2022/11/09/multihop/%E6%B1%87%E6%8A%A511.9_04.jpg" class>
<img data-src="/2022/11/09/multihop/%E6%B1%87%E6%8A%A511.9_05.jpg" class>
<img data-src="/2022/11/09/multihop/%E6%B1%87%E6%8A%A511.9_06.jpg" class>
<img data-src="/2022/11/09/multihop/%E6%B1%87%E6%8A%A511.9_07.jpg" class>
<img data-src="/2022/11/09/multihop/%E6%B1%87%E6%8A%A511.9_08.jpg" class>
<img data-src="/2022/11/09/multihop/%E6%B1%87%E6%8A%A511.9_09.jpg" class>
<img data-src="/2022/11/09/multihop/%E6%B1%87%E6%8A%A511.9_10.jpg" class>
<img data-src="/2022/11/09/multihop/%E6%B1%87%E6%8A%A511.9_11.jpg" class>
<img data-src="/2022/11/09/multihop/%E6%B1%87%E6%8A%A511.9_12.jpg" class>
<img data-src="/2022/11/09/multihop/%E6%B1%87%E6%8A%A511.9_13.jpg" class>
<img data-src="/2022/11/09/multihop/%E6%B1%87%E6%8A%A511.9_14.jpg" class>
<img data-src="/2022/11/09/multihop/%E6%B1%87%E6%8A%A511.9_15.jpg" class>
]]></content>
      <tags>
        <tag>Graph Modal</tag>
        <tag>MultiHop</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-day1</title>
    <url>/2022/11/08/vue-day1/</url>
    <content><![CDATA[<h1 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h1><h4 id="实现TodoList"><a href="#实现TodoList" class="headerlink" title="实现TodoList"></a>实现TodoList</h4><p>（虽然早在半年前都做过一遍了，很长时间也没用忘得差不多了，于是再重新系统地学一遍）</p>
<p>1.写vue不要忘记加setup：<code>&lt;script setup&gt;</code></p>
<p>2.<code>v-for=&quot;(item,index) in list&quot;</code> 其中的item和index的位置不能写错</p>
<p>3.v-bind和v-model的区别：v-bind是单向绑定，v-model是双向绑定。</p>
<p>4.原本用的是var变量，但是为了<strong>实时渲染，</strong> 用的是<code>const list = ref([])</code></p>
<p>5.删除数组中的某处索引<code>splice(index,i)</code>表示从index开始的i个数删掉</p>
<p>6.可以发现计算属性和函数可以实现完全一样的功能。但是计算属性基于依赖的存储属性的值变化而重新计算，结果会被缓存，但是函数是每次都会都会重新执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; computed &#125; <span class="keyword">from</span> <span class="string">&#x27;@vue/reactivity&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> list = <span class="title function_">ref</span>([])</span><br><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">var</span> content0 = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">const</span> newTodo = <span class="title function_">ref</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addTodo</span> () &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;list:&quot;</span>+list.<span class="property">value</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;content:&quot;</span>+newTodo.<span class="property">value</span>)</span><br><span class="line">    list.<span class="property">value</span>.<span class="title function_">push</span>(newTodo.<span class="property">value</span>)</span><br><span class="line">    count.<span class="property">value</span>++;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;count:&quot;</span>+count)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;list after:&quot;</span>+list.<span class="property">value</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">removeTodo</span>(<span class="params">index</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;index:&quot;</span>+index);</span><br><span class="line">    list.<span class="property">value</span>.<span class="title function_">splice</span>(index,<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其实就相当于computed:&#123;&#125;里的计算属性</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">type</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;count:&quot;</span>+count.<span class="property">value</span>)</span><br><span class="line">    <span class="keyword">return</span> count.<span class="property">value</span> &gt; <span class="number">10</span> ? <span class="number">2</span> : <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>TodoList<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;newTodo&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;input..&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;addTodo&quot;</span>&gt;</span>add<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item,index) in list&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;&#123;item&#125;&#125;<span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;removeTodo(index)&quot;</span>&gt;</span>remove<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;&#123;type()&#125;&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>myfirst</title>
    <url>/2022/09/06/myfirst/</url>
    <content><![CDATA[<h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="image"><a href="#image" class="headerlink" title="image"></a>image</h3><img data-src="/2022/09/06/myfirst/cc.jpg" class title="This is a test image">
<p><strong>This is my first blog !😋</strong></p>
]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>中风预测</title>
    <url>/2022/11/24/%E4%B8%AD%E9%A3%8E%E9%A2%84%E6%B5%8B/</url>
    <content><![CDATA[<h1 id="个人作业"><a href="#个人作业" class="headerlink" title="个人作业"></a>个人作业</h1><h1 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h1><h3 id="读入数据"><a href="#读入数据" class="headerlink" title="读入数据"></a>读入数据</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_data = pd.read_csv(<span class="string">&#x27;./train.csv&#x27;</span>, encoding=<span class="string">&#x27;ISO-8859-1&#x27;</span>)</span><br><span class="line">len_train_data = <span class="built_in">len</span>(train_data)</span><br></pre></td></tr></table></figure>
<h3 id="数据数字化"><a href="#数据数字化" class="headerlink" title="数据数字化"></a>数据数字化</h3><p>使得未用数字标识的性别、是否结婚、工作、居住地、是否抽烟用数字表示。</p>
<p>由于bmi指数有上百条数据为空，所以这里的处理是求取bmi均值，替代空值【原本的处理方式是将bmi为空值的数据丢弃，但是由于标签为1的稀疏性，最后的预测结果很差，所以最后还是将bmi为空值的数据用均值替代】。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(len_train_data):</span><br><span class="line">    entity = train_data.loc[i]</span><br><span class="line">    <span class="keyword">if</span> math.isnan(entity[<span class="string">&#x27;bmi&#x27;</span>]):</span><br><span class="line">        entity[<span class="string">&#x27;bmi&#x27;</span>] = bmiAve</span><br><span class="line">    label_list.append(entity[<span class="string">&#x27;stroke&#x27;</span>])</span><br><span class="line">    <span class="keyword">del</span> entity[<span class="string">&#x27;id&#x27;</span>]</span><br><span class="line">    <span class="keyword">del</span> entity[<span class="string">&#x27;stroke&#x27;</span>]</span><br><span class="line">    <span class="comment"># 替换gender为数字</span></span><br><span class="line">    gender = entity[<span class="string">&quot;gender&quot;</span>]</span><br><span class="line">    <span class="keyword">if</span> dictGender.get(gender) == <span class="literal">None</span>:</span><br><span class="line">        dictGender[gender] = indexGender</span><br><span class="line">        entity[<span class="string">&quot;gender&quot;</span>] = indexGender</span><br><span class="line">        indexGender = indexGender + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        entity[<span class="string">&quot;gender&quot;</span>] = dictGender.get(gender)</span><br><span class="line">    <span class="comment"># 替换marry为数字</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment"># 替换work_type为数字</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment"># 替换residence_type</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment"># 替换smoking_status</span></span><br><span class="line">   ...</span><br><span class="line">    cell = []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> entity:</span><br><span class="line">        cell.append(item)</span><br><span class="line">    data_pre.append(cell)</span><br></pre></td></tr></table></figure>
<p>至此数据预处理部分完成。</p>
<h1 id="决策回归树模型"><a href="#决策回归树模型" class="headerlink" title="决策回归树模型"></a>决策回归树模型</h1><h2 id="决策回归树【手写版】"><a href="#决策回归树【手写版】" class="headerlink" title="决策回归树【手写版】"></a>决策回归树【手写版】</h2><p>【代码详见dec_tree.ipynb文件】</p>
<h3 id="前述"><a href="#前述" class="headerlink" title="前述"></a><strong>前述</strong></h3><p>决策树是一种从无次序、无规则的样本数据集推理出决策树表示形式的分类规则。其中有两种结点：决策节点和叶节点。决策节点表示将数据分为两个分支，叶节点表示一个类。训练的过程就是一个在找最佳分割的过程，使得每个集合的纯度越高。</p>
<p>决策树的度量基本采用的指标有：$Gini $和$Entropy$，具体而言：</p>
<script type="math/tex; mode=display">
Gini=1-\sum_{j=1}^cp_{j}^2</script><script type="math/tex; mode=display">
Entropy=1-\sum_{j=1}^cp_{j}logp_{j}</script><p>此处我用$Entropy$来判断，$Entropy$越小，数据的纯度就越高。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">data_entropy</span>(<span class="params">data</span>):</span><br><span class="line">    n_rows=data.shape[<span class="number">0</span>]</span><br><span class="line">    n_stroke=data[data.stroke==<span class="number">1</span>].shape[<span class="number">0</span>]</span><br><span class="line">    n_healthy=n_rows-n_stroke</span><br><span class="line">    <span class="keyword">return</span> information_entropy([n_stroke, n_healthy])</span><br></pre></td></tr></table></figure>
<p>最开始我先试着用性别对其进行了一个划分，发现以性别划分得到的纯度已经有<code>0.29030858809013044</code>，但是这显然还是不够的。需要函数得到使其信息熵最小的划分,得到正样本和负样本。由于存在数据不是bool的，例如ave_glucose_level等,所以在遍历这些特征的时候，我将<strong>步长设置成1</strong>进行遍历。</p>
<h3 id="获得最优划分"><a href="#获得最优划分" class="headerlink" title="获得最优划分"></a><strong>获得最优划分</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find_best_feature</span>(<span class="params">data, label</span>):</span><br><span class="line">    X=data.drop(label, axis=<span class="number">1</span>)</span><br><span class="line">    min_entropy=<span class="number">1</span></span><br><span class="line">    col_selected=<span class="string">&#x27;&#x27;</span></span><br><span class="line">    data_positive_found=<span class="literal">None</span></span><br><span class="line">    data_negative_found=<span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> X.columns:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">float</span>(<span class="built_in">max</span>(data[col])) &gt; <span class="number">1.0</span>:</span><br><span class="line">            <span class="comment"># 连续数据 或者多分类 步长为1</span></span><br><span class="line">            <span class="keyword">for</span> mid <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,math.ceil(<span class="built_in">max</span>(data[col])),<span class="number">1</span>):</span><br><span class="line">                data_positive = data[data[col]+<span class="number">0.0</span> &lt;= <span class="built_in">float</span>(mid)]</span><br><span class="line">                data_negative = data[data[col]+<span class="number">0.0</span> &gt; <span class="built_in">float</span>(mid)]</span><br><span class="line">                <span class="keyword">if</span> data_positive.shape[<span class="number">0</span>]==<span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> data_negative.shape[<span class="number">0</span>]==<span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                entropy = data_entropy2(data_positive, data_negative)</span><br><span class="line">                <span class="keyword">if</span> entropy &lt; min_entropy:</span><br><span class="line">                    min_entropy=entropy</span><br><span class="line">                    col_selected=col</span><br><span class="line">                    data_positive_found=data_positive</span><br><span class="line">                    data_negative_found=data_negative</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ...</span><br><span class="line">    <span class="keyword">return</span> col_selected, min_entropy, data_positive_found, data_negative_found</span><br></pre></td></tr></table></figure>
<p>最后可以得到每次划分起决定性作用的特征、最小信息熵、正样本和负样本。</p>
<h3 id="构建决策树"><a href="#构建决策树" class="headerlink" title="构建决策树"></a>构建决策树</h3><p>这其实是一个递归下降的过程，当到了最大深度（自己设定）的时候，就返回对应的branch，这也是防止过拟合的一种方式。</p>
<p>每个分支Branch类如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Branch</span>:</span><br><span class="line">    no=<span class="number">0</span> </span><br><span class="line">    depth=<span class="number">1</span> <span class="comment">#深度</span></span><br><span class="line">    column=<span class="string">&#x27;&#x27;</span> <span class="comment"># 划分的feature</span></span><br><span class="line">    entropy=<span class="number">0</span> <span class="comment"># 信息熵</span></span><br><span class="line">    samples=<span class="number">0</span> <span class="comment"># 样本数量</span></span><br><span class="line">    value=[] <span class="comment"># 记录正负样本的个数</span></span><br><span class="line"></span><br><span class="line">    branch_positive=<span class="literal">None</span> <span class="comment">#存储正样本</span></span><br><span class="line">    branch_negative=<span class="literal">None</span> <span class="comment">#存储负样本</span></span><br><span class="line">    no_positive=<span class="number">0</span> <span class="comment"># </span></span><br><span class="line">    no_negative=<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>决策树构建：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">decision_tree_inner</span>(<span class="params">data, label, depth, max_depth</span>):</span><br><span class="line">    <span class="keyword">global</span> number</span><br><span class="line">    branch = Branch()</span><br><span class="line">    branch.no=number</span><br><span class="line">    number=number+<span class="number">1</span></span><br><span class="line">    branch.depth=depth</span><br><span class="line">    branch.samples=data.shape[<span class="number">0</span>]</span><br><span class="line">    n_positive=data[data[label]==<span class="number">1</span>].shape[<span class="number">0</span>]</span><br><span class="line">    branch.value=[branch.samples-n_positive,n_positive]</span><br><span class="line">    branch.entropy=information_entropy(branch.value)</span><br><span class="line">    best_feature = find_best_feature(data, label)</span><br><span class="line">    branch.column=best_feature[<span class="number">0</span>]</span><br><span class="line">    new_entropy=best_feature[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> depth==max_depth <span class="keyword">or</span> branch.column==<span class="string">&#x27;&#x27;</span>:</span><br><span class="line">        branch.no_positive=number</span><br><span class="line">        number=number+<span class="number">1</span></span><br><span class="line">        branch.no_negative=number</span><br><span class="line">        number=number+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> branch</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        data_negative=best_feature[<span class="number">3</span>]</span><br><span class="line">        branch.branch_negative=decision_tree_inner(data_negative, label, depth+<span class="number">1</span>, max_depth=max_depth)</span><br><span class="line">        data_positive=best_feature[<span class="number">2</span>]</span><br><span class="line">        branch.branch_positive=decision_tree_inner(data_positive, label, depth+<span class="number">1</span>, max_depth=max_depth)</span><br><span class="line">        <span class="keyword">return</span> branch</span><br></pre></td></tr></table></figure>
<p>当决策树的深度设置成了10能够达到一定的分类和预测效果。但是精度不高，于是尝试导包做了一遍。</p>
<h2 id="决策回归树【导包版】"><a href="#决策回归树【导包版】" class="headerlink" title="决策回归树【导包版】"></a>决策回归树【导包版】</h2><p>【代码详见tree.ipynb】</p>
<h3 id="划分数据集"><a href="#划分数据集" class="headerlink" title="划分数据集"></a>划分数据集</h3><p>此处的训练集和测试集的比例为：1:4</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x_train, x_test, y_train, y_test = train_test_split(data_pre, label_list, test_size = <span class="number">0.2</span>, random_state = <span class="number">1234</span>)</span><br></pre></td></tr></table></figure>
<h3 id="建模和预测"><a href="#建模和预测" class="headerlink" title="建模和预测"></a>建模和预测</h3><p>为防止过拟合，将树的深度从1遍历到了50，绘制树的深度-preocision的曲线图，发现将书的深度设置成17左右拟合效果最好。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 绘制曲线  查看是否过拟合 找到最优的max_depth</span></span><br><span class="line">depList = []</span><br><span class="line">preList = []</span><br><span class="line"><span class="keyword">for</span> depth <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">50</span>):</span><br><span class="line">    clf = clf = DecisionTreeClassifier(criterion = <span class="string">&#x27;gini&#x27;</span></span><br><span class="line">                            , max_depth = depth</span><br><span class="line">                            , random_state = <span class="number">30</span>)</span><br><span class="line">    clf.fit(x_train, y_train) <span class="comment"># 模型训练</span></span><br><span class="line"></span><br><span class="line">    y_pred = clf.predict(x_test) <span class="comment"># 在测试集上做预测</span></span><br><span class="line">    depList.append(depth)</span><br><span class="line">    preList.append(metrics.precision_score(y_test,y_pred))</span><br><span class="line"></span><br><span class="line">clf = DecisionTreeClassifier(criterion = <span class="string">&#x27;gini&#x27;</span></span><br><span class="line">                            , max_depth = <span class="number">20</span></span><br><span class="line">                            , random_state = <span class="number">30</span>)</span><br><span class="line">clf.fit(x_train, y_train) <span class="comment"># 模型训练</span></span><br></pre></td></tr></table></figure>
<p>如下图所示：</p>
<img data-src="/2022/11/24/%E4%B8%AD%E9%A3%8E%E9%A2%84%E6%B5%8B/image_Z_73fGIEeK.png" class>
<h3 id="决策树的可视化"><a href="#决策树的可视化" class="headerlink" title="决策树的可视化"></a>决策树的可视化</h3><p>【对应附件中的tree01.pdf,tree02.pfd,tree03.pdf】</p>
<p>当深度设置成3时的决策树：</p>
<img data-src="/2022/11/24/%E4%B8%AD%E9%A3%8E%E9%A2%84%E6%B5%8B/image_Vmhcg2osVa.png" class>
<p>树深度为20的决策树：</p>
<img data-src="/2022/11/24/%E4%B8%AD%E9%A3%8E%E9%A2%84%E6%B5%8B/image_LArJd_yWdA.png" class>
<p>此时的分类效果较好，用其预测可以达到百分之九十的精确度。</p>

<h1 id="LSTM神经网络预测模型"><a href="#LSTM神经网络预测模型" class="headerlink" title="LSTM神经网络预测模型"></a>LSTM神经网络预测模型</h1><p>【代码详见lstm.py】</p>
<h3 id="数据过采样"><a href="#数据过采样" class="headerlink" title="数据过采样"></a>数据过采样</h3><p>由于原始数据中为中风的稀疏性，导致训练出来的神经网络效果很不好，因此为了平衡数据，采用SMOTE算法过采样数据，使得负样本和正样本的比例较为均衡。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> imblearn.over_sampling <span class="keyword">import</span> SMOTE</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;过采样之前训练集中正负样本的比例分布:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(y_train[<span class="string">&#x27;stroke&#x27;</span>].value_counts())</span><br><span class="line"><span class="built_in">print</span>(y_train[<span class="string">&#x27;stroke&#x27;</span>].value_counts()/<span class="built_in">len</span>(y_train))</span><br><span class="line">os = SMOTE(random_state=<span class="number">0</span>,k_neighbors=<span class="number">5</span>)</span><br><span class="line">os_data_X,os_data_y=os.fit_resample(x_train, y_train.values.ravel())</span><br><span class="line">os_data_X = pd.DataFrame(data=os_data_X,columns=columns )</span><br><span class="line">os_data_y= pd.DataFrame(data=os_data_y,columns=[<span class="string">&#x27;stroke&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-------------------------------------------&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;过采样之后训练集中正负样本的比例分布:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(os_data_y[<span class="string">&#x27;stroke&#x27;</span>].value_counts())</span><br><span class="line"><span class="built_in">print</span>(os_data_y[<span class="string">&#x27;stroke&#x27;</span>].value_counts()/<span class="built_in">len</span>(os_data_y))</span><br></pre></td></tr></table></figure>
<h3 id="数据归一化"><a href="#数据归一化" class="headerlink" title="数据归一化"></a>数据归一化</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scaler.fit(x_train)</span><br><span class="line">x_train = scaler.transform(x_train)</span><br><span class="line">x_test = scaler.transform(x_test)</span><br></pre></td></tr></table></figure>
<h3 id="重设维度"><a href="#重设维度" class="headerlink" title="重设维度"></a>重设维度</h3><p>由于输入到LSTM神经网络中的维度需要三维，所以对训练数据和测试数据进行reshape，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x_train = np.array(x_train).reshape((-<span class="number">1</span>,<span class="number">1</span>,<span class="number">10</span>))</span><br><span class="line">y_train = np_utils.to_categorical(y_train)</span><br><span class="line">x_test = np.array(x_test).reshape((-<span class="number">1</span>,<span class="number">1</span>,<span class="number">10</span>))</span><br><span class="line">y_test = np_utils.to_categorical(y_test)</span><br></pre></td></tr></table></figure>
<h3 id="LSTM模型的建立和训练"><a href="#LSTM模型的建立和训练" class="headerlink" title="LSTM模型的建立和训练"></a>LSTM模型的建立和训练</h3><p>采用串联的方式拼接各个层，最后采用的激活函数时$softmax$，损失函数采用$croossentropy$。架构上，我采用了四层LSTM，四层全连接层。并且为了防止过拟合，还采用了$checkpoint,earlystop,reducelr$三者拼接作为$callbacks$。</p>
<p>训练的参数如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">batch_size=<span class="number">8</span>,epochs=<span class="number">5</span>,verbose=<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Test score: <span class="number">0.39172635084231117</span></span><br><span class="line">Test accuracy: <span class="number">0.7883211680282352</span></span><br></pre></td></tr></table></figure>
<p>在开发集上的$precision$虽然只有百分之八十不到，但是最后交到评测网站测评时也能达到将近百分之九十，可见过采样对于神经网络的训练能起到很大的作用。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>学习了如何手写决策树以及用导包的方式解决分类预测问题，途中遇到了很多困难，包括环境上的搭建、对数据预处理如何更加合理有效、对特殊数据的处理、如何防止决策树的过拟合，以及对于一开始神经网络训练效果很差、如何处理不平衡数据的分类问题等等，但都在最后得到了解决。</p>
<p>虽然最后效果不是很好，但是确实在这个过程中学习到了很多！继续加油！</p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Decision Tree</tag>
        <tag>Over Sampling</tag>
      </tags>
  </entry>
  <entry>
    <title>同时安装mysql8和mysql5x</title>
    <url>/2022/11/12/%E5%90%8C%E6%97%B6%E5%AE%89%E8%A3%85mysql8%E5%92%8Cmysql5x/</url>
    <content><![CDATA[<h3 id="同时安装MYSQL8和MYSQL5"><a href="#同时安装MYSQL8和MYSQL5" class="headerlink" title="同时安装MYSQL8和MYSQL5"></a>同时安装MYSQL8和MYSQL5</h3><p>本身电脑又mysql8，但是项目需要安装mysql5。但是安装了一个下午，最开始是生成的临时密码登不上服务。后来是新建的服务都启动不了。搞了一个下午，最后通过更改注册表成功了！</p>
<h4 id="mysql无法启动："><a href="#mysql无法启动：" class="headerlink" title="mysql无法启动："></a>mysql无法启动：</h4><p>解决方法：修改新安装的mysql的注册表。由于</p>
<img data-src="/2022/11/12/%E5%90%8C%E6%97%B6%E5%AE%89%E8%A3%85mysql8%E5%92%8Cmysql5x/a78678444eb62a588db3f8cc32dad05_VKcRFtdaqs.png" class>
<img data-src="/2022/11/12/%E5%90%8C%E6%97%B6%E5%AE%89%E8%A3%85mysql8%E5%92%8Cmysql5x/93e79c2f5fc5be74a6c1aa643c72a1b_VCmfksDNiH.png" class>
<img data-src="/2022/11/12/%E5%90%8C%E6%97%B6%E5%AE%89%E8%A3%85mysql8%E5%92%8Cmysql5x/c1ffceb64201f3e07c6cd5b8ce06c60_ocltpcFJrr.png" class>
<p>其注册表如图所示，由于我在对应文件夹bin下<code>mysql -install MYSQL50</code>之后，<strong>MYSQL50服务对应的ImgePath竟然跑到MYSQL8的文件夹里了！！！</strong> 改掉之后就能成功运行了。</p>
<p>这个是MYSQL8的注册表：</p>
<h4 id="临时密码无法登录"><a href="#临时密码无法登录" class="headerlink" title="临时密码无法登录"></a>临时密码无法登录</h4><p>最终解决方法：重新安装一次mysql5… …</p>
<p>我的<code>my.ini</code>文件如下:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[client]</span><br><span class="line"></span><br><span class="line">port=3306</span><br><span class="line"></span><br><span class="line">default-character-set=utf8</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line"></span><br><span class="line"># 设置为自己MYSQL的安装目录</span><br><span class="line"></span><br><span class="line">basedir=D:\\mysql-5.7.40-winx64\\</span><br><span class="line"></span><br><span class="line"># 设置为MYSQL的数据目录</span><br><span class="line"></span><br><span class="line">datadir=D:\\mysql-5.7.40-winx64\\data\\</span><br><span class="line"></span><br><span class="line">port=3306</span><br><span class="line"></span><br><span class="line">character_set_server=utf8</span><br><span class="line"></span><br><span class="line">#跳过安全检查</span><br><span class="line">#skip-grant-tables</span><br></pre></td></tr></table></figure>
<p>如果无需密码就将最后一行放行就行了。</p>
<p>终于搞了一个下午…想当初mysql8一下就下载运行好了…</p>
<img data-src="/2022/11/12/%E5%90%8C%E6%97%B6%E5%AE%89%E8%A3%85mysql8%E5%92%8Cmysql5x/90943598dcf68bcfd8a82437dfbe680_e_hbH03NAR.png" class>
<p>最终只需要用这里的任务管理器，</p>
<p>如图，要用哪个就运行哪个。</p>
]]></content>
  </entry>
  <entry>
    <title>常微分方程和差分方程</title>
    <url>/2022/10/09/%E5%B8%B8%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E5%92%8C%E5%B7%AE%E5%88%86%E6%96%B9%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="第四章-常微分方程和差分方程"><a href="#第四章-常微分方程和差分方程" class="headerlink" title="第四章-常微分方程和差分方程"></a>第四章-常微分方程和差分方程</h1><h2 id="习题1"><a href="#习题1" class="headerlink" title="习题1"></a>习题1</h2><script type="math/tex; mode=display">
2x_{n+2}-x_{n+1}-2x_{n}=0</script><p>并且初值为$x_0=-2;x1=0;$</p>
<p><strong>解法一：</strong></p>
<p>其对应的特征方程为：</p>
<script type="math/tex; mode=display">
2\lambda^2-\lambda-2=0</script><p>求解特征值可以通过一元二次方程的公式求解，也可以通过scipy直接求解。</p>
<p>求解出的特征值有两个，不是重根，分别为$\lambda_1,\lambda_2$，则其通解为</p>
<script type="math/tex; mode=display">
x_n=C_1\lambda_1^n+C_2\lambda_2^n</script><p>其中C1和C2常量由初始条件求出。</p>
<p><strong>解法二：</strong></p>
<p>通过迭代法求出$ x_n  $对应的数值解。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----通过math计算特征方程的根----&quot;</span>)</span><br><span class="line"></span><br><span class="line">a = <span class="number">2</span></span><br><span class="line">b = -<span class="number">1</span></span><br><span class="line">c = -<span class="number">2</span></span><br><span class="line">d=b**<span class="number">2</span>-<span class="number">4</span>*a*c</span><br><span class="line"><span class="keyword">if</span> (d&lt;<span class="number">0</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;无解&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    e = math.sqrt(d)</span><br><span class="line">    x1=((-b+e)/(<span class="number">2</span>*a))<span class="comment">#调用math模块中sqrt开平方函数</span></span><br><span class="line">    x2=((-b-e)/(<span class="number">2</span>*a))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;landa1=&quot;</span>,x1,<span class="string">&quot;\t&quot;</span>,<span class="string">&quot;landa2=&quot;</span>,x2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sympy <span class="keyword">as</span> sp</span><br><span class="line"><span class="comment">#solve函数可以直接求解</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----通过sympy计算特征方程的根和最终结果----&quot;</span>)</span><br><span class="line">sp.var(<span class="string">&#x27;t, c1, c2&#x27;</span>)</span><br><span class="line">t0 = sp.solve(<span class="number">2</span>*t**<span class="number">2</span>-t-<span class="number">2</span>)  <span class="comment">#求解特征方程</span></span><br><span class="line">eq1 = c1 + c2 + <span class="number">2</span></span><br><span class="line">eq2 = c1 * t0[<span class="number">0</span>] + c2 *t0[<span class="number">1</span>]</span><br><span class="line">s = sp.solve([eq1, eq2])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;landa1=&#x27;</span>,t0[<span class="number">0</span>],<span class="string">&#x27;\t&#x27;</span>,<span class="string">&#x27;landa2=&#x27;</span>,t0[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;c1=&#x27;</span>, s[c1]); <span class="built_in">print</span>(<span class="string">&#x27;c2=&#x27;</span>, s[c2])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="number">10</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;x[&quot;</span>,i,<span class="string">&quot;]=&quot;</span>,(s[c1]*<span class="built_in">pow</span>(t0[<span class="number">0</span>],i)+s[c2]*<span class="built_in">pow</span>(t0[<span class="number">1</span>],i)).evalf())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;----通过迭代计算x(n)的数值解-----&#x27;</span>)</span><br><span class="line">prev = -<span class="number">2</span>;x = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">    temp = x</span><br><span class="line">    x = (x + <span class="number">2</span>*prev)/<span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;x[&quot;</span>,i+<span class="number">1</span>,<span class="string">&quot;]=&quot;</span>,x)</span><br><span class="line">    prev = temp</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">----通过math计算特征方程的根----</span><br><span class="line">landa1= 1.2807764064044151    landa2= -0.7807764064044151</span><br><span class="line">----通过sympy计算特征方程的根和最终结果----</span><br><span class="line">landa1= 1/4 - sqrt(17)/4    landa2= 1/4 + sqrt(17)/4</span><br><span class="line">c1= -1 - sqrt(17)/17</span><br><span class="line">c2= -1 + sqrt(17)/17</span><br><span class="line">x[ 2 ]= -2.00000000000000</span><br><span class="line">x[ 3 ]= -1.00000000000000</span><br><span class="line">x[ 4 ]= -2.50000000000000</span><br><span class="line">x[ 5 ]= -2.25000000000000</span><br><span class="line">x[ 6 ]= -3.62500000000000</span><br><span class="line">x[ 7 ]= -4.06250000000000</span><br><span class="line">x[ 8 ]= -5.65625000000000</span><br><span class="line">x[ 9 ]= -6.89062500000000</span><br><span class="line">----通过迭代计算x(n)的数值解-----</span><br><span class="line">x[ 2 ]= -2.0</span><br><span class="line">x[ 3 ]= -1.0</span><br><span class="line">x[ 4 ]= -2.5</span><br><span class="line">x[ 5 ]= -2.25</span><br><span class="line">x[ 6 ]= -3.625</span><br><span class="line">x[ 7 ]= -4.0625</span><br><span class="line">x[ 8 ]= -5.65625</span><br><span class="line">x[ 9 ]= -6.890625</span><br><span class="line">x[ 10 ]= -9.1015625</span><br></pre></td></tr></table></figure>
<p>最终其结果为</p>
<script type="math/tex; mode=display">
x_n=(-1-\frac{\sqrt17}{17})*(\frac{1-\sqrt17}{4})^n+(-1+\frac{\sqrt17}{17})*(\frac{1+\sqrt17}{4})^n</script><p>以上结果可以发现<strong>特征方程</strong>的解法和<strong>迭代解法</strong>的完全一致。</p>
<hr>
<h2 id="习题2"><a href="#习题2" class="headerlink" title="习题2"></a>习题2</h2><p>令$x(t)=[x_1(t),x_2(t)]^T$其中，$x_1(t)=x,x_2(t)=y$；则题目描述可以变成</p>
<script type="math/tex; mode=display">
\frac{dx}{dt}=Ax,x(0)=[1,0]^T,A=\begin{bmatrix}  %中括号
      1&-2\\
      1&2
    \end{bmatrix}</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sympy <span class="keyword">as</span> sp</span><br><span class="line"><span class="keyword">from</span> scipy.integrate <span class="keyword">import</span> odeint</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pylab <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment">#-------------求解析解----------------</span></span><br><span class="line">sp.var(<span class="string">&#x27;t&#x27;</span>)</span><br><span class="line">sp.var(<span class="string">&#x27;x1:3&#x27;</span>, cls=sp.Function) <span class="comment">#定义2个符号函数</span></span><br><span class="line">x = sp.Matrix([x1(t), x2(t)])  <span class="comment">#列向量</span></span><br><span class="line">A = sp.Matrix([[<span class="number">1</span>,-<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>]])</span><br><span class="line">eq = x.diff(t)-A@x</span><br><span class="line">s = sp.dsolve(eq, ics=&#123;x1(<span class="number">0</span>):<span class="number">1</span>, x2(<span class="number">0</span>):<span class="number">0</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;解析解为:&quot;</span>,s);</span><br><span class="line">sx = sp.lambdify(t,s[<span class="number">0</span>].args[<span class="number">1</span>],<span class="string">&#x27;numpy&#x27;</span>)  <span class="comment">#符号函数转匿名函数</span></span><br><span class="line">sy = sp.lambdify(t,s[<span class="number">1</span>].args[<span class="number">1</span>],<span class="string">&#x27;numpy&#x27;</span>)  <span class="comment">#符号函数转匿名函数</span></span><br><span class="line">xx = np.linspace(<span class="number">0</span>,<span class="number">1</span>,<span class="number">50</span>)</span><br><span class="line">plt.rc(<span class="string">&#x27;font&#x27;</span>, family=<span class="string">&#x27;SimHei&#x27;</span>)</span><br><span class="line">plt.rc(<span class="string">&#x27;axes&#x27;</span>, unicode_minus=<span class="literal">False</span>)</span><br><span class="line">plt.rc(<span class="string">&#x27;font&#x27;</span>, size=<span class="number">16</span>)</span><br><span class="line">plt.plot(sx(xx), sy(xx));</span><br><span class="line">plt.xlabel(<span class="string">&#x27;$x$&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;$y$&#x27;</span>,rotation=<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#-------------求数值解--------------</span></span><br><span class="line">dx = <span class="keyword">lambda</span> x, t: [x[<span class="number">0</span>]-<span class="number">2</span>*x[<span class="number">1</span>],x[<span class="number">0</span>]+<span class="number">2</span>*x[<span class="number">1</span>]]</span><br><span class="line">t = np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">50</span>)</span><br><span class="line">s = odeint(dx, [<span class="number">1</span>,<span class="number">0</span>], t)</span><br><span class="line">plt.plot(s[:,<span class="number">0</span>], s[:,<span class="number">1</span>]);</span><br><span class="line">plt.xlabel(<span class="string">&#x27;$x$&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;$y$&#x27;</span>,rotation=<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=============具体结果为==================&quot;</span>)</span><br><span class="line">k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> np.linspace(<span class="number">0</span>,<span class="number">1</span>,<span class="number">50</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;t=&quot;</span>,i,<span class="string">&quot;时\n解析解求得:x(t)=&quot;</span>,sx(i),<span class="string">&quot;y(t)=&quot;</span>,sy(i),<span class="string">&quot;\n数值解求得:x(t)=&quot;</span>,s[:,<span class="number">0</span>][k],<span class="string">&quot;y(t)=&quot;</span>,s[:,<span class="number">1</span>][k])</span><br><span class="line">    k=k+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">plt.legend([<span class="string">&#x27;解析解&#x27;</span>,<span class="string">&#x27;数值解&#x27;</span>])</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">D:\anaconda\envs\pytorch\python.exe &quot;D:/pythonMath/Deffrential Equations/homework2.py&quot;</span><br><span class="line">解析解为: [Eq(x1(t), -sqrt(7)*exp(3*t/2)*sin(sqrt(7)*t/2)/7 + exp(3*t/2)*cos(sqrt(7)*t/2)), Eq(x2(t), 2*sqrt(7)*exp(3*t/2)*sin(sqrt(7)*t/2)/7)]</span><br><span class="line">=============具体结果为==================</span><br><span class="line">t= 0.0 时</span><br><span class="line">解析解求得:x(t)= 1.0 y(t)= 0.0 </span><br><span class="line">数值解求得:x(t)= 1.0 y(t)= 0.0</span><br><span class="line">t= 0.02040816326530612 时</span><br><span class="line">解析解求得:x(t)= 1.020189876647608 y(t)= 0.021040007527822792 </span><br><span class="line">数值解求得:x(t)= 1.0201898879194644 y(t)= 0.021039997406066154</span><br><span class="line">t= 0.04081632653061224 时</span><br><span class="line">解析解求得:x(t)= 1.0399020205807203 y(t)= 0.043372287285719395 </span><br><span class="line">数值解求得:x(t)= 1.0399020271650798 y(t)= 0.043372277714182235</span><br><span class="line">t= 0.061224489795918366 时</span><br><span class="line">解析解求得:x(t)= 1.0590724075998625 y(t)= 0.0670400680081496 </span><br><span class="line">数值解求得:x(t)= 1.0590724185491094 y(t)= 0.0670400571843811</span><br><span class="line">t= 0.08163265306122448 时</span><br><span class="line">解析解求得:x(t)= 1.0776339017990748 y(t)= 0.09208701367564913 </span><br><span class="line">数值解求得:x(t)= 1.0776339148814231 y(t)= 0.09208700197578465</span><br><span class="line">t= 0.1020408163265306 时</span><br><span class="line">解析解求得:x(t)= 1.0955161744257782 y(t)= 0.11855717598964706 </span><br><span class="line">数值解求得:x(t)= 1.0955161877240351 y(t)= 0.11855716371338518</span><br><span class="line">t= 0.12244897959183673 时</span><br><span class="line">解析解求得:x(t)= 1.1126456231022948 y(t)= 0.14649494318063638 </span><br><span class="line">数值解求得:x(t)= 1.112645634783687 y(t)= 0.14649492887241075</span><br><span class="line">t= 0.14285714285714285 时</span><br><span class="line">解析解求得:x(t)= 1.1289452915706144 y(t)= 0.1759449850061317 </span><br><span class="line">数值解求得:x(t)= 1.1289452961242472 y(t)= 0.17594496400477785</span><br><span class="line">t= 0.16326530612244897 时</span><br><span class="line">解析解求得:x(t)= 1.1443347901312997 y(t)= 0.20695219379232827 </span><br><span class="line">数值解求得:x(t)= 1.1443347993093749 y(t)= 0.20695217366966792</span><br><span class="line">t= 0.18367346938775508 时</span><br><span class="line">解析解求得:x(t)= 1.158730216957037 y(t)= 0.23956162137094936 </span><br><span class="line">数值解求得:x(t)= 1.1587302335745913 y(t)= 0.23956160356463208</span><br><span class="line">t= 0.2040816326530612 时</span><br><span class="line">解析解求得:x(t)= 1.1720440804712116 y(t)= 0.27381841176044386 </span><br><span class="line">数值解求得:x(t)= 1.1720440993327175 y(t)= 0.2738183930701502</span><br><span class="line">t= 0.22448979591836732 时</span><br><span class="line">解析解求得:x(t)= 1.184185222992092 y(t)= 0.3097677294384818 </span><br><span class="line">数值解求得:x(t)= 1.1841852438829685 y(t)= 0.3097677096764967</span><br><span class="line">t= 0.24489795918367346 时</span><br><span class="line">解析解求得:x(t)= 1.1950587458536985 y(t)= 0.34745468305060684 </span><br><span class="line">数值解求得:x(t)= 1.1950587687745 y(t)= 0.34745466091234584</span><br><span class="line">t= 0.26530612244897955 时</span><br><span class="line">解析解求得:x(t)= 1.204565936225206 y(t)= 0.3869242443979466 </span><br><span class="line">数值解求得:x(t)= 1.2045659608485249 y(t)= 0.38692422094306006</span><br><span class="line">t= 0.2857142857142857 时</span><br><span class="line">解析解求得:x(t)= 1.2126041958618434 y(t)= 0.4282211625450773 </span><br><span class="line">数值解求得:x(t)= 1.2126042225958342 y(t)= 0.42822113693988506</span><br><span class="line">t= 0.3061224489795918 时</span><br><span class="line">解析解求得:x(t)= 1.219066972031623 y(t)= 0.4713898728874819 </span><br><span class="line">数值解求得:x(t)= 1.2190670009195195 y(t)= 0.4713898455557759</span><br><span class="line">t= 0.32653061224489793 时</span><br><span class="line">解析解求得:x(t)= 1.2238436908739307 y(t)= 0.5164744010165694 </span><br><span class="line">数值解求得:x(t)= 1.223843722308065 y(t)= 0.5164743714132232</span><br><span class="line">t= 0.3469387755102041 时</span><br><span class="line">解析解求得:x(t)= 1.2268196934579962 y(t)= 0.5635182612189238 </span><br><span class="line">数值解求得:x(t)= 1.2268197322675731 y(t)= 0.5635182204027751</span><br><span class="line">t= 0.36734693877551017 时</span><br><span class="line">解析解求得:x(t)= 1.227876174821546 y(t)= 0.6125643494453575 </span><br><span class="line">数值解求得:x(t)= 1.227876226781901 y(t)= 0.6125642872253357</span><br><span class="line">t= 0.3877551020408163 时</span><br><span class="line">解析解求得:x(t)= 1.2268901262825176 y(t)= 0.6636548305844675 </span><br><span class="line">数值解求得:x(t)= 1.2268901860909702 y(t)= 0.6636547583015104</span><br><span class="line">t= 0.4081632653061224 时</span><br><span class="line">解析解求得:x(t)= 1.223734281329584 y(t)= 0.716831019874726 </span><br><span class="line">数值解求得:x(t)= 1.2237343409840549 y(t)= 0.7168309556017836</span><br><span class="line">t= 0.42857142857142855 时</span><br><span class="line">解析解求得:x(t)= 1.2182770654103952 y(t)= 0.7721332582887461 </span><br><span class="line">数值解求得:x(t)= 1.218277123099709 y(t)= 0.7721332067917788</span><br><span class="line">t= 0.44897959183673464 时</span><br><span class="line">解析解求得:x(t)= 1.2103825499498861 y(t)= 0.8296007817231976 </span><br><span class="line">数值解求得:x(t)= 1.210382610633588 y(t)= 0.8296007294438116</span><br><span class="line">t= 0.4693877551020408 时</span><br><span class="line">解析解求得:x(t)= 1.1999104109447043 y(t)= 0.8892715838279832 </span><br><span class="line">数值解求得:x(t)= 1.1999104771822011 y(t)= 0.8892715275180807</span><br><span class="line">t= 0.4897959183673469 时</span><br><span class="line">解析解求得:x(t)= 1.1867158924938193 y(t)= 0.9511822723087026 </span><br><span class="line">数值解求得:x(t)= 1.1867159642423326 y(t)= 0.9511822134138961</span><br><span class="line">t= 0.5102040816326531 时</span><br><span class="line">解析解求得:x(t)= 1.1706497756396121 y(t)= 1.0153679185371705 </span><br><span class="line">数值解求得:x(t)= 1.170649853490215 y(t)= 1.0153678586747292</span><br><span class="line">t= 0.5306122448979591 时</span><br><span class="line">解析解求得:x(t)= 1.1515583529082627 y(t)= 1.0818619003058079 </span><br><span class="line">数值解求得:x(t)= 1.1515584373707495 y(t)= 1.0818618396133117</span><br><span class="line">t= 0.5510204081632653 时</span><br><span class="line">解析解求得:x(t)= 1.1292834089530053 y(t)= 1.150695737563145 </span><br><span class="line">数值解求得:x(t)= 1.129283497834692 y(t)= 1.1506956759804483</span><br><span class="line">t= 0.5714285714285714 时</span><br><span class="line">解析解求得:x(t)= 1.103662207718833 y(t)= 1.2218989209694522 </span><br><span class="line">数值解求得:x(t)= 1.1036623018061529 y(t)= 1.2218988580689951</span><br><span class="line">t= 0.5918367346938775 时</span><br><span class="line">解析解求得:x(t)= 1.0745274865624315 y(t)= 1.2954987331136845 </span><br><span class="line">数值解求得:x(t)= 1.0745275858196601 y(t)= 1.295498669179269</span><br><span class="line">t= 0.6122448979591836 时</span><br><span class="line">解析解求得:x(t)= 1.0417074577765977 y(t)= 1.3715200622355053 </span><br><span class="line">数值解求得:x(t)= 1.0417075636067084 y(t)= 1.3715199970490806</span><br><span class="line">t= 0.6326530612244897 时</span><br><span class="line">解析解求得:x(t)= 1.0050258179840106 y(t)= 1.4499852082991638 </span><br><span class="line">数值解求得:x(t)= 1.005025931367244 y(t)= 1.4499851416835472</span><br><span class="line">t= 0.6530612244897959 时</span><br><span class="line">解析解求得:x(t)= 0.9643017658810773 y(t)= 1.5309136812694661 </span><br><span class="line">数值解求得:x(t)= 0.9643018849986369 y(t)= 1.530913614053574</span><br><span class="line">t= 0.673469387755102 时</span><br><span class="line">解析解求得:x(t)= 0.9193500288285735 y(t)= 1.6143219914440199 </span><br><span class="line">数值解求得:x(t)= 0.9193501552672215 y(t)= 1.614321923290281</span><br><span class="line">t= 0.6938775510204082 时</span><br><span class="line">解析解求得:x(t)= 0.8699808988019734 y(t)= 1.7002234317003653 </span><br><span class="line">数值解求得:x(t)= 0.8699810316861855 y(t)= 1.700223363015467</span><br><span class="line">t= 0.7142857142857142 时</span><br><span class="line">解析解求得:x(t)= 0.8160002782306479 y(t)= 1.7886278515215799 </span><br><span class="line">数值解求得:x(t)= 0.816000418452806 y(t)= 1.7886277822226788</span><br><span class="line">t= 0.7346938775510203 时</span><br><span class="line">解析解求得:x(t)= 0.7572097362715636 y(t)= 1.8795414226694434 </span><br><span class="line">数值解求得:x(t)= 0.7572098846938927 y(t)= 1.8795413527037244</span><br><span class="line">t= 0.7551020408163265 时</span><br><span class="line">解析解求得:x(t)= 0.6934065760796148 y(t)= 1.972966396380324 </span><br><span class="line">数值解求得:x(t)= 0.6934067316386655 y(t)= 1.972966326317898</span><br><span class="line">t= 0.7755102040816326 时</span><br><span class="line">解析解求得:x(t)= 0.6243839136533351 y(t)= 2.0689008519656586 </span><br><span class="line">数值解求得:x(t)= 0.6243840793830152 y(t)= 2.068900781342949</span><br><span class="line">t= 0.7959183673469387 时</span><br><span class="line">解析解求得:x(t)= 0.5499307688513946 y(t)= 2.1673384367061703 </span><br><span class="line">数值解求得:x(t)= 0.5499309446566499 y(t)= 2.167338365754919</span><br><span class="line">t= 0.8163265306122448 时</span><br><span class="line">解析解求得:x(t)= 0.46983216919195314 y(t)= 2.26826809693694 </span><br><span class="line">数值解求得:x(t)= 0.4698323509298826 y(t)= 2.2682680268561617</span><br><span class="line">t= 0.836734693877551 时</span><br><span class="line">解析解求得:x(t)= 0.3838692670636703 y(t)= 2.3716738002290874 </span><br><span class="line">数值解求得:x(t)= 0.3838694532496656 y(t)= 2.3716737318902226</span><br><span class="line">t= 0.8571428571428571 时</span><br><span class="line">解析解求得:x(t)= 0.29181947099377314 y(t)= 2.477534248583156 </span><br><span class="line">数值解求得:x(t)= 0.2918196618123881 y(t)= 2.4775341820833674</span><br><span class="line">t= 0.8775510204081632 时</span><br><span class="line">解析解求得:x(t)= 0.19345659163525064 y(t)= 2.585822582559378 </span><br><span class="line">数值解求得:x(t)= 0.19345678857948362 y(t)= 2.5858225174390705</span><br><span class="line">t= 0.8979591836734693 时</span><br><span class="line">解析解求得:x(t)= 0.08855100315170672 y(t)= 2.6965060762808264 </span><br><span class="line">数值解求得:x(t)= 0.08855120520166707 y(t)= 2.6965060133744223</span><br><span class="line">t= 0.9183673469387754 时</span><br><span class="line">解析解求得:x(t)= -0.02313017930517547 y(t)= 2.8095458232571393 </span><br><span class="line">数值解求得:x(t)= -0.02312997178555415 y(t)= 2.8095457627403286</span><br><span class="line">t= 0.9387755102040816 时</span><br><span class="line">解析解求得:x(t)= -0.14182290531437092 y(t)= 2.924896412988897 </span><br><span class="line">数值解求得:x(t)= -0.1418226909606244 y(t)= 2.9248963546723097</span><br><span class="line">t= 0.9591836734693877 时</span><br><span class="line">解析解求得:x(t)= -0.26776597737325014 y(t)= 3.04250559832613 </span><br><span class="line">数值解求得:x(t)= -0.26776575610194187 y(t)= 3.042505542867204</span><br><span class="line">t= 0.9795918367346939 时</span><br><span class="line">解析解求得:x(t)= -0.40120082081129205 y(t)= 3.1623139535685887 </span><br><span class="line">数值解求得:x(t)= -0.4012005926051197 y(t)= 3.162313901033337</span><br><span class="line">t= 1.0 时</span><br><span class="line">解析解求得:x(t)= -0.5423712346712355 y(t)= 3.2842545233105325 </span><br><span class="line">数值解求得:x(t)= -0.5423709994286192 y(t)= 3.2842544735529384</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因此其<strong>解析解</strong>为：</p>
<script type="math/tex; mode=display">
x(t)=-sqrt(7)*exp(3*t/2)*sin(sqrt(7)*t/2)/7 + exp(3*t/2)*cos(sqrt(7)*t/2)</script><script type="math/tex; mode=display">
y(t)=2*sqrt(7)*exp(3*t/2)*sin(sqrt(7)*t/2)/7)</script><p>解析解和数值解由于十分相似，在画图时不容易分辨，于是我将数值解的步长设置为0.2，解析解的步长为0.02时，其结果为：</p>
<img data-src="/2022/10/09/%E5%B8%B8%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E5%92%8C%E5%B7%AE%E5%88%86%E6%96%B9%E7%A8%8B/image_c916K47SOh.png" class>
<p>当解析解与数值解的步长相等，均为0.02时，结果如下图：</p>
<img data-src="/2022/10/09/%E5%B8%B8%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E5%92%8C%E5%B7%AE%E5%88%86%E6%96%B9%E7%A8%8B/image_h2ZS9n8oNb.png" class>
<p>可见二者几乎完全重合。</p>
]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>外卖系统实现</title>
    <url>/2023/01/01/%E5%A4%96%E5%8D%96%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="外卖系统实现报告"><a href="#外卖系统实现报告" class="headerlink" title="外卖系统实现报告"></a>外卖系统实现报告</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#一实现环境">一、实现环境</a></li>
<li><a href="#二系统功能结构图">二、系统功能结构图</a></li>
<li><a href="#三基本表的定义和完整性约束">三、基本表的定义和完整性约束</a><ul>
<li><a href="#ID设置表Id_max">ID设置表Id_max</a></li>
<li><a href="#商家账户信息表Buser">商家账户信息表Buser</a></li>
<li><a href="#顾客账户信息表Cuser">顾客账户信息表Cuser</a></li>
<li><a href="#菜单管理表Food">菜单管理表Food</a></li>
<li><a href="#订单表Order_shop">订单表Order_shop</a></li>
<li><a href="#订单详情表Order_food">订单详情表Order_food</a></li>
<li><a href="#购物车表Cart">购物车表Cart</a></li>
<li><a href="#操作日志Record">操作日志Record</a></li>
<li><a href="#主外码等完整性约束定义">主外码等完整性约束定义</a><ul>
<li><a href="#Id_max">Id_max</a></li>
<li><a href="#Buser">Buser</a></li>
<li><a href="#Cuser">Cuser</a></li>
<li><a href="#Food">Food</a></li>
<li><a href="#Order_shop">Order_shop</a></li>
<li><a href="#Order_food">Order_food</a></li>
<li><a href="#Cart">Cart</a></li>
<li><a href="#Record">Record</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#四系统的安全性设计及相关权限">四、系统的安全性设计及相关权限</a><ul>
<li><a href="#41安全性说明">4.1安全性说明</a></li>
<li><a href="#42权限外模式设置">4.2权限/外模式设置</a><ul>
<li><a href="#商家">商家</a></li>
<li><a href="#顾客">顾客</a></li>
<li><a href="#查看">查看</a></li>
<li><a href="#修改">修改</a></li>
<li><a href="#管理员">管理员</a></li>
<li><a href="#查看">查看</a></li>
<li><a href="#修改">修改</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#五存储过程触发器和函数的代码说明">五、存储过程、触发器和函数的代码说明</a><ul>
<li><a href="#51存储过程">5.1存储过程</a></li>
<li><a href="#52-Insert触发器">5.2 Insert触发器</a></li>
<li><a href="#53Update触发器">5.3Update触发器</a></li>
<li><a href="#54函数">5.4函数</a></li>
</ul>
</li>
<li><a href="#六实现过程中主要技术和主要模块的论述">六、实现过程中主要技术和主要模块的论述</a><ul>
<li><a href="#61前后端交流的基地址设置">6.1前后端交流的基地址设置</a></li>
<li><a href="#62后端springboot与数据库sqlserver连接">6.2后端springboot与数据库sqlserver连接</a></li>
<li><a href="#63前后端连接">6.3前后端连接</a></li>
<li><a href="#64模块论述">6.4模块论述</a><ul>
<li><a href="#641登录模块">6.4.1登录模块</a></li>
<li><a href="#642菜单模块">6.4.2菜单模块</a></li>
<li><a href="#643订单模块">6.4.3订单模块</a></li>
<li><a href="#644管理模块">6.4.4管理模块</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#七运行实例">七、运行实例</a><ul>
<li><a href="#登陆界面">登陆界面</a></li>
<li><a href="#注册界面">注册界面</a></li>
<li><a href="#商家页面">商家页面</a><ul>
<li><a href="#商家简介">商家简介</a></li>
<li><a href="#销售业绩">销售业绩</a></li>
<li><a href="#商品管理">商品管理</a></li>
<li><a href="#订单管理">订单管理</a></li>
</ul>
</li>
<li><a href="#顾客">顾客</a><ul>
<li><a href="#所有商店">所有商店</a></li>
<li><a href="#购物车">购物车</a></li>
<li><a href="#历史订单">历史订单</a></li>
</ul>
</li>
<li><a href="#管理员">管理员</a></li>
</ul>
</li>
<li><a href="#八源程序说明">八、源程序说明</a><ul>
<li><a href="#81后端基本框架">8.1后端基本框架</a><ul>
<li><a href="#811构建数据库">8.1.1构建数据库</a></li>
<li><a href="#812接受前端端口数据并运行代码">8.1.2接受前端端口数据并运行代码</a></li>
</ul>
</li>
<li><a href="#82前端基本框架">8.2前端基本框架</a></li>
</ul>
</li>
<li><a href="#九贡献分配">九、贡献分配</a></li>
<li><a href="#十收获和体会">十、收获和体会</a></li>
</ul>
<h1 id="一、实现环境"><a href="#一、实现环境" class="headerlink" title="一、实现环境"></a>一、实现环境</h1><p>我们小组实现了外卖系统。这个系统是一个前端后端分离的项目，前端用了Vue+Elemntui框架，后端用Springboot框架实现，数据库用SQLServer实现。包括前期的设计文档，以及系统实现，前后端联调总共历时两周。最终实现效果不错。</p>
<h1 id="二、系统功能结构图"><a href="#二、系统功能结构图" class="headerlink" title="二、系统功能结构图"></a>二、系统功能结构图</h1><img data-src="/2023/01/01/%E5%A4%96%E5%8D%96%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/image_DYkZBHdq9c.png" class>
<p>此系统提供三种身份注册和登录，为商家、顾客、管理员。用户可以在系统上注册商家或者顾客的账号，管理员会对刚注册的账号进行审核。审核通过后用户就能登录刚注册的账号。</p>
<p>对于<strong>商家</strong>，能够实现：</p>
<ol>
<li>更改商家信息</li>
<li>添加、编辑、删除菜品</li>
<li>导出所有菜品为Excel表</li>
<li>条件查询，排序菜品</li>
<li>接受订单，查看订单详细信息</li>
<li>业绩统计分析图</li>
</ol>
<p>对于<strong>顾客</strong>，能够实现：</p>
<ol>
<li>查看商家列表</li>
<li>进入商家查看菜品</li>
<li>选择菜品、数目并加入购物车</li>
<li>结账并添加备注</li>
<li>查看历史订单</li>
</ol>
<p>对于<strong>管理员</strong>，能够实现：</p>
<ol>
<li>审核用户</li>
<li>审核菜品</li>
<li>审核订单</li>
<li>日志记录</li>
</ol>
<h1 id="三、基本表的定义和完整性约束"><a href="#三、基本表的定义和完整性约束" class="headerlink" title="三、基本表的定义和完整性约束"></a>三、基本表的定义和完整性约束</h1><h3 id="ID设置表Id-max"><a href="#ID设置表Id-max" class="headerlink" title="ID设置表Id_max"></a>ID设置表Id_max</h3><div class="table-container">
<table>
<thead>
<tr>
<th>字段名</th>
<th>类型</th>
<th>是否允许为空</th>
<th>是否唯一</th>
<th>字段最大长度</th>
<th>内容限制</th>
</tr>
</thead>
<tbody>
<tr>
<td>索引(temp)</td>
<td>int</td>
<td>否</td>
<td>否</td>
<td>无</td>
<td>0</td>
</tr>
<tr>
<td>订单最大id(Omax)</td>
<td>int</td>
<td>否</td>
<td>否</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>用户最大id(Umax)</td>
<td>int</td>
<td>否</td>
<td>否</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>餐品最大id(Fmax)</td>
<td>int</td>
<td>否</td>
<td>否</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>管理密码(Pwd)</td>
<td>nvarchar</td>
<td>否</td>
<td>否</td>
<td>50</td>
<td>无</td>
</tr>
</tbody>
</table>
</div>
<h3 id="商家账户信息表Buser"><a href="#商家账户信息表Buser" class="headerlink" title="商家账户信息表Buser"></a>商家账户信息表Buser</h3><div class="table-container">
<table>
<thead>
<tr>
<th>字段名</th>
<th>类型</th>
<th>是否允许为空</th>
<th>是否唯一</th>
<th>字段最大长度</th>
<th>内容限制</th>
</tr>
</thead>
<tbody>
<tr>
<td>ID(Bid)</td>
<td>int</td>
<td>否</td>
<td>是</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>电话(Btele)</td>
<td>nvarchar</td>
<td>否</td>
<td>否</td>
<td>20</td>
<td>无</td>
</tr>
<tr>
<td>名字(Bname)</td>
<td>nvarchar</td>
<td>否</td>
<td>否</td>
<td>50</td>
<td>无</td>
</tr>
<tr>
<td>性别(Bsex)</td>
<td>int</td>
<td>是</td>
<td>否</td>
<td>无</td>
<td>0男1女</td>
</tr>
<tr>
<td>密码(Bpwd)</td>
<td>nvarchar</td>
<td>否</td>
<td>否</td>
<td>50</td>
<td>无</td>
</tr>
<tr>
<td>头像(Bimg)</td>
<td>varbinary</td>
<td>是</td>
<td>否</td>
<td>无</td>
<td>max</td>
</tr>
<tr>
<td>地址(Badd)</td>
<td>nvarchar</td>
<td>是</td>
<td>否</td>
<td>50</td>
<td>无</td>
</tr>
<tr>
<td>通过(Bstatus)</td>
<td>nvarchar</td>
<td>否</td>
<td>否</td>
<td>20</td>
<td>两审核状态</td>
</tr>
<tr>
<td>已删除(Bdel)</td>
<td>int</td>
<td>否</td>
<td>否</td>
<td>无</td>
<td>0在1无</td>
</tr>
</tbody>
</table>
</div>
<h3 id="顾客账户信息表Cuser"><a href="#顾客账户信息表Cuser" class="headerlink" title="顾客账户信息表Cuser"></a>顾客账户信息表Cuser</h3><div class="table-container">
<table>
<thead>
<tr>
<th>字段名</th>
<th>类型</th>
<th>是否允许为空</th>
<th>是否唯一</th>
<th>字段最大长度</th>
<th>内容限制</th>
</tr>
</thead>
<tbody>
<tr>
<td>ID(Cid)</td>
<td>int</td>
<td>否</td>
<td>是</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>电话(Ctele)</td>
<td>nvarchar</td>
<td>否</td>
<td>是</td>
<td>20</td>
<td>无</td>
</tr>
<tr>
<td>名字(Cname)</td>
<td>nvarchar</td>
<td>否</td>
<td>是</td>
<td>50</td>
<td>无</td>
</tr>
<tr>
<td>性别(Csex)</td>
<td>int</td>
<td>是</td>
<td>否</td>
<td>无</td>
<td>0男1女</td>
</tr>
<tr>
<td>密码(Cpwd)</td>
<td>nvarchar</td>
<td>否</td>
<td>否</td>
<td>50</td>
<td>无</td>
</tr>
<tr>
<td>头像(Cimg)</td>
<td>varbinary</td>
<td>是</td>
<td>否</td>
<td>无</td>
<td>max</td>
</tr>
<tr>
<td>地址(Cadd)</td>
<td>nvarchar</td>
<td>是</td>
<td>否</td>
<td>50</td>
<td>无</td>
</tr>
<tr>
<td>通过(Cstatus)</td>
<td>nvarchar</td>
<td>否</td>
<td>否</td>
<td>20</td>
<td>两审核状态</td>
</tr>
<tr>
<td>已删除(Cdel)</td>
<td>int</td>
<td>否</td>
<td>否</td>
<td>无</td>
<td>0在1无</td>
</tr>
</tbody>
</table>
</div>
<h3 id="菜单管理表Food"><a href="#菜单管理表Food" class="headerlink" title="菜单管理表Food"></a>菜单管理表Food</h3><div class="table-container">
<table>
<thead>
<tr>
<th>字段名</th>
<th>类型</th>
<th>是否允许为空</th>
<th>是否唯一</th>
<th>字段最大长度</th>
<th>内容限制</th>
</tr>
</thead>
<tbody>
<tr>
<td>ID(Fid)</td>
<td>int</td>
<td>否</td>
<td>是</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>店家(Bid)</td>
<td>int</td>
<td>否</td>
<td>否</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>名称(Fname)</td>
<td>nvarchar</td>
<td>否</td>
<td>否</td>
<td>50</td>
<td>无</td>
</tr>
<tr>
<td>单价(Fprice)</td>
<td>float</td>
<td>否</td>
<td>否</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>图像(Fimg)</td>
<td>varbinary</td>
<td>是</td>
<td>否</td>
<td>无</td>
<td>max</td>
</tr>
<tr>
<td>描述(Fdesc)</td>
<td>nvarchar</td>
<td>是</td>
<td>否</td>
<td>100</td>
<td>无</td>
</tr>
<tr>
<td>库存(Fstock)</td>
<td>int</td>
<td>否</td>
<td>否</td>
<td>无</td>
<td>0-100</td>
</tr>
<tr>
<td>分类(Ftype)</td>
<td>nvarchar</td>
<td>否</td>
<td>否</td>
<td>20</td>
<td>无</td>
</tr>
<tr>
<td>推荐(Frec)</td>
<td>int</td>
<td>否</td>
<td>否</td>
<td>无</td>
<td>0-5</td>
</tr>
<tr>
<td>状态(Fstatus)</td>
<td>nvarchar</td>
<td>否</td>
<td>否</td>
<td>20</td>
<td>‘下架’or‘上架’</td>
</tr>
<tr>
<td>审核(Fpass)</td>
<td>nvarchar</td>
<td>否</td>
<td>否</td>
<td>20</td>
<td>两审核状态</td>
</tr>
<tr>
<td>已删除(Fdel)</td>
<td>int</td>
<td>否</td>
<td>否</td>
<td>无</td>
<td>0在1无</td>
</tr>
</tbody>
</table>
</div>
<h3 id="订单表Order-shop"><a href="#订单表Order-shop" class="headerlink" title="订单表Order_shop"></a>订单表Order_shop</h3><div class="table-container">
<table>
<thead>
<tr>
<th>字段名</th>
<th>类型</th>
<th>是否允许为空</th>
<th>是否唯一</th>
<th>字段最大长度</th>
<th>内容限制</th>
</tr>
</thead>
<tbody>
<tr>
<td>订单编号(Oid)</td>
<td>int</td>
<td>否</td>
<td>是</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>下单时间(Otime)</td>
<td>datatime</td>
<td>否</td>
<td>否</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>顾客电话(Ctele)</td>
<td>nvarchar</td>
<td>否</td>
<td>否</td>
<td>20</td>
<td>无</td>
</tr>
<tr>
<td>店家编号(Bid)</td>
<td>int</td>
<td>否</td>
<td>否</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>顾客编号(Cid)</td>
<td>int</td>
<td>否</td>
<td>否</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>订单价格(Oval)</td>
<td>float</td>
<td>否</td>
<td>否</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>状态(Ostatus)</td>
<td>nvarchar</td>
<td>否</td>
<td>否</td>
<td>20</td>
<td>四接单状态</td>
</tr>
<tr>
<td>备注(Otip)</td>
<td>nvarchar</td>
<td>否</td>
<td>否</td>
<td>100</td>
<td>无</td>
</tr>
<tr>
<td>已删除(Odel)</td>
<td>int</td>
<td>否</td>
<td>否</td>
<td>无</td>
<td>0在1无</td>
</tr>
</tbody>
</table>
</div>
<h3 id="订单详情表Order-food"><a href="#订单详情表Order-food" class="headerlink" title="订单详情表Order_food"></a>订单详情表Order_food</h3><div class="table-container">
<table>
<thead>
<tr>
<th>字段名</th>
<th>类型</th>
<th>是否允许为空</th>
<th>是否唯一</th>
<th>字段最大长度</th>
<th>内容限制</th>
</tr>
</thead>
<tbody>
<tr>
<td>订单编号(Oid)</td>
<td>int</td>
<td>否</td>
<td>否</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>食品id(Fid)</td>
<td>int</td>
<td>否</td>
<td>否</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>食品名(Fname)</td>
<td>nvarchar</td>
<td>否</td>
<td>否</td>
<td>50</td>
<td>无</td>
</tr>
<tr>
<td>食品图(Fimg)</td>
<td>varbinary</td>
<td>是</td>
<td>否</td>
<td>无</td>
<td>max</td>
</tr>
<tr>
<td>食品数量(Fnum)</td>
<td>int</td>
<td>否</td>
<td>否</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>食品总价(Fvalue)</td>
<td>float</td>
<td>否</td>
<td>否</td>
<td>无</td>
<td>无</td>
</tr>
</tbody>
</table>
</div>
<h3 id="购物车表Cart"><a href="#购物车表Cart" class="headerlink" title="购物车表Cart"></a>购物车表Cart</h3><div class="table-container">
<table>
<thead>
<tr>
<th>字段名</th>
<th>类型</th>
<th>是否允许为空</th>
<th>是否唯一</th>
<th>字段最大长度</th>
<th>内容限制</th>
</tr>
</thead>
<tbody>
<tr>
<td>店家(Bid)</td>
<td>int</td>
<td>否</td>
<td>否</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>顾客(Cid)</td>
<td>int</td>
<td>否</td>
<td>否</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>食品id(Fid)</td>
<td>int</td>
<td>否</td>
<td>否</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>食品数量(Fnum)</td>
<td>int</td>
<td>否</td>
<td>否</td>
<td>无</td>
<td>无</td>
</tr>
</tbody>
</table>
</div>
<h3 id="操作日志Record"><a href="#操作日志Record" class="headerlink" title="操作日志Record"></a>操作日志Record</h3><div class="table-container">
<table>
<thead>
<tr>
<th>字段名</th>
<th>类型</th>
<th>是否允许为空</th>
<th>是否唯一</th>
<th>字段最大长度</th>
<th>内容限制</th>
</tr>
</thead>
<tbody>
<tr>
<td>操作类型(Rtype)</td>
<td>int</td>
<td>否</td>
<td>否</td>
<td>无</td>
<td>1-10</td>
</tr>
<tr>
<td>操作时间(Rtime)</td>
<td>datatime</td>
<td>否</td>
<td>否</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>操作用户(Rid)</td>
<td>int</td>
<td>否</td>
<td>否</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>用户类型(Ukind)</td>
<td>int</td>
<td>是</td>
<td>否</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>用户电话(Utele)</td>
<td>nvarchar</td>
<td>是</td>
<td>否</td>
<td>20</td>
<td>无</td>
</tr>
<tr>
<td>用户名字(Uname)</td>
<td>nvarchar</td>
<td>是</td>
<td>否</td>
<td>50</td>
<td>无</td>
</tr>
<tr>
<td>用户性别(Usex)</td>
<td>int</td>
<td>是</td>
<td>否</td>
<td>无</td>
<td>0男1女</td>
</tr>
<tr>
<td>用户密码(Upwd)</td>
<td>nvarchar</td>
<td>是</td>
<td>否</td>
<td>50</td>
<td>无</td>
</tr>
<tr>
<td>用户头像(Uimg)</td>
<td>varbinary</td>
<td>是</td>
<td>否</td>
<td>无</td>
<td>max</td>
</tr>
<tr>
<td>用户地址(Uaddr)</td>
<td>nvarchar</td>
<td>是</td>
<td>否</td>
<td>50</td>
<td>无</td>
</tr>
<tr>
<td>菜品id(Fid)</td>
<td>int</td>
<td>是</td>
<td>否</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>菜品名称(Fname)</td>
<td>nvarchar</td>
<td>是</td>
<td>否</td>
<td>50</td>
<td>无</td>
</tr>
<tr>
<td>菜品单价(Fprice)</td>
<td>float</td>
<td>是</td>
<td>否</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>菜品图片(Fimg)</td>
<td>varbinary</td>
<td>是</td>
<td>否</td>
<td>无</td>
<td>max</td>
</tr>
<tr>
<td>菜品描述(Fdesc)</td>
<td>nvarchar</td>
<td>是</td>
<td>否</td>
<td>100</td>
<td>无</td>
</tr>
<tr>
<td>菜品库存(Fstock)</td>
<td>int</td>
<td>是</td>
<td>否</td>
<td>无</td>
<td>0-100</td>
</tr>
<tr>
<td>菜品分类(Ftype)</td>
<td>nvarchar</td>
<td>是</td>
<td>否</td>
<td>20</td>
<td>无</td>
</tr>
<tr>
<td>菜品推荐(Frec)</td>
<td>int</td>
<td>是</td>
<td>否</td>
<td>无</td>
<td>0-5</td>
</tr>
<tr>
<td>菜品状态(Fstatus)</td>
<td>nvarchar</td>
<td>是</td>
<td>否</td>
<td>20</td>
<td>2上架状态</td>
</tr>
<tr>
<td>订单id(Oid)</td>
<td>int</td>
<td>是</td>
<td>否</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>订单状态(Ostatus)</td>
<td>nvarchar</td>
<td>是</td>
<td>否</td>
<td>20</td>
<td>4接单状态</td>
</tr>
<tr>
<td>店家id(Bid)</td>
<td>int</td>
<td>是</td>
<td>否</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>备注(Otip)</td>
<td>nvarchar</td>
<td>是</td>
<td>否</td>
<td>100</td>
<td>无</td>
</tr>
</tbody>
</table>
</div>
<h2 id="主外码等完整性约束定义"><a href="#主外码等完整性约束定义" class="headerlink" title="主外码等完整性约束定义"></a>主外码等完整性约束定义</h2><h3 id="Id-max"><a href="#Id-max" class="headerlink" title="Id_max"></a>Id_max</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">constraint primary_Id_max_temp primary key (temp))</span><br></pre></td></tr></table></figure>
<h3 id="Buser"><a href="#Buser" class="headerlink" title="Buser"></a>Buser</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">constraint primary_Buser_Bid primary key (Bid)</span><br><span class="line">constraint check_Buser_Bsex check (Bsex = <span class="number">0</span> <span class="keyword">or</span> Bsex = <span class="number">1</span>)</span><br><span class="line">constraint check_Buser_Bstatus check (Bstatus = N<span class="string">&#x27;未审核&#x27;</span> <span class="keyword">or</span> Bstatus = N<span class="string">&#x27;已审核&#x27;</span>)</span><br><span class="line">constraint check_Buser_Bdel check (Bdel = <span class="number">1</span> <span class="keyword">or</span> Bdel = <span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<h3 id="Cuser"><a href="#Cuser" class="headerlink" title="Cuser"></a>Cuser</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">constraint primary_Cuser_Cid primary key (Cid)</span><br><span class="line">constraint check_Cuser_Csex check (Csex = <span class="number">0</span> <span class="keyword">or</span> Csex = <span class="number">1</span>)</span><br><span class="line">constraint check_Cuser_Cstatus check (Cstatus = N<span class="string">&#x27;未审核&#x27;</span> Cstatus = N<span class="string">&#x27;已审核&#x27;</span>)</span><br><span class="line">constraint check_Cuser_Cdel check (Cdel = <span class="number">1</span> <span class="keyword">or</span> Cdel = <span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<h3 id="Food"><a href="#Food" class="headerlink" title="Food"></a>Food</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">constraint primary_Food_Fid primary key (Fid)</span><br><span class="line">constraint foreign_Food_Bid foreign key (Bid) references Buser(Bid)</span><br><span class="line">constraint check_Food_Fstock check (Fstock &gt;= <span class="number">0</span> <span class="keyword">and</span> Fstock &lt;= <span class="number">100</span>)</span><br><span class="line">constraint check_Food_Frec check (Frec &gt;= <span class="number">0</span> <span class="keyword">and</span> Frec &lt;= <span class="number">5</span>)</span><br><span class="line">constraint check_Food_Fstatus check (Fstatus = N<span class="string">&#x27;下架&#x27;</span> <span class="keyword">or</span> Fstatus = N<span class="string">&#x27;上架&#x27;</span>)</span><br><span class="line">constraint check_Food_Fpass check (Fpass = N<span class="string">&#x27;未审核&#x27;</span> <span class="keyword">or</span> Fpass = N<span class="string">&#x27;已审核&#x27;</span>)</span><br><span class="line">constraint check_Food_Fdel check (Fdel = <span class="number">1</span> <span class="keyword">or</span> Fdel = <span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<h3 id="Order-shop"><a href="#Order-shop" class="headerlink" title="Order_shop"></a>Order_shop</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">constraint primary_Oshop_Oid primary key (Oid)</span><br><span class="line">constraint foreign_Oshop_Bid foreign key (Bid) references Buser(Bid)</span><br><span class="line">constraint foreign_Oshop_Cid foreign key (Cid) references Cuser(Cid)</span><br><span class="line">constraint check_Oshop_Ostatus check (Ostatus = N<span class="string">&#x27;未通过&#x27;</span> <span class="keyword">or</span> Ostatus = N<span class="string">&#x27;未接单&#x27;</span> <span class="keyword">or</span> Ostatus = N<span class="string">&#x27;已接单&#x27;</span> <span class="keyword">or</span> Ostatus = N<span class="string">&#x27;已完成&#x27;</span>)</span><br><span class="line">constraint check_Oshop_Odel check (Odel = <span class="number">1</span> <span class="keyword">or</span> Odel = <span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<h3 id="Order-food"><a href="#Order-food" class="headerlink" title="Order_food"></a>Order_food</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">constraint primary_Ofood_Oid_Fid primary key (Oid, Fid)</span><br><span class="line">constraint foreign_Ofood_Oid foreign key (Oid) references Order_shop(Oid)</span><br><span class="line">constraint foreign_Ofood_Fid foreign key (Fid) references Food(Fid))</span><br></pre></td></tr></table></figure>
<h3 id="Cart"><a href="#Cart" class="headerlink" title="Cart"></a>Cart</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">constraint primary_Cart_Bid_Cid_Fid primary key (Bid, Cid, Fid)</span><br><span class="line">constraint foreign_Cart_Bid foreign key (Bid) references Buser(Bid)</span><br><span class="line">constraint foreign_Cart_Cid foreign key (Cid) references Cuser(Cid)</span><br><span class="line">constraint foreign_Cart_Fid foreign key (Fid) references Food(Fid))</span><br></pre></td></tr></table></figure>
<h3 id="Record"><a href="#Record" class="headerlink" title="Record"></a>Record</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">constraint foreign_Record_Bid foreign key (Bid) references Buser(Bid)</span><br><span class="line">constraint foreign_Record_Oid foreign key (Oid) references Order_shop(Oid)</span><br><span class="line">constraint foreign_Record_Fid foreign key (Fid) references Food(Fid)</span><br><span class="line">constraint check_Record_Usex check (Usex = <span class="number">0</span> <span class="keyword">or</span> Usex = <span class="number">1</span>)</span><br><span class="line">constraint check_Record_Fstock check (Fstock &gt;=<span class="number">0</span> <span class="keyword">and</span> Fstock &lt;= <span class="number">100</span>)</span><br><span class="line">constraint check_Record_Frec check (Frec &gt;= <span class="number">0</span> <span class="keyword">and</span> Frec &lt;= <span class="number">5</span>)</span><br><span class="line">constraint check_Record_Fstatus check (Fstatus = N<span class="string">&#x27;上架&#x27;</span> <span class="keyword">or</span> Fstatus = N<span class="string">&#x27;下架&#x27;</span>)</span><br><span class="line">constraint check_Record_Ostatus check (Ostatus = N<span class="string">&#x27;未接单&#x27;</span> <span class="keyword">or</span> <span class="string">&quot; Ostatus = N&#x27;已接单&#x27; or Ostatus = N&#x27;已完成&#x27; or Ostatus = N&#x27;未通过&#x27;))</span></span><br></pre></td></tr></table></figure>
<h1 id="四、系统的安全性设计及相关权限"><a href="#四、系统的安全性设计及相关权限" class="headerlink" title="四、系统的安全性设计及相关权限"></a>四、系统的安全性设计及相关权限</h1><h2 id="4-1安全性说明"><a href="#4-1安全性说明" class="headerlink" title="4.1安全性说明"></a>4.1安全性说明</h2><p>本系统为外卖系统，各角色(商家、顾客、管理员)的权限较为固定，主要通过前后端接口作为权限划分的依据。</p>
<p>即后端根据前端调用的登录接口与进入商家接口来识别并记录当前用户id及其角色与所在商店id，同时通过前后端接口地址即可确认当前角色以及所需操作(双重保险)，在后续的各个接口将当前用户id作为参数参与sql语句，从而在后端代码层面保证每位用户的权限不会“越权”。</p>
<h2 id="4-2权限-外模式设置"><a href="#4-2权限-外模式设置" class="headerlink" title="4.2权限/外模式设置"></a>4.2权限/外模式设置</h2><h4 id="商家"><a href="#商家" class="headerlink" title="商家"></a>商家</h4><p>查看</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">自己店铺的已审核未删除的菜品信息</span><br><span class="line">select Fid, Bid, Fname, Fprice, Fimg, Fdesc, Fstock <span class="keyword">from</span> Food where Fpass = <span class="string">&#x27;已审核&#x27;</span> <span class="keyword">and</span> Fdel = <span class="number">0</span> <span class="keyword">and</span> Bid = 自己</span><br><span class="line">与自己有关的已审核未删除的订单信息</span><br><span class="line">select Order_shop.Oid, Otime, Bid, Cid, Ctele, Oval, Ostatus, Otip, Fid, Fname, Fimg, Fnum, Fvalue <span class="keyword">from</span> Order_shop, Order_food where Ostatus != <span class="string">&#x27;未通过&#x27;</span> <span class="keyword">and</span> Odel = <span class="number">0</span> <span class="keyword">and</span> Bid = 自己 <span class="keyword">and</span> Order_shop.Oid = Order_food.Oid</span><br><span class="line">自己的账号信息</span><br><span class="line">select * <span class="keyword">from</span> Buser where Bid = 自己</span><br></pre></td></tr></table></figure>
<p>修改</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">为自己店铺增加菜品、修改菜品信息</span><br><span class="line">select * <span class="keyword">from</span> Food where Bid = 自己</span><br><span class="line">删除订单、接单</span><br><span class="line">select Ostatus, Odel <span class="keyword">from</span> Order_shop where Ostatus != <span class="string">&#x27;未通过&#x27;</span> <span class="keyword">and</span> Odel = <span class="number">0</span> <span class="keyword">and</span> Bid = 自己</span><br><span class="line">修改密码</span><br><span class="line">select Bpwd <span class="keyword">from</span> Buser where Bid = 自己</span><br></pre></td></tr></table></figure>
<h4 id="顾客"><a href="#顾客" class="headerlink" title="顾客"></a>顾客</h4><h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">已审核未删除的商家部分信息</span><br><span class="line">select Bid, Bname, Btele, Bimg, Baddr <span class="keyword">from</span> Buser where Bstatus = <span class="string">&#x27;已审核&#x27;</span> <span class="keyword">and</span> Bdel = <span class="number">0</span></span><br><span class="line">已审核未删除上架的菜品部分信息</span><br><span class="line">select Fid, Bid, Fname, Fprice, Fimg, Fdesc, Fstock <span class="keyword">from</span> Food where Fstatus = <span class="string">&#x27;上架&#x27;</span> <span class="keyword">and</span> Fpass = <span class="string">&#x27;已审核&#x27;</span> <span class="keyword">and</span> Fdel = <span class="number">0</span></span><br><span class="line">与自己有关的已审核未删除的部分订单信息</span><br><span class="line">select Order_shop.Oid, Otime, Bid, Cid, Oval, Ostatus, Otip, Fid, Fname, Fimg, Fnum, Fvalue <span class="keyword">from</span> Order_shop, Order_food where Ostatus != <span class="string">&#x27;未通过&#x27;</span> <span class="keyword">and</span> Odel = <span class="number">0</span> <span class="keyword">and</span> Cid = 自己 <span class="keyword">and</span> Order_shop.Oid = Order_food.Oid</span><br><span class="line">自己的购物车</span><br><span class="line">select * Cart where Cid = 自己</span><br><span class="line">自己的账号信息</span><br><span class="line">select * <span class="keyword">from</span> Cuser where Cid = 自己</span><br></pre></td></tr></table></figure>
<h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">增减、修改自己的购物车</span><br><span class="line">select * Cart where Cid = 自己</span><br><span class="line">建立提交订单</span><br><span class="line">insert into Order_shop</span><br><span class="line">insert into Order_food</span><br><span class="line">修改密码</span><br><span class="line">select Cpwd <span class="keyword">from</span> Cuser where Cid = 自己</span><br></pre></td></tr></table></figure>
<h4 id="管理员"><a href="#管理员" class="headerlink" title="管理员"></a>管理员</h4><h4 id="查看-1"><a href="#查看-1" class="headerlink" title="查看"></a>查看</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">未删除的商家信息</span><br><span class="line">select * <span class="keyword">from</span> Buser where Bdel = <span class="number">0</span></span><br><span class="line">未删除的顾客信息</span><br><span class="line">select * <span class="keyword">from</span> Cuser where Cdel = <span class="number">0</span></span><br><span class="line">未删除的食品信息</span><br><span class="line">select * <span class="keyword">from</span> Food where Fdel = <span class="number">0</span></span><br><span class="line">未删除的订单信息</span><br><span class="line">select * <span class="keyword">from</span> Order_shop, Order_food where Order_shop.Oid = Order_food.Oid <span class="keyword">and</span> Odel = <span class="number">0</span></span><br><span class="line">日志信息</span><br><span class="line">select * <span class="keyword">from</span> Record</span><br></pre></td></tr></table></figure>
<h4 id="修改-1"><a href="#修改-1" class="headerlink" title="修改"></a>修改</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">审核、删除商家</span><br><span class="line">select Bstatus, Bdel <span class="keyword">from</span> Buser where Bdel = <span class="number">0</span></span><br><span class="line">审核、删除顾客</span><br><span class="line">select Cstatus, Cdel <span class="keyword">from</span> Cuser where Cdel = <span class="number">0</span></span><br><span class="line">审核、删除菜品</span><br><span class="line">select Fpass, Fdel <span class="keyword">from</span> Food where Fdel = <span class="number">0</span></span><br><span class="line">审核、删除订单</span><br><span class="line">select Ostatus, Odel <span class="keyword">from</span> Order_shop where Odel = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h1 id="五、存储过程、触发器和函数的代码说明"><a href="#五、存储过程、触发器和函数的代码说明" class="headerlink" title="五、存储过程、触发器和函数的代码说明"></a>五、存储过程、触发器和函数的代码说明</h1><h2 id="5-1存储过程"><a href="#5-1存储过程" class="headerlink" title="5.1存储过程"></a>5.1存储过程</h2><p>使用经典的insert与update进行数据库更新，所有删除使用del属性进行标记</p>
<p>在java中书写sql代码，使用Connection.prepareStatement.setBlob将二进制图像插入sql语句</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">prest = con.prepareStatement(<span class="string">&quot;insert into Food values (&quot;</span></span><br><span class="line">        + myId + <span class="string">&quot;, &quot;</span> + bid + <span class="string">&quot;, &#x27;&quot;</span> + food + <span class="string">&quot;&#x27;, &quot;</span> + price + <span class="string">&quot;, ?, &#x27;&quot;</span></span><br><span class="line">        + desc + <span class="string">&quot;&#x27;, &quot;</span> + myStock + <span class="string">&quot;, &#x27;&quot;</span> + <span class="built_in">type</span> + <span class="string">&quot;&#x27;, &quot;</span> + rec + <span class="string">&quot;, &#x27;&quot;</span></span><br><span class="line">        + status + <span class="string">&quot;&#x27;, N&#x27;未审核&#x27;, 0)&quot;</span>);</span><br><span class="line">Blob blob = con.createBlob();</span><br><span class="line">blob.setBytes(<span class="number">1</span>, img);</span><br><span class="line">prest.setBlob(<span class="number">1</span>, blob);</span><br><span class="line">prest.executeUpdate();</span><br></pre></td></tr></table></figure>
<p>使用Connection.Statement进行简单sql语句运行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sql = <span class="string">&quot;update Food set Fname = &#x27;&quot;</span> + food + <span class="string">&quot;&#x27;, Fprice = &quot;</span> + price +</span><br><span class="line">        <span class="string">&quot;, Fdesc = &#x27;&quot;</span> + desc + <span class="string">&quot;&#x27;, Fstock = &quot;</span> + myStock + <span class="string">&quot;, Ftype = &#x27;&quot;</span> + <span class="built_in">type</span></span><br><span class="line">        + <span class="string">&quot;&#x27;, Frec = &quot;</span> + rec + <span class="string">&quot;, Fstatus = &#x27;&quot;</span> + status + <span class="string">&quot;&#x27; where Fid = &quot;</span> + <span class="built_in">id</span>;</span><br><span class="line">st.executeUpdate(sql);</span><br></pre></td></tr></table></figure>
<h2 id="5-2-Insert触发器"><a href="#5-2-Insert触发器" class="headerlink" title="5.2 Insert触发器"></a>5.2 Insert触发器</h2><p>防止插入Food表时Fstock超出约束性定义[0,100]的限制造成约束性错误</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">create trigger insertFood on Food instead of insert </span><br><span class="line"><span class="keyword">as</span> begin </span><br><span class="line">  declare @Fid <span class="built_in">int</span>, @Bid <span class="built_in">int</span>, @Fname nvarchar(<span class="number">50</span>), @Fprice <span class="built_in">float</span>, @Fimg varbinary(<span class="built_in">max</span>), @Fdesc nvarchar(<span class="number">100</span>), @Fstock <span class="built_in">int</span>, @Ftype nvarchar(<span class="number">20</span>), @Frec <span class="built_in">int</span>, @Fstatus nvarchar(<span class="number">20</span>), @Fpass nvarchar(<span class="number">20</span>), @Fdel <span class="built_in">int</span>; </span><br><span class="line">  select @Fid = Fid, @Bid = Bid, @Fname = Fname, @Fprice = Fprice, @Fimg = Fimg, @Fdesc = Fdesc, @Fstock = Fstock, @Ftype = Ftype, @Frec = Frec, @Fstatus = Fstatus, @Fpass = Fpass, @Fdel = Fdel <span class="keyword">from</span> inserted; </span><br><span class="line">  <span class="keyword">if</span> @Fstock &lt; <span class="number">0</span> begin </span><br><span class="line">    insert into Food values (@Fid, @Bid, @Fname, @Fprice, @Fimg, @Fdesc, <span class="number">0</span>, @Ftype, @Frec, @Fstatus, @Fpass, @Fdel) </span><br><span class="line">  end <span class="keyword">else</span> begin </span><br><span class="line">    <span class="keyword">if</span> @Fstock &gt; <span class="number">100</span> begin </span><br><span class="line">      insert into Food values (@Fid, @Bid, @Fname, @Fprice, @Fimg, @Fdesc, <span class="number">100</span>, @Ftype, @Frec, @Fstatus, @Fpass, @Fdel) </span><br><span class="line">    end <span class="keyword">else</span> begin </span><br><span class="line">      insert into Food values (@Fid, @Bid, @Fname, @Fprice, @Fimg, @Fdesc @Fstock, @Ftype, @Frec, @Fstatus, @Fpass, @Fdel) </span><br><span class="line">    end </span><br><span class="line">  end </span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h2 id="5-3Update触发器"><a href="#5-3Update触发器" class="headerlink" title="5.3Update触发器"></a>5.3Update触发器</h2><p>防止修改Food表时Fstock超出约束性定义[0,100]的限制造成约束性错误</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">create trigger updateFood on Food instead of update </span><br><span class="line"><span class="keyword">as</span> begin </span><br><span class="line">  <span class="keyword">if</span> update(Fname) begin </span><br><span class="line">    declare @Fid <span class="built_in">int</span>, @Fname nvarchar(<span class="number">50</span>), @Fprice <span class="built_in">float</span>, @Fdesc nvarchar(<span class="number">100</span>), @Fstock <span class="built_in">int</span>, @Ftype nvarchar(<span class="number">20</span>), @Frec <span class="built_in">int</span>, @Fstatus nvarchar(<span class="number">20</span>); </span><br><span class="line">        select @Fname = Fname, @Fprice = Fprice, @Fdesc = Fdesc, @Fstock = Fstock, @Ftype = Ftype, @Frec = Frec, @Fstatus = Fstatus <span class="keyword">from</span> inserted; </span><br><span class="line">        select @Fid = Fid <span class="keyword">from</span> deleted; </span><br><span class="line">        <span class="keyword">if</span> @Fstock &lt; <span class="number">0</span> begin </span><br><span class="line">          update Food <span class="built_in">set</span> Fname = @Fname, Fprice = @Fprice, Fdesc = @Fdesc, Fstock = <span class="number">0</span>, Ftype = @Ftype, Frec = @Frec, Fstatus = @Fstatus where Fid = @Fid </span><br><span class="line">        end <span class="keyword">else</span> begin </span><br><span class="line">          <span class="keyword">if</span> @Fstock &gt; <span class="number">100</span> begin </span><br><span class="line">            update Food <span class="built_in">set</span> Fname = @Fname, Fprice = @Fprice, Fdesc = @Fdesc, Fstock = <span class="number">100</span>, Ftype = @Ftype, Frec = @Frec, Fstatus = @Fstatus where Fid = @Fid </span><br><span class="line">          end <span class="keyword">else</span> begin </span><br><span class="line">                update Food <span class="built_in">set</span> Fname = @Fname, Fprice = @Fprice, Fdesc = @Fdesc, Fstock = @Fstock, Ftype = @Ftype, Frec = @Frec, Fstatus = @Fstatus where Fid = @Fid</span><br><span class="line">          end </span><br><span class="line">        end </span><br><span class="line">    end <span class="keyword">else</span> begin </span><br><span class="line">      <span class="keyword">if</span> update(Fstock) begin </span><br><span class="line">          declare @Fid <span class="built_in">int</span>, @Fstock <span class="built_in">int</span>; </span><br><span class="line">          select @Fstock = Fstock <span class="keyword">from</span> inserted; select @Fid = Fid <span class="keyword">from</span> deleted; </span><br><span class="line">          <span class="keyword">if</span> @Fstock &lt; <span class="number">0</span> begin </span><br><span class="line">            update Food <span class="built_in">set</span> Fstock = <span class="number">0</span> where Fid = @Fid </span><br><span class="line">          end <span class="keyword">else</span> begin </span><br><span class="line">            <span class="keyword">if</span> @Fstock &gt; <span class="number">100</span> begin </span><br><span class="line">              update Food <span class="built_in">set</span> Fstock = <span class="number">100</span> where Fid = @Fid </span><br><span class="line">            end <span class="keyword">else</span> begin </span><br><span class="line">              update Food <span class="built_in">set</span> Fstock = @Fstock where Fid = @Fid </span><br><span class="line">            end </span><br><span class="line">          end </span><br><span class="line">        end </span><br><span class="line">    end </span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h2 id="5-4函数"><a href="#5-4函数" class="headerlink" title="5.4函数"></a>5.4函数</h2><p>实现直接对float型数据进行string与float之间的转换，与前后端接口处价格等float数据使用string类型相适应</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">create function FloatToStr(@num <span class="built_in">float</span>) </span><br><span class="line">returns nvarchar(<span class="number">20</span>) </span><br><span class="line"><span class="keyword">as</span> begin </span><br><span class="line">  <span class="keyword">return</span> convert (nvarchar(<span class="number">20</span>), @num)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">create function StrToFloat(@num nvarchar(<span class="number">20</span>)) </span><br><span class="line">returns <span class="built_in">float</span> </span><br><span class="line"><span class="keyword">as</span> begin </span><br><span class="line">  <span class="keyword">return</span> convert (<span class="built_in">float</span> , @num)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h1 id="六、实现过程中主要技术和主要模块的论述"><a href="#六、实现过程中主要技术和主要模块的论述" class="headerlink" title="六、实现过程中主要技术和主要模块的论述"></a>六、实现过程中主要技术和主要模块的论述</h1><h2 id="6-1前后端交流的基地址设置"><a href="#6-1前后端交流的基地址设置" class="headerlink" title="6.1前后端交流的基地址设置"></a>6.1前后端交流的基地址设置</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line">public <span class="keyword">class</span> <span class="title class_">HomeworkApplication</span> &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication application = new SpringApplication(HomeworkApplication.<span class="keyword">class</span>);</span><br><span class="line">        Map&lt;String, Object&gt; <span class="built_in">map</span> = new HashMap&lt;&gt;();</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="string">&quot;SERVER.PORT&quot;</span>, <span class="string">&quot;8001&quot;</span>);</span><br><span class="line">        application.setDefaultProperties(<span class="built_in">map</span>);</span><br><span class="line">        application.run(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-2后端springboot与数据库sqlserver连接"><a href="#6-2后端springboot与数据库sqlserver连接" class="headerlink" title="6.2后端springboot与数据库sqlserver连接"></a>6.2后端springboot与数据库sqlserver连接</h2><p>使用idea新建springboot项目，用自带的添加数据源进行初步连接</p>
<img data-src="/2023/01/01/%E5%A4%96%E5%8D%96%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/image_R7ukr73PMz.png" class>
<p>接着使用代码进行数据库连接与sql语句编写运行，需要注意设置trustServerCertificate，否则可能连接失败</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">private final String dbUrl =<span class="string">&quot;jdbc:sqlserver://localhost:1433;database=homework;trustServerCertificate=true&quot;</span>;</span><br><span class="line">private final String userName = <span class="string">&quot;sa&quot;</span>;</span><br><span class="line">private final String userPwd = <span class="string">&quot;密码&quot;</span>;</span><br><span class="line">private Connection con;</span><br><span class="line">private Statement st;</span><br><span class="line">private ResultSet rs;</span><br><span class="line">private String sql;</span><br><span class="line">con = DriverManager.getConnection(dbUrl, userName, userPwd);</span><br><span class="line">st = con.createStatement();</span><br><span class="line">sql = <span class="string">&quot;select * from Food where Bid = &quot;</span> + bid + <span class="string">&quot; and Fname = &#x27;&quot;</span> + food + <span class="string">&quot;&#x27; and Fdel = 0&quot;</span>;</span><br><span class="line">rs = st.executeQuery(sql);</span><br></pre></td></tr></table></figure>
<p>对于查询得到的ResultSet表格，可以迭代遍历(rs,next)取用(rs.getInt())</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(rs.<span class="built_in">next</span>()) &#123;</span><br><span class="line">  <span class="keyword">return</span> rs.getBytes(<span class="string">&quot;Fimg&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是插入varbinary二进制图片数据时，无法将byte[]数据直接转化为string并插入sql语句，需要作为额外参数插入语句</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">PreparedStatement prest;</span><br><span class="line">prest = con.prepareStatement(<span class="string">&quot;insert into Food values (&quot;</span></span><br><span class="line">      + myId + <span class="string">&quot;, &quot;</span> + bid + <span class="string">&quot;, &#x27;&quot;</span> + food + <span class="string">&quot;&#x27;, &quot;</span> + price + <span class="string">&quot;, ?, &#x27;&quot;</span></span><br><span class="line">      + desc + <span class="string">&quot;&#x27;, &quot;</span> + myStock + <span class="string">&quot;, &#x27;&quot;</span> + <span class="built_in">type</span> + <span class="string">&quot;&#x27;, &quot;</span> + rec + <span class="string">&quot;, &#x27;&quot;</span></span><br><span class="line">      + status + <span class="string">&quot;&#x27;, N&#x27;未审核&#x27;, 0)&quot;</span>);</span><br><span class="line">Blob blob = con.createBlob();</span><br><span class="line">blob.setBytes(<span class="number">1</span>, img);</span><br><span class="line">prest.setBlob(<span class="number">1</span>, blob);</span><br><span class="line">prest.executeUpdate();</span><br></pre></td></tr></table></figure>
<h2 id="6-3前后端连接"><a href="#6-3前后端连接" class="headerlink" title="6.3前后端连接"></a>6.3前后端连接</h2><p>使用@RestController定义控制类作为总的接受前端接口的类</p>
<p>使用@CrossOrigin避免可能出现的跨域报错</p>
<p>@PostMapping(“/initial/register”)或者Get/Put/Delete接受相应的接口请求，当接收到前端请求时即会调用想用的函数，如下当接收到/initial/register的Post请求时会调用register函数，@RequestBody接收前端传过来的json参数，为了代码、理解方便而令前端使用字典格式，在register函数内部可以对数据库进行操作获取数据，@ResponseBody将后端返回的数据自适应为前端的数据格式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@CrossOrigin</span></span><br><span class="line">public <span class="keyword">class</span> <span class="title class_">Controller</span> &#123;</span><br><span class="line"><span class="meta">    @PostMapping(<span class="params"><span class="string">&quot;/initial/register&quot;</span></span>)</span></span><br><span class="line"><span class="meta">    @ResponseBody</span></span><br><span class="line">    public Map&lt;String, Object&gt; register(@RequestBody Map&lt;String,Object&gt; <span class="built_in">map</span>) &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-4模块论述"><a href="#6-4模块论述" class="headerlink" title="6.4模块论述"></a>6.4模块论述</h2><p>从逻辑上基本可以分为登录模块、菜单模块、订单模块、管理模块</p>
<h4 id="6-4-1登录模块"><a href="#6-4-1登录模块" class="headerlink" title="6.4.1登录模块"></a>6.4.1登录模块</h4><p>注册时，通过前端传到后端的账号类别、手机号、密码等信息与账户信息表中的select数据进行对比，若存在重复名称或重复手机号则注册失败，注册成功后等待管理员审核后即可登录；</p>
<p>登录时若找到匹配的数据，则登录成功，同时更新当前用户信息，记录当前使用者的信息，以确认具体角色权限，同时若使用者为用户，则可以通过进入商店接口确认用户当前所浏览的是那个商店界面，从而进行针对商店的用户操作(例如购物车)；</p>
<p>修改密码和登录同理，若匹配则运行update指令更新密码；</p>
<p>用户ID根据Id_max表格中的Umax记录作为当前历史最大的用户数，并将Umax加一，可以理解为ID每次递增加一，顾客与商家共用Umax。</p>
<h4 id="6-4-2菜单模块"><a href="#6-4-2菜单模块" class="headerlink" title="6.4.2菜单模块"></a>6.4.2菜单模块</h4><p>商家添加新菜品时，检测数据库中是否存在未删除的同名菜品，若存在，则添加失败，添加成功后等待管理员审核；</p>
<p>修改菜品信息时，同样检测同名菜品判断是否修改失败；</p>
<p>菜品ID与用户ID同理。</p>
<h4 id="6-4-3订单模块"><a href="#6-4-3订单模块" class="headerlink" title="6.4.3订单模块"></a>6.4.3订单模块</h4><p>主要通过顾客向购物车添加菜品，若菜品库存不足添加量，则将已有库存先加入购物车后再返回库存不足的提醒，在添加购物车时就同步减少相应库存；</p>
<p>顾客提交购物车后，即将当前购物车清空，并构建菜单，等待管理员审核，管理员审核后商家即可接单；</p>
<p>查询订单可可以通过select where限定ID，时间，商家，顾客等多个属性进行筛选；</p>
<p>订单ID与用户ID同理。</p>
<h4 id="6-4-4管理模块"><a href="#6-4-4管理模块" class="headerlink" title="6.4.4管理模块"></a>6.4.4管理模块</h4><p>管理员由于具有唯一性，因不设定用户名，仅考虑登录密码是否正确；</p>
<p>管理员不可注册，密码通过后端直接在数据库中设置；</p>
<p>通过select各个对象的表格的信息传回前端，根据前段审核或删除指令更新对象的审核状态与删除状态这两个参数；</p>
<p>对于已经删除的对象，永远无法被任何人再次读取，通过选择筛选del = 0来保证这一点；</p>
<p>每一次改变数据库的操作都会被记录在日志中，日志中保存了操作时间、操作类别、操作具体数据。</p>
<h1 id="七、运行实例"><a href="#七、运行实例" class="headerlink" title="七、运行实例"></a>七、运行实例</h1><h2 id="登陆界面"><a href="#登陆界面" class="headerlink" title="登陆界面"></a>登陆界面</h2><img data-src="/2023/01/01/%E5%A4%96%E5%8D%96%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/image_feMBroIJYh.png" class>
<p>用户经过注册，<strong>等待管理员审核通过</strong>后才能登录。登录只需要输入注册时的用户名和密码，然后选择对应的类型即可。</p>
<h2 id="注册界面"><a href="#注册界面" class="headerlink" title="注册界面"></a>注册界面</h2><img data-src="/2023/01/01/%E5%A4%96%E5%8D%96%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/image_XC043I7IFZ.png" class>
<p>注册界面需要输入用户名，联系电话，注册类型，性别，密码以及地址。</p>
<p>其中用户名和联系电话都会进行<strong>约束性条件检查</strong>，要求手机号第一位为1，以及总位数为11位，密码为6-15个字符之间等等。</p>
<p>同时我们采用了<strong>百度地图</strong>的获取当前位置的方式能够获取到当前所在的省市以及经纬度。</p>
<img data-src="/2023/01/01/%E5%A4%96%E5%8D%96%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/image_DScGW5T61l.png" class>
<p>当前注册一个用户名为ioio，密码为ioioio的商家账号。</p>
<p>现在登录管理账号审核，可以发现当前帐号已经出现在所有用户中，并且是未审核的状态，将其通过审核之后这个账号就能正常登录。</p>
<img data-src="/2023/01/01/%E5%A4%96%E5%8D%96%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/image_hreD9t4nAD.png" class>
<h2 id="商家页面"><a href="#商家页面" class="headerlink" title="商家页面"></a>商家页面</h2><h4 id="商家简介"><a href="#商家简介" class="headerlink" title="商家简介"></a>商家简介</h4><p>登录已创建的商家之后,可以看到商家中心的简介：</p>
<img data-src="/2023/01/01/%E5%A4%96%E5%8D%96%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/image_D3Iov8egq5.png" class>
<p>点击圆形图片可以更换头像，头像下面显示了当前商家的名称和地址，以及右侧有一个当前商家的评分、店铺分类、营业时间等，可以点击编辑按钮对其进行编辑：</p>
<img data-src="/2023/01/01/%E5%A4%96%E5%8D%96%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/image_Qf6RKf4hwF.png" class>
<p>同时点击“账户信息”，会显示当前账户的用户名，注册时的手机号以及地址等信息，同样可以进行编辑：</p>
<img data-src="/2023/01/01/%E5%A4%96%E5%8D%96%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/image_WYl4Jz-Bb3.png" class>
<h4 id="销售业绩"><a href="#销售业绩" class="headerlink" title="销售业绩"></a>销售业绩</h4><p>销售业绩部分可以看到当前商家的客户总数、订单总数、销售额以及商品总数，以及对于四者对应过去的一周业绩的曲线图：</p>
<img data-src="/2023/01/01/%E5%A4%96%E5%8D%96%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/image_tpNgfa3VX3.png" class>
<h4 id="商品管理"><a href="#商品管理" class="headerlink" title="商品管理"></a>商品管理</h4><p>可以看到所有的商品列表，能够实现<strong>图片显示</strong>，并且可以选择不同的条数进行翻页。</p>
<img data-src="/2023/01/01/%E5%A4%96%E5%8D%96%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/image_xwmDc4hkpi.png" class>
<p>将左侧的选择改为菜品名，在输入框中填写牛肉面，再点击搜索，可以根据输入框进行条件查询：</p>
<p>注：这是通过后端接口，即数据库的SELECT语句实现的，而非通过前端过滤。</p>
<p>在查询菜品列表的时候有<strong>函数作用</strong>使得将float类型的价格转换为nvarchar从而与接口类型匹配。</p>
<img data-src="/2023/01/01/%E5%A4%96%E5%8D%96%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/image_tqRbwogFeW.png" class>
<p>点击“添加菜品”按钮，可以实现菜品的添加，可以设置其价格，库存，推荐指数，图片以及描述等信息：</p>
<img data-src="/2023/01/01/%E5%A4%96%E5%8D%96%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/image_gPg3Glixm6.png" class>
<p>添加菜品之后经过管理员审核之后菜品就会显示在菜品列表。</p>
<p>点击每一行的“编辑”按钮之后，就能实现对该菜品的编辑，在编辑的过程中，在每次增加或者修改菜品的时候后端有<strong>触发器</strong>保证stock库存始终处于[0,100]之间。</p>
<p>如果将该菜品<strong>更改为下架</strong>，那么顾客端口就不会显示该商家的该商品：</p>
<img data-src="/2023/01/01/%E5%A4%96%E5%8D%96%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/image_36qr7Zm7IV.png" class>
<p>点击“删除”按钮，可以实现对菜品的删除。</p>
<p>点击“筛选”按钮，可以实现对菜品的<strong>多条件筛选</strong>，即输入菜品价格上下限，库存的上下限以及类型：</p>
<img data-src="/2023/01/01/%E5%A4%96%E5%8D%96%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/image_oBwZVVe9WV.png" class>
<p>点击“导出Excel表”还可以将当前商家的所有菜品导出为Excel表：</p>
<img data-src="/2023/01/01/%E5%A4%96%E5%8D%96%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/image_j4Dmlgn7ng.png" class>
<h4 id="订单管理"><a href="#订单管理" class="headerlink" title="订单管理"></a>订单管理</h4><p>订单管理页面可以实现对订单编号/订单人姓名的<strong>条件查询</strong>，同样也可以<strong>导出为Excel表</strong>：</p>
<img data-src="/2023/01/01/%E5%A4%96%E5%8D%96%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/image_5Ymp3XaAou.png" class>
<p>对于每一个订单，都会在左栏显示下单的时间，下单人姓名、下单金额以及备注。</p>
<p><strong>点击任意一行</strong>，就会在右边的“订单详情”板块显示当前订单的状态，订单的编号，联系电话，下单时间，顾客昵称，下单金额以及详细的菜品，以及备注：</p>
<img data-src="/2023/01/01/%E5%A4%96%E5%8D%96%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/image_CYeK17IrAU.png" class>
<p>订单最初始的状态是未通过的状态，此时等待管理员审核通过之后，就会出现在商家的订单列表里。商家点击“未接单”的红色按钮之后，就会显示“已接单”的状态，同时该信息也会同步给顾客，顾客收到订单之后点击“已完成”之后，商家这边的“订单详情”就会显示“已完成”的状态。</p>
<p>还可以看到当前商家的统计详情，用的是echarts组件，会标记出过去12个月的每个价格区间内的销售额以及月平均销售额，方便商家对各个价位的菜品进行评估：</p>
<img data-src="/2023/01/01/%E5%A4%96%E5%8D%96%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/image_34osjdhTk1.png" class>
<h2 id="顾客-1"><a href="#顾客-1" class="headerlink" title="顾客"></a>顾客</h2><h4 id="所有商店"><a href="#所有商店" class="headerlink" title="所有商店"></a>所有商店</h4><p>顾客可以<strong>查看商家列表</strong>，了解商家名称，位置，联系方式等：</p>
<img data-src="/2023/01/01/%E5%A4%96%E5%8D%96%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/image_76I0qCPHq8.png" class>
<p>点击操作按钮，可以进入到商家的<strong>菜品页面</strong>：</p>
<img data-src="/2023/01/01/%E5%A4%96%E5%8D%96%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/image_XlmhoY5QVk.png" class>
<p>在菜品页面可以查看<strong>菜品信息</strong>（名称、价格、图片等），通过右侧数量选择输入或点击上下箭头调整数量，</p>
<p>在最下方点击加入购物车按钮可以将选择的菜品<strong>加入购物车</strong>：</p>
<img data-src="/2023/01/01/%E5%A4%96%E5%8D%96%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/image_Mx8Qdr3cOh.png" class>
<h4 id="购物车"><a href="#购物车" class="headerlink" title="购物车"></a>购物车</h4><p>点击购物车选项可以查看<strong>已经添加在购物车中</strong>的菜品：</p>
<img data-src="/2023/01/01/%E5%A4%96%E5%8D%96%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/image_drfNo6b3Cs.png" class>
<p>之后可以选择<strong>删除菜品、添加备注、结账</strong>：</p>
<img data-src="/2023/01/01/%E5%A4%96%E5%8D%96%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/image_XPjtSwEB5f.png" class>
<h4 id="历史订单"><a href="#历史订单" class="headerlink" title="历史订单"></a>历史订单</h4><p>进入历史订单页面可以看到过往的<strong>所有订单</strong>，并可以根据<strong>时间排序</strong>：</p>
<img data-src="/2023/01/01/%E5%A4%96%E5%8D%96%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/image_m-46vFMe_0.png" class>
<h2 id="管理员-1"><a href="#管理员-1" class="headerlink" title="管理员"></a>管理员</h2><p>管理员的主要职责有对<strong>用户的审核，删除</strong>，同时可以在输入框中进行<strong>全局搜索</strong>：</p>
<img data-src="/2023/01/01/%E5%A4%96%E5%8D%96%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/image_1UWB6n9GGR.png" class>
<p>对所有<strong>菜品的审核，删除</strong>，同时可以在输入框中进行<strong>全局搜索</strong>：</p>
<img data-src="/2023/01/01/%E5%A4%96%E5%8D%96%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/image_o0Nr7A29Ja.png" class>
<p>全局搜索“牛肉面”之后的结果如下图所示：</p>
<img data-src="/2023/01/01/%E5%A4%96%E5%8D%96%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/image_rj0GcAmZ5n.png" class>
<p>对<strong>订单的审核，删除，</strong> 同时也可以进行全局搜索：</p>
<img data-src="/2023/01/01/%E5%A4%96%E5%8D%96%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/image_pWwOv4cODy.png" class>
<p>并且可以查看每个订单的具体信息：</p>
<img data-src="/2023/01/01/%E5%A4%96%E5%8D%96%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/image_Z2lsugolaP.png" class>
<p>也可以进行<strong>日志查看，</strong>日志包括所有的操作、时间以及对应操作的ID（商家和顾客的ID不能重复）<strong>：</strong></p>
<img data-src="/2023/01/01/%E5%A4%96%E5%8D%96%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/image_muzWCSe2Tq.png" class>
<h1 id="八、源程序说明"><a href="#八、源程序说明" class="headerlink" title="八、源程序说明"></a>八、源程序说明</h1><h2 id="8-1后端基本框架"><a href="#8-1后端基本框架" class="headerlink" title="8.1后端基本框架"></a>8.1后端基本框架</h2><img data-src="/2023/01/01/%E5%A4%96%E5%8D%96%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/image_-odpR2SBSJ.png" class>
<h3 id="8-1-1构建数据库"><a href="#8-1-1构建数据库" class="headerlink" title="8.1.1构建数据库"></a>8.1.1构建数据库</h3><p>通过BuildDatabase检查是否存在总数据库与所需表姑，若不存在则构建总数据库与表格</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">String sql = <span class="string">&quot;select name from sys.databases where name = &#x27;homework&#x27;&quot;</span>;</span><br><span class="line">rs = st.executeQuery(sql);</span><br><span class="line"><span class="built_in">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (rs.<span class="built_in">next</span>()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (rs.getString(<span class="string">&quot;name&quot;</span>).equals(<span class="string">&quot;homework&quot;</span>)) &#123;</span><br><span class="line">    flag = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">  sql = <span class="string">&quot;create database homework&quot;</span>;</span><br><span class="line">  st.executeUpdate(sql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-1-2接受前端端口数据并运行代码"><a href="#8-1-2接受前端端口数据并运行代码" class="headerlink" title="8.1.2接受前端端口数据并运行代码"></a>8.1.2接受前端端口数据并运行代码</h3><p>Controller类作为总的接口类，接受各个接口，并将不同接口的代码分别封装在Admin/Business/Customer/Initial/Log的类方法中，在Controller直接调用类方法并返回即可</p>
<img data-src="/2023/01/01/%E5%A4%96%E5%8D%96%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/image_xALDk4-Fbz.png" class>
<h2 id="8-2前端基本框架"><a href="#8-2前端基本框架" class="headerlink" title="8.2前端基本框架"></a>8.2前端基本框架</h2><p>采用了Vue前端框架和Element Ui框架。</p>
<img data-src="/2023/01/01/%E5%A4%96%E5%8D%96%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/image_xYAip0KcuN.png" class>
<p>其中也用了eCharts等组件。teacher中记录的是商家页面。student中记录的是顾客页面。admin中记录的是管理员页面。</p>
<h1 id="九、收获和体会"><a href="#九、收获和体会" class="headerlink" title="九、收获和体会"></a>九、收获和体会</h1><p>实现的系统基本实现了外卖系统应该能够实现的任务，例如点餐，下单等基本功能。系统具有一定的规模，且在开发过程中遇到了很多困难，从最初的如何选题，如何设计系统，到之后的前后端语言和架构的学习，到最后的前后端联调部分，组员的每一位同学都积极参与和互相协调，最终解决了这些问题。在这次的系统开发过程中，我们学习到了很多最初没有接触过的知识，通过学习应用到实践过程中去，并将上课时学习到的SQL语句以及系统架构等知识运用到其中。</p>
<p><strong>附件：数据库前后端API.pdf</strong></p>
]]></content>
      <tags>
        <tag>VUE</tag>
        <tag>JS</tag>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>杰对编程</title>
    <url>/2023/03/16/%E6%9D%B0%E5%AF%B9%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<div class="table-container">
<table>
<thead>
<tr>
<th>项目</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>这个作业属于哪个课程</td>
<td><a href="https://bbs.csdn.net/forums/buaa-ase2023">北航软工</a></td>
</tr>
<tr>
<td>这个作业的要求在哪里</td>
<td><a href="https://bbs.csdn.net/topics/613883108">最长英语单词链</a></td>
</tr>
<tr>
<td>我在这个课程的目标是</td>
<td>学会团队协作</td>
</tr>
<tr>
<td>这个作业在哪个具体方面帮助我实现目标</td>
<td>组队项目，使用vs</td>
</tr>
</tbody>
</table>
</div>
<h1 id="0-项目信息"><a href="#0-项目信息" class="headerlink" title="0  项目信息"></a>0  项目信息</h1><div class="table-container">
<table>
<thead>
<tr>
<th>教学班级</th>
<th>项目地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>周四下午</td>
<td><a href="https://github.com/warriors2001/Pair-Programing">pair-program</a></td>
</tr>
</tbody>
</table>
</div>
<hr>
<p><strong>预计耗时</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">psp2.1</th>
<th style="text-align:center"></th>
<th style="text-align:center">预估耗时(min)</th>
<th style="text-align:center">实际耗时(min)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>Planning</strong></td>
<td style="text-align:center"><strong>计划</strong></td>
<td style="text-align:center">60</td>
<td style="text-align:center">45</td>
</tr>
<tr>
<td style="text-align:center">. Estimate</td>
<td style="text-align:center">· 估计这个任务需要多少时间</td>
<td style="text-align:center">3130</td>
<td style="text-align:center">3450</td>
</tr>
<tr>
<td style="text-align:center"><strong>Development</strong></td>
<td style="text-align:center"><strong>开发</strong></td>
<td style="text-align:center">700</td>
<td style="text-align:center">900</td>
</tr>
<tr>
<td style="text-align:center">. Analysis</td>
<td style="text-align:center">· 需求分析 (包括学习新技术)</td>
<td style="text-align:center">480</td>
<td style="text-align:center">500</td>
</tr>
<tr>
<td style="text-align:center">. Design Spec</td>
<td style="text-align:center">· 生成设计文档</td>
<td style="text-align:center">120</td>
<td style="text-align:center">150</td>
</tr>
<tr>
<td style="text-align:center">.Design Review</td>
<td style="text-align:center">· 设计复审 (和同事审核设计文档)</td>
<td style="text-align:center">30</td>
<td style="text-align:center">20</td>
</tr>
<tr>
<td style="text-align:center">.Coding Standard</td>
<td style="text-align:center">· 代码规范 (为目前的开发制定合适的规范</td>
<td style="text-align:center">03</td>
<td style="text-align:center">20</td>
</tr>
<tr>
<td style="text-align:center">.Design</td>
<td style="text-align:center">· 具体设计</td>
<td style="text-align:center">60</td>
<td style="text-align:center">50</td>
</tr>
<tr>
<td style="text-align:center">.Coding</td>
<td style="text-align:center">· 具体编码</td>
<td style="text-align:center">1000</td>
<td style="text-align:center">800</td>
</tr>
<tr>
<td style="text-align:center">.Code Review</td>
<td style="text-align:center">· 代码复审</td>
<td style="text-align:center">60</td>
<td style="text-align:center">90</td>
</tr>
<tr>
<td style="text-align:center">.Test</td>
<td style="text-align:center">· 测试（自我测试，修改代码，提交修改)</td>
<td style="text-align:center">300</td>
<td style="text-align:center">450</td>
</tr>
<tr>
<td style="text-align:center"><strong>Reporting</strong></td>
<td style="text-align:center"><strong>报告</strong></td>
<td style="text-align:center">200</td>
<td style="text-align:center">300</td>
</tr>
<tr>
<td style="text-align:center">.Test Report</td>
<td style="text-align:center">· 测试报告</td>
<td style="text-align:center">60</td>
<td style="text-align:center">30</td>
</tr>
<tr>
<td style="text-align:center">.Size Measurement</td>
<td style="text-align:center">· 计算工作量</td>
<td style="text-align:center">60</td>
<td style="text-align:center">30</td>
</tr>
<tr>
<td style="text-align:center">.Postmortem &amp; Process Improvement Plan</td>
<td style="text-align:center">· 事后总结, 并提出过程改进计划</td>
<td style="text-align:center">30</td>
<td style="text-align:center">100</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">合计</td>
<td style="text-align:center">3190</td>
<td style="text-align:center">3495</td>
</tr>
</tbody>
</table>
</div>
<h1 id="1-接口设计"><a href="#1-接口设计" class="headerlink" title="1  接口设计"></a>1  接口设计</h1><h2 id="1-1-Information-Hiding"><a href="#1-1-Information-Hiding" class="headerlink" title="1.1 Information Hiding"></a>1.1 Information Hiding</h2><p>书中提到的接口设计中要求的Information hiding是为了模块内的主要功能和函数不暴露在外，否则可能会带来安全问题和让程序变得更加复杂。所以有效地隐藏信息和核心函数是十分重要的。所以我们总共留下了4个接口，分别是用来处理核心功能的<code>process()</code>，用于和GUI交互的三个接口，并且前后端交换数据并不会通过<code>process()</code>接口，而是将<code>process()</code>函数封装在三个单独功能的接口里。除此之外，对于不能被外界访问的数据用<code>private</code>，对于其他可以被外界访问的数据用<code>public</code>。这样</p>
<h2 id="1-2-Interface-Design"><a href="#1-2-Interface-Design" class="headerlink" title="1.2 Interface Design"></a>1.2 Interface Design</h2><p>对于接口设计的理念是，一个接口就完成一个特定的任务，要对接口也进行模块化，对于其他功能或者是信息在这个接口是不可以接入的，只有找到专用的接口才能访问内部数据，这样可以使得编程更加模块化，系统化，有效防止信息泄露和其他情况。在此次结对编程中我们对外留下了<code>process(char *wordList[], char *result[], int len,
    int type, bool letterSum, char head, char tail, char j)</code>，这是一个核心函数。通过这个接口就可以防止内部的信息泄露，较好地完成了模块的封装，也保障了信息的安全。<br>    下面是具体的接口设计，</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gen_chain_word</span><span class="params">(<span class="type">char</span> *words[], <span class="type">int</span> len, <span class="type">char</span> *result[], <span class="type">char</span> head, <span class="type">char</span> tail, <span class="type">char</span> forbid, <span class="type">bool</span> enable_loop)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gen_chains_all</span><span class="params">(<span class="type">char</span> *words[], <span class="type">int</span> len, <span class="type">char</span> *result[])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gen_chain_char</span><span class="params">(<span class="type">char</span> *words[], <span class="type">int</span> len, <span class="type">char</span> *result[], <span class="type">char</span> head, <span class="type">char</span> tail, <span class="type">char</span> forbid, <span class="type">bool</span> enable_loop)</span></span>;</span><br></pre></td></tr></table></figure>
<p>还有核心模块的接口：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">process</span><span class="params">(<span class="type">char</span> *wordList[], <span class="type">char</span> *result[], <span class="type">int</span> len,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">int</span> type, <span class="type">bool</span> letterSum, <span class="type">char</span> head, <span class="type">char</span> tail, <span class="type">char</span> forbid)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="1-3-Loose-Coupling"><a href="#1-3-Loose-Coupling" class="headerlink" title="1.3 Loose Coupling"></a>1.3 Loose Coupling</h2><p>结合书中的松耦合的描述，指的是要将功能聚合在一个cpp或者函数内，然后对外交互信息的时候要实现松耦合，尽可能地将要替换一个功能或者应用到别的场景的时候能够最小化要解耦的地方。此次结对编程我们将核心计算部分集中在<code>core.cpp</code>这个文件中，通过三个既定的接口与GUI／CLI进行交互。这样就能实现Loose Coupling了。这样也方便和其它组别进行互换测试。</p>
<h1 id="2-接口"><a href="#2-接口" class="headerlink" title="2  接口"></a>2  接口</h1><h2 id="2-1-接口设计"><a href="#2-1-接口设计" class="headerlink" title="2.1 接口设计"></a>2.1 接口设计</h2><p>对于既定的接口，本质都是通过实现<code>process()</code>接口实现的，根据<code>type</code>,<code>head</code>,<code>tail</code>,<code>forbid</code>,<code>enable_loop</code>等参数实现<code>gen_chain_word</code>,<code>gen_chains_all</code>,<code>gen_chain_char</code>这个三个接口。<br>对于<code>process()</code>这个接口而言，是先通过<code>init()</code>函数初始化，若<code>argv</code>中带有<code>-j</code>那么直接在<code>wordlist</code>中删除头字母为限制字母的单词。再经过排序<code>sort()</code>和<code>erase()</code>之后，根据<code>type</code>类型判断是<code>-n</code>，还是<code>-w</code>,<code>-c</code>。调用图如下：<br><img data-src="/2023/03/16/%E6%9D%B0%E5%AF%B9%E7%BC%96%E7%A8%8B/1.png" class><br>对于<code>process()</code>而言，通过wordlist和参数构建图，对于允许单词环的，首先检查wordlist中是否有单词环，如果有，但是又参数中没有<code>-r</code>则应该报错，并且由于是<code>NP-hard</code>所以没有最优的性能，暴力求解。但是如果没有单词环，则应该构件<code>DAG</code>之后<code>DP</code>求解。</p>
<ul>
<li><code>gen_chains_all()</code>：遍历所有的单词进行DFS，求最长链，对于超过要求<code>20000</code>长度的则按照异常处理</li>
<li><code>gen_chain_word()和gen_chain_char()</code>只是在构件图的时候边的权重不同而已，在算法部分会详细讲解.</li>
</ul>
<h2 id="2-2-接口实现"><a href="#2-2-接口实现" class="headerlink" title="2.2 接口实现"></a>2.2 接口实现</h2><h3 id="2-2-1-输入预处理"><a href="#2-2-1-输入预处理" class="headerlink" title="2.2.1 输入预处理"></a>2.2.1 输入预处理</h3><p>首先我们对输入的单词数量进行去重，然后对于不满足条件的输入报异常，例如小于两个单词的则不需要求解。对于<code>-j</code>参数我们的处理是在预处理的时候对对应的首字母为制定字母的单词删去，即不参与构图。</p>
<h3 id="2-2-2-构建有权有向图"><a href="#2-2-2-构建有权有向图" class="headerlink" title="2.2.2 构建有权有向图"></a>2.2.2 构建有权有向图</h3><p>对于单词<code>a..b</code>,则创建a和b节点，然后有一条从a到b的有向边。根据需求，如果求的是最多单词数量，则边的权重为1，否则为单词的字母数。以此类推构建一个有向图，此方法的时间复杂度为<code>O(n^2)</code>.<br>我们将其划分<strong>为两种情况</strong>，其一为无隐含的单词环，其二是有隐含的单词环。对于第一种情况，我们可以使用DP求解。在DP的过程中要纪录每个点作为起始点的最长链，最后就可求得最长链的长度了。<br>获得拓扑序列的目的是对于那些有<code>-h</code>或者<code>-t</code>的情况则需要重构图，从而使得最后的重构图能够达到限制条件，时间复杂度为<code>O(n^2+m)</code>。<br>对于有单词环的情况，由于没有最优解，所以我们采用<code>getRingChain()</code>函数进行DFS暴力搜索。</p>
<img data-src="/2023/03/16/%E6%9D%B0%E5%AF%B9%E7%BC%96%E7%A8%8B/2.png" class>
<h2 id="编译无警告的截图："><a href="#编译无警告的截图：" class="headerlink" title="编译无警告的截图："></a>编译无警告的截图：</h2><img data-src="/2023/03/16/%E6%9D%B0%E5%AF%B9%E7%BC%96%E7%A8%8B/3.png" class>
<h1 id="3-UML图"><a href="#3-UML图" class="headerlink" title="3 UML图"></a>3 UML图</h1><p>此次编程项目我们总共写了三个文件，分别是：</p>
<ul>
<li><code>main.cpp</code>用于处理输入，例如单词去重，对单词流的预处理，以及抛出部分异常等</li>
<li><code>core.cpp</code>用于核心计算功能，包括建图，DFS，DP等核心功能集成在这个文件中，其中<code>getScc()</code>用于得到所有的额强连通分量,<code>dfsAll()</code>用于深搜遍历节点</li>
<li><code>core.h</code>用于对外和GUI／CLI的接口<img data-src="/2023/03/16/%E6%9D%B0%E5%AF%B9%E7%BC%96%E7%A8%8B/4.png" class>
</li>
</ul>
<h1 id="4-性能改进"><a href="#4-性能改进" class="headerlink" title="4 性能改进"></a>4 性能改进</h1><p>首先对于有向无环图中的参数<code>-w</code>和<code>-c</code>，由于我们采用了拓扑排序和DP的放大求解，所以能够加快求解速度。对于<code>-j</code>我们的做法是在单词输入预处理的时候把首字母为指定字母的单词直接删去，不参与构建有向图，所以这也可以有助于性能的改进。</p>
<ul>
<li><strong>简单样例</strong><br>!<img data-src="/2023/03/16/%E6%9D%B0%E5%AF%B9%E7%BC%96%E7%A8%8B/5.png" class></li>
<li><strong>复杂样例</strong></li>
</ul>
<img data-src="/2023/03/16/%E6%9D%B0%E5%AF%B9%E7%BC%96%E7%A8%8B/6.png" class>
<img data-src="/2023/03/16/%E6%9D%B0%E5%AF%B9%E7%BC%96%E7%A8%8B/7.png" class>
<p>可以看到在出现单词环的时候，主要在<code>dfsRing()</code>和<code>getRingChain</code>两个的函数上，<br>但是对于一些更为复杂的样例，加上具有<code>-r</code>的含有单词环的情况，程序性能就会急剧下降。</p>
<h1 id="5-Design-by-Contract-amp-Code-Contract"><a href="#5-Design-by-Contract-amp-Code-Contract" class="headerlink" title="5  Design by Contract &amp; Code Contract"></a>5  Design by Contract &amp; Code Contract</h1><p>Design by Contract 是契约式设计，例如大二下学期上的OO课程中的<code>JML</code>就是契约式设计。这种设计的好处在于接口具有不变性，方便人们调试和测试，但是确定契约也是一个繁杂和耗时的磨合的过程．<br>Code Contract 指的是在过程中涉及到的规则约束和编译检查相关的部分.<br>本次作业我们对契约式设计体现在接口的前后端规定，即每个方法都要满足前置条件、后置条件和不变式以及其他的状态约束条件.我们在构建有向图的时候就是所谓的前置条件，不变式就是在<code>process()</code>的过程不破坏图的结构，后置条件就是输出符合要求。</p>
<h1 id="6-测试"><a href="#6-测试" class="headerlink" title="6 测试"></a>6 测试</h1><p>测试我们是在<code>Visual Studio2017</code>内进行调试，后用<code>2022Community</code>版本查看了代码覆盖率。我们主要分为两个测试程序，分别是<code>unitTest.cpp</code>和<code>mainTest.cpp</code>，第一个是用于单元测试，包括参数的测试等，第二个用于主要函数的异常测试。<br>构造测试数据的思路是：穷尽不同组合的参数，对于不可能出现的参数组合，例如<code>-n -r</code>要报异常，下面是单元测试中的两个样例，其中<code>test_gen_chain_word</code>是对<code>gen_chain_word</code>这个接口进行测试。对于三个接口我们都构造了不同的数据。</p>
<ul>
<li><code>unitTest.cpp</code>的部分代码:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">		-w -t -j</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="built_in">TEST_METHOD</span>(test_w_t_j) &#123;</span><br><span class="line">			<span class="type">char</span>* words[] = &#123; <span class="string">&quot;algebra&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;zoo&quot;</span>, <span class="string">&quot;elephant&quot;</span>, <span class="string">&quot;under&quot;</span>, <span class="string">&quot;fox&quot;</span>, <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;moon&quot;</span>, <span class="string">&quot;leaf&quot;</span>, <span class="string">&quot;trick&quot;</span>, <span class="string">&quot;pseudopseudohypoparathyroidism&quot;</span> &#125;;</span><br><span class="line">			<span class="type">char</span>* ans[] = &#123; <span class="string">&quot;elephant&quot;</span>, <span class="string">&quot;trick&quot;</span> &#125;;</span><br><span class="line">			<span class="built_in">test_gen_chain_word</span>(words, <span class="number">11</span>, ans, <span class="number">2</span>, <span class="number">0</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		-w -h -t -j </span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="built_in">TEST_METHOD</span>(test_w_h_t_j) &#123;</span><br><span class="line">			<span class="type">char</span>* words[] = &#123;<span class="string">&quot;asdac&quot;</span>,<span class="string">&quot;jiasdnc&quot;</span>,<span class="string">&quot;qweudasunc&quot;</span>,<span class="string">&quot;casdowdn&quot;</span>,<span class="string">&quot;nasdnw&quot;</span> ,<span class="string">&quot;nqwer&quot;</span>,<span class="string">&quot;rhusad&quot;</span>,<span class="string">&quot;radqwt&quot;</span>,<span class="string">&quot;tqwdbf&quot;</span>,<span class="string">&quot;dqwdf&quot;</span>&#125;;</span><br><span class="line">			<span class="type">char</span>* ans[] = &#123; <span class="string">&quot;qweudasunc&quot;</span>,<span class="string">&quot;casdowdn&quot;</span> ,<span class="string">&quot;nqwer&quot;</span> ,<span class="string">&quot;rhusad&quot;</span>,<span class="string">&quot;dqwdf&quot;</span> &#125;;</span><br><span class="line">			<span class="built_in">test_gen_chain_word</span>(words, <span class="number">10</span>, ans, <span class="number">5</span>,<span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代码覆盖率"><a href="#代码覆盖率" class="headerlink" title="代码覆盖率"></a>代码覆盖率</h2><img data-src="/2023/03/16/%E6%9D%B0%E5%AF%B9%E7%BC%96%E7%A8%8B/8.png" class>
<h1 id="7-异常处理"><a href="#7-异常处理" class="headerlink" title="7 异常处理"></a>7 异常处理</h1><ul>
<li><p>缺少功能参数 <code>Missing function option, please choose -n or -w or -c</code></p>
<blockquote>
<p>功能参数包括 -n -w -c至少要有其一</p>
</blockquote>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">TEST_METHOD</span>(missing_arguments)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="type">char</span> * args[] = &#123; <span class="string">&quot;C:\\Users\\Q\\Desktop\\test.txt&quot;</span> &#125;;</span><br><span class="line">				<span class="built_in">main</span>(<span class="number">1</span>, args);</span><br><span class="line">			&#125;<span class="built_in">catch</span>(invalid_argument <span class="type">const</span> &amp;e)&#123;</span><br><span class="line">				Assert::<span class="built_in">AreEqual</span>(<span class="number">0</span>, <span class="built_in">strcmp</span>(<span class="string">&quot;Missing function option, please choose -n or -w or -c&quot;</span>, e.<span class="built_in">what</span>()));</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			Assert::<span class="built_in">Fail</span>();</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>功能参数不兼容<code>Function option -w, -n and -c conflict</code></p>
<blockquote>
<p>-w -n -c 不兼容</p>
</blockquote>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">TEST_METHOD</span>(duplicated_wnc) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="type">char</span> * args[] = &#123; <span class="string">&quot;-w&quot;</span>, <span class="string">&quot;-n&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;C:\\Users\\Q\\Desktop\\test.txt&quot;</span> &#125;;</span><br><span class="line">				<span class="built_in">main</span>(<span class="number">4</span>, args);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">catch</span> (invalid_argument <span class="type">const</span> &amp;e) &#123;</span><br><span class="line">				Assert::<span class="built_in">AreEqual</span>(<span class="number">0</span>, <span class="built_in">strcmp</span>(<span class="string">&quot;Function option -w, -n and -c conflict&quot;</span>, e.<span class="built_in">what</span>()));</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			Assert::<span class="built_in">Fail</span>();</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>未定义参数<code>Undefined option &#39;-x&#39;</code></p>
<blockquote>
<p>出现未定义参数 -x等</p>
</blockquote>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">TEST_METHOD</span>(undefined_x) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="type">char</span> * args[] = &#123; <span class="string">&quot;-o&quot;</span>, <span class="string">&quot;C:\\Users\\Q\\Desktop\\test.txt&quot;</span> &#125;;</span><br><span class="line">				<span class="built_in">main</span>(<span class="number">2</span>, args);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">catch</span> (invalid_argument <span class="type">const</span> &amp;e) &#123;</span><br><span class="line">				Assert::<span class="built_in">AreEqual</span>(<span class="number">0</span>, <span class="built_in">strcmp</span>(<span class="string">&quot;Undefined option &#x27;-x&#x27;&quot;</span>, e.<span class="built_in">what</span>()));</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			Assert::<span class="built_in">Fail</span>();</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>参数格式错误<code>Argument of option &#39;-x&#39; should be a single alphabet</code></p>
<blockquote>
<p>-h -t -j 后的指令不是单个字母， （单个字符 or 单词）</p>
</blockquote>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">TEST_METHOD</span>(argument_pattern) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="type">char</span> * args[] = &#123; <span class="string">&quot;-h&quot;</span>,<span class="string">&quot;word&quot;</span>, <span class="string">&quot;C:\\Users\\Q\\Desktop\\test.txt&quot;</span> &#125;;</span><br><span class="line">				<span class="built_in">main</span>(<span class="number">3</span>, args);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">catch</span> (invalid_argument <span class="type">const</span> &amp;e) &#123;</span><br><span class="line">				Assert::<span class="built_in">AreEqual</span>(<span class="number">0</span>, <span class="built_in">strcmp</span>(<span class="string">&quot;Argument of option &#x27;-x&#x27; should be a single alphabet&quot;</span>, e.<span class="built_in">what</span>()));</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			Assert::<span class="built_in">Fail</span>();</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>-h与-j不兼容<code>Argument of -h and -j conflict. No answer</code></p>
<blockquote>
<p>-n 与 附加参数 不连用（不要求）</p>
<p>-h 与 -j 指定字母一致则冲突</p>
</blockquote>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">TEST_METHOD</span>(conflict_hj) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="type">char</span> * args[] = &#123; <span class="string">&quot;-h&quot;</span>,<span class="string">&quot;a&quot;</span>, <span class="string">&quot;-j&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;C:\\Users\\Q\\Desktop\\test.txt&quot;</span> &#125;;</span><br><span class="line">				<span class="built_in">main</span>(<span class="number">5</span>, args);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">catch</span> (invalid_argument <span class="type">const</span> &amp;e) &#123;</span><br><span class="line">				Assert::<span class="built_in">AreEqual</span>(<span class="number">0</span>, <span class="built_in">strcmp</span>(<span class="string">&quot;Argument of -h and -j conflict. No answer&quot;</span>, e.<span class="built_in">what</span>()));</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			Assert::<span class="built_in">Fail</span>();</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>不支持-n与附加参数连用<code>-n should be used independantly</code></p>
<blockquote>
<p>-n 与 附加参数 不连用</p>
</blockquote>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">TEST_METHOD</span>(independent_n) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="type">char</span> * args[] = &#123; <span class="string">&quot;-n&quot;</span>,<span class="string">&quot;-r&quot;</span>,<span class="string">&quot;C:\\Users\\Q\\Desktop\\test.txt&quot;</span> &#125;;</span><br><span class="line">				<span class="built_in">main</span>(<span class="number">3</span>, args);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">catch</span> (invalid_argument <span class="type">const</span> &amp;e) &#123;</span><br><span class="line">				Assert::<span class="built_in">AreEqual</span>(<span class="number">0</span>, <span class="built_in">strcmp</span>(<span class="string">&quot;-n should be used independantly&quot;</span>, e.<span class="built_in">what</span>()));</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			Assert::<span class="built_in">Fail</span>();</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>文件不存在<code>Can not find file</code></p>
<blockquote>
<p>输入文件不存在</p>
</blockquote>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">TEST_METHOD</span>(file_notfind) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="type">char</span> * args[] = &#123; <span class="string">&quot;-n&quot;</span>,<span class="string">&quot;C:\\Users\\Q\\Desktop\\fileee.txt&quot;</span> &#125;;</span><br><span class="line">				<span class="built_in">main</span>(<span class="number">2</span>, args);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">catch</span> (invalid_argument <span class="type">const</span> &amp;e) &#123;</span><br><span class="line">				Assert::<span class="built_in">AreEqual</span>(<span class="number">0</span>, <span class="built_in">strcmp</span>(<span class="string">&quot;Can not find file&quot;</span>, e.<span class="built_in">what</span>()));</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			Assert::<span class="built_in">Fail</span>();</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>文件不合法<code>Wrong file format</code></p>
<blockquote>
<p>输入文件格式不合法</p>
</blockquote>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">TEST_METHOD</span>(wrong_fileformat) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="type">char</span> * args[] = &#123; <span class="string">&quot;-n&quot;</span>,<span class="string">&quot;wrong_fileformat.txt&quot;</span> &#125;;</span><br><span class="line">				<span class="built_in">main</span>(<span class="number">2</span>, args);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">catch</span> (invalid_argument <span class="type">const</span> &amp;e) &#123;</span><br><span class="line">				Assert::<span class="built_in">AreEqual</span>(<span class="number">0</span>, <span class="built_in">strcmp</span>(<span class="string">&quot;Wrong file format&quot;</span>, e.<span class="built_in">what</span>()));</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			Assert::<span class="built_in">Fail</span>();</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>隐含单词环<code>Ring dectected without -r option</code></p>
<blockquote>
<p>没有-r的情况下包含了单词环</p>
</blockquote>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">TEST_METHOD</span>(ring_detect) &#123;</span><br><span class="line">			<span class="type">char</span>* words[<span class="number">101</span>] = &#123; <span class="string">&quot;fddsu&quot;</span>, <span class="string">&quot;uasdasf&quot;</span>, <span class="string">&quot;ugfl&quot;</span>, <span class="string">&quot;laght&quot;</span>, <span class="string">&quot;adbon&quot;</span>, <span class="string">&quot;tasdu&quot;</span> &#125;;</span><br><span class="line">			<span class="type">char</span>* result[<span class="number">101</span>];</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">101</span>; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				result[i] = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="number">601</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="built_in">gen_chain_word</span>(words, <span class="number">6</span>, result, <span class="number">0</span>, <span class="number">0</span>,<span class="number">0</span>, <span class="literal">false</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">catch</span> (invalid_argument <span class="type">const</span> &amp;e) &#123;</span><br><span class="line">				Assert::<span class="built_in">AreEqual</span>(<span class="number">0</span>, <span class="built_in">strcmp</span>(<span class="string">&quot;Ring dectected without -r option&quot;</span>, e.<span class="built_in">what</span>()));</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">101</span>; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">free</span>(result[i]);</span><br><span class="line">			&#125;</span><br><span class="line">			Assert::<span class="built_in">Fail</span>();</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>单词链数量过多<code>Too many word chains</code></p>
<blockquote>
<p>超过20000</p>
</blockquote>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">TEST_METHOD</span>(wordlen_overflow) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="type">char</span> * args[] = &#123; <span class="string">&quot;-n&quot;</span>,<span class="string">&quot;wordlenoverflow.txt&quot;</span> &#125;;</span><br><span class="line">				<span class="built_in">main</span>(<span class="number">2</span>, args);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">catch</span> (invalid_argument <span class="type">const</span> &amp;e) &#123;</span><br><span class="line">				Assert::<span class="built_in">AreEqual</span>(<span class="number">0</span>, <span class="built_in">strcmp</span>(<span class="string">&quot;Too many word chains&quot;</span>, e.<span class="built_in">what</span>()));</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			Assert::<span class="built_in">Fail</span>();</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h1 id="8-GUI界面"><a href="#8-GUI界面" class="headerlink" title="8 GUI界面"></a>8 GUI界面</h1><p>我们采用的是QT进行设计。最开始我们采用的是<code>visual studio2017</code>中的C# windows进行设计，但是由于不懂如何写C++ wrapper，且C#和C++一些类型转换较为复杂，整了很久的<code>char* result[]</code>的数据传递，但是一直都是<code>null</code>,所以最后就转用了QT5.12.</p>
<img data-src="/2023/03/16/%E6%9D%B0%E5%AF%B9%E7%BC%96%E7%A8%8B/9.png" class>
<p><strong>开始分析按钮对应：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::on_begin_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    myTimer-&gt;<span class="built_in">setInterval</span>(<span class="number">100</span>);</span><br><span class="line">    myTimer-&gt;<span class="built_in">start</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">startCalc</span>();</span><br><span class="line">    myTimer-&gt;<span class="built_in">stop</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的<code>startCalc()</code>就是核心计算部分，调用DLL进行计算，对于异常具有输出处理功能。在点击了<code>开始分析</code>按钮的时候就开始计时，计算结束的时候停止计时。由于对于一些简单的案例所需时间较短，所以为了保留两位数之后数会很小。<br>与<code>core.dll</code>对接：<br><img data-src="/2023/03/16/%E6%9D%B0%E5%AF%B9%E7%BC%96%E7%A8%8B/10.png" class></p>
<ul>
<li>基本界面：<img data-src="/2023/03/16/%E6%9D%B0%E5%AF%B9%E7%BC%96%E7%A8%8B/11.png" class></li>
<li>导入文件：<img data-src="/2023/03/16/%E6%9D%B0%E5%AF%B9%E7%BC%96%E7%A8%8B/12.png" class></li>
<li><p>导出文件：</p>
<img data-src="/2023/03/16/%E6%9D%B0%E5%AF%B9%E7%BC%96%E7%A8%8B/13.png" class>
</li>
<li><p>正常处理：</p>
<img data-src="/2023/03/16/%E6%9D%B0%E5%AF%B9%E7%BC%96%E7%A8%8B/14.png" class>
<img data-src="/2023/03/16/%E6%9D%B0%E5%AF%B9%E7%BC%96%E7%A8%8B/15.png" class></li>
<li>异常处理：<img data-src="/2023/03/16/%E6%9D%B0%E5%AF%B9%E7%BC%96%E7%A8%8B/16.png" class>
<img data-src="/2023/03/16/%E6%9D%B0%E5%AF%B9%E7%BC%96%E7%A8%8B/17.png" class>
</li>
</ul>
<h1 id="9-杰对讨论"><a href="#9-杰对讨论" class="headerlink" title="9 杰对讨论"></a>9 杰对讨论</h1><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>本人：</strong></p>
<ul>
<li>优点:<br>1.积极沟通，避免了额外的时间开销<br>2.代码编写规范，阅读时没有障碍0<br>3.善于前端制作，在前后端对接出现问题时迅速完成重构</li>
<li>缺点:<br>1.不熟悉vs,qt,上手很慢</li>
</ul>
<p><strong>同伴：</strong></p>
<ul>
<li>优点:<br>1.积极讨论，善于沟通<br>2.比较有生产力<br>3.认真学习之前没接触过的软件缺点:</li>
<li>缺点：<br>对报告比较头疼，第一次接触c++项目启动阶段遇到了一些困难</li>
</ul>
]]></content>
      <categories>
        <category>Program Project</category>
      </categories>
  </entry>
  <entry>
    <title>数据库-第四,五章作业</title>
    <url>/2022/10/15/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%AC%AC%E5%9B%9B-%E4%BA%94%E7%AB%A0%E4%BD%9C%E4%B8%9A/</url>
    <content><![CDATA[<h2 id="第四章作业"><a href="#第四章作业" class="headerlink" title="第四章作业"></a>第四章作业</h2><h3 id="1-什么是数据库安全性？"><a href="#1-什么是数据库安全性？" class="headerlink" title="1. 什么是数据库安全性？"></a><strong>1. 什么是数据库安全性？</strong></h3><p>数据库的安全性是指保护数据库以防止不合法使用所造成的数据泄露、更改或破坏。</p>
<h3 id="2-试述实现数据库安全性控制的常用方法和技术。"><a href="#2-试述实现数据库安全性控制的常用方法和技术。" class="headerlink" title="2. 试述实现数据库安全性控制的常用方法和技术。"></a><strong>2. 试述实现数据库安全性控制的常用方法和技术。</strong></h3><p>数据库的安全性控制主要包括用户身份鉴别、多层存取控制、审计、视图和数据加密等安全技术.</p>
<ul>
<li>用户身份鉴别<ul>
<li>静态口令鉴别</li>
<li>动态口令鉴别</li>
<li>生物特征鉴别</li>
<li>智能卡鉴别</li>
</ul>
</li>
<li>存取控制<ul>
<li>定义用户权限</li>
<li>合法权限检查</li>
</ul>
</li>
</ul>
<h3 id="3-什么是数据库中的自主存取控制和强制存取控制方法。"><a href="#3-什么是数据库中的自主存取控制和强制存取控制方法。" class="headerlink" title="3. 什么是数据库中的自主存取控制和强制存取控制方法。"></a><strong>3. 什么是数据库中的自主存取控制和强制存取控制方法。</strong></h3><p><strong>自主存取控制：</strong>用户对于不同的数据库对象有不同的存取权限，不同的用户对同一对象也有不用的权限，而且用户还可以将其拥有的存取权限转授给其他用户。因此自主存取十分灵活。</p>
<p>主要通过SQL的GRANT和REVOKE与来实现。用户权限由数据库对象和操作类型组成。定义存取权限被称为授权。</p>
<p><strong>强制存储控制：</strong>每一个数据库对象被标有一定的密级，每一个用户也被授予某一个级别的许可证。对于任意一个对象，只有具有合法证的用户才可以存取。强制存取比较严格。</p>
<p>强制存取控制是对数据本身进行密级标记，无论 数据如何复制，标记与数据是一个不可分的整体，只有符合密级标记要求的用户才可以操纵数据，从而提供了更高级别的安全性。</p>
<h3 id="4-试述角色和用户组的定义和作用。"><a href="#4-试述角色和用户组的定义和作用。" class="headerlink" title="4.试述角色和用户组的定义和作用。"></a>4.试述角色和用户组的定义和作用。</h3><p><strong>角色的定义：</strong>数据库角色是被命名的一组与数据库操作相关的权限，角色是权限的集合。</p>
<p><strong>角色作用：</strong>数据库角色是<strong>一组权限的集合</strong>。使用角色来管理数据库权限可以简化授权的过程，使自主授权的执行更加灵活。</p>
<p><strong>用户组的定义</strong>：用户组是一组具有相同特性用户的集合。在授权或收回权限时，可以以用户组为单位进行。</p>
<p><strong>用户组的作用：</strong>数据库用户组由于特性相同，因为在授权和收回权限的时候能够整体进行，效率更高。</p>
<hr>
<h2 id="第五章作业"><a href="#第五章作业" class="headerlink" title="第五章作业"></a>第五章作业</h2><h3 id="1-什么是数据库的完整性"><a href="#1-什么是数据库的完整性" class="headerlink" title="1.什么是数据库的完整性"></a>1.什么是数据库的完整性</h3><p>数据库的完整性是指数据的<strong>正确性</strong>和<strong>相容性</strong>。</p>
<p><strong>正确性</strong>是指数据应具有合法的类型，包括数据类型的正确和数据范围没有溢出等等。</p>
<p><strong>相容性</strong>是指表示同一个事实的两个数据应该相同，并且符合逻辑。</p>
<h3 id="2-什么是数据库的完整性约束条件"><a href="#2-什么是数据库的完整性约束条件" class="headerlink" title="2. 什么是数据库的完整性约束条件"></a>2. 什么是数据库的完整性约束条件</h3><p>​        完整性约束条件也称为完整性规则，是数据库中的数据必须满足的语义约束条件。它表达了给定的数据模型中数据及其联系所具有的制约和依存规则，用以限定符合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效和相容。</p>
<p>​        主要包括关系模型的<strong>实体完整性、参照完整性</strong>和<strong>用户定义完整性</strong>。</p>
<h3 id="3-RDBMS的完整性控制机制应具有哪些功能"><a href="#3-RDBMS的完整性控制机制应具有哪些功能" class="headerlink" title="3. RDBMS的完整性控制机制应具有哪些功能"></a>3. RDBMS的完整性控制机制应具有哪些功能</h3><ul>
<li>定义功能：提供定义完整性约束条件的机制。</li>
<li>检查功能，检查用户发出的操作请求是否违背了完整性约束条件。</li>
<li>违约处理，如果发现用户的操作请求使数据违背于完整性约束条件i则采取一定的动作来保证数据的完整性。</li>
</ul>
<h3 id="4-数据库在实现参照完整性时需要考虑哪些方面？"><a href="#4-数据库在实现参照完整性时需要考虑哪些方面？" class="headerlink" title="4.数据库在实现参照完整性时需要考虑哪些方面？"></a>4.数据库在实现参照完整性时需要考虑哪些方面？</h3><p>参照完整性往往会有一些不一致事情的发生，例如：</p>
<p>（1）表中增加一个元组，由于该元组对应的外码的数值在表中找不到，则会引发冲突。</p>
<p>（2）修改外码值，会对原本是这些外码值的元组造成影响。</p>
<p>（3）删除元组，导致另一个表中的某些属性的外码在该表中找不到元组。</p>
<p>等等。</p>
<p>所以要采取的策略主要有：</p>
<p>（1）拒绝执行（NOT ACTION）</p>
<p>（2）级联执行（CASCADE）</p>
<p>当遇到不一致的情况，就把所有不一致的情况删除。</p>
<p>（3）设置为空值</p>
<p>当删除或者修改参照表中的一个元组造成不一致的时候，就将不一致的元组的属性设置为空值。</p>
<hr>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h4 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h4><p>（1）创建用户王明，并授予他对学生表的SELECT权限</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;王明&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;123456p&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> db1.`学生表` <span class="keyword">TO</span> <span class="string">&#x27;王明&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<img data-src="/2022/10/15/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%AC%AC%E5%9B%9B-%E4%BA%94%E7%AB%A0%E4%BD%9C%E4%B8%9A/image-20221015155443150.png" class>
<p>（2）授予用户王明对学生表的INSERT和DELETE权限</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">INSERT</span>,<span class="keyword">DELETE</span> <span class="keyword">ON</span> db1.`学生表` <span class="keyword">TO</span> <span class="string">&#x27;王明&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>（3）授予用户王明对选课表的SELECT权限和对成绩字段的UPDATE权限</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>,<span class="keyword">UPDATE</span>(Grade) <span class="keyword">ON</span> db1.`选课表` <span class="keyword">TO</span> <span class="string">&#x27;王明&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>（4）授予用户王明创建表的权限</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> db1.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;王明&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>（5）授予用户王明对学生表的所有权限，并具有转授给他人的权力</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> db1.`学生表` <span class="keyword">TO</span> <span class="string">&#x27;王明&#x27;</span>@<span class="string">&#x27;%&#x27;</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br></pre></td></tr></table></figure>
<p>（6）撤销用户王明对学生表的INSERT和DELETE权限</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">INSERT</span>,<span class="keyword">DELETE</span> <span class="keyword">ON</span> db1.`学生表` <span class="keyword">FROM</span> <span class="string">&#x27;王明&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>（7）撤销用户王明对选课表的SELECT权限和对成绩字段的UPDATE权限</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span>,<span class="keyword">UPDATE</span>(Grade) <span class="keyword">ON</span> db1.`选课表` <span class="keyword">FROM</span> <span class="string">&#x27;王明&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>（8）撤销用户王明创建表的权限</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> db1.<span class="operator">*</span> <span class="keyword">FROM</span> <span class="string">&#x27;王明&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>（9）使得用户王明只能查看每个班级的最高分、最低分、平均分，但不能查看每个学生所选课程的具体成绩。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> </span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(`成绩`),<span class="built_in">MIN</span>(`成绩`),<span class="built_in">AVG</span>(`成绩`)</span><br><span class="line"><span class="keyword">FROM</span> `选课表`</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> `班级`</span><br><span class="line"><span class="keyword">ON</span> db1.`选课表` <span class="keyword">TO</span> <span class="string">&#x27;王明&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#创建一个用于成绩定档的函数</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> log_bin_trust_function_creators<span class="operator">=</span><span class="literal">TRUE</span>;#不添加这一行会报错</span><br><span class="line"></span><br><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> IF <span class="keyword">EXISTS</span> gradeLevel$$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> gradeLevel(grade <span class="type">int</span>) <span class="keyword">RETURNS</span> <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">DECLARE</span> str <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">	IF (grade <span class="operator">&lt;</span> <span class="number">60</span>)  <span class="keyword">THEN</span> </span><br><span class="line">	<span class="keyword">set</span> str<span class="operator">=</span><span class="string">&#x27;不及格&#x27;</span>;</span><br><span class="line">	ELSEIF (grade <span class="operator">&lt;</span> <span class="number">70</span> ) <span class="keyword">THEN</span></span><br><span class="line">	<span class="keyword">set</span> str<span class="operator">=</span><span class="string">&#x27;及格&#x27;</span>;</span><br><span class="line">	ELSEIF (grade <span class="operator">&lt;</span> <span class="number">80</span>) <span class="keyword">THEN</span></span><br><span class="line">	<span class="keyword">set</span> str <span class="operator">=</span> <span class="string">&#x27;中等&#x27;</span>;</span><br><span class="line">	ELSEIF (grade <span class="operator">&lt;</span> <span class="number">90</span>) <span class="keyword">THEN</span></span><br><span class="line">	<span class="keyword">set</span> str <span class="operator">=</span> <span class="string">&#x27;良好&#x27;</span>;</span><br><span class="line">	<span class="keyword">ELSE</span></span><br><span class="line">	<span class="keyword">set</span> str <span class="operator">=</span> <span class="string">&#x27;优秀&#x27;</span>;</span><br><span class="line">	<span class="keyword">END</span> IF;</span><br><span class="line">  <span class="keyword">return</span> str;</span><br><span class="line"><span class="keyword">END</span> $$</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> `学生表`.`学号`,`学生表`.`姓名`,`课程表`.`课程名`,`选课表`.`成绩`,gradeLevel(`选课表`.`成绩`)</span><br><span class="line"><span class="keyword">FROM</span> `学生表`,`选课表`,`课程表`</span><br><span class="line"><span class="keyword">WHERE</span> `学生表`.`学号` <span class="operator">=</span> `选课表`.`学号` <span class="keyword">AND</span> `课程表`.`课程号` <span class="operator">=</span> `选课表`.`课程号`;</span><br></pre></td></tr></table></figure>
<p>结果如图：</p>
<img data-src="/2022/10/15/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%AC%AC%E5%9B%9B-%E4%BA%94%E7%AB%A0%E4%BD%9C%E4%B8%9A/image-20221015173133384.png" class>
<h4 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span>定义一个存储过程<span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span></span><br><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> </span><br><span class="line"><span class="keyword">PROCEDURE</span> getGrade(<span class="keyword">IN</span> course <span class="type">VARCHAR</span>(<span class="number">255</span>))</span><br><span class="line">	<span class="comment">-- 存储过程体</span></span><br><span class="line">	<span class="keyword">BEGIN</span></span><br><span class="line">		<span class="comment">-- 把SQL中查询的结果通过INTO赋给变量 INTO SNO INTO sname INTO grade </span></span><br><span class="line">		<span class="keyword">SELECT</span> `学生表`.`学号`  ,`学生表`.`姓名`  ,`选课表`.`成绩` </span><br><span class="line">		<span class="keyword">FROM</span></span><br><span class="line">		`学生表`,`选课表`,`课程表`</span><br><span class="line">		<span class="keyword">WHERE</span></span><br><span class="line">		`学生表`.`学号` <span class="operator">=</span> `选课表`.`学号` <span class="keyword">AND</span> `课程表`.`课程号` <span class="operator">=</span> `选课表`.`课程号` <span class="keyword">AND</span> `课程表`.`课程名`<span class="operator">=</span> course;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">END</span>$$</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> getGrade;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> getGrade(<span class="string">&#x27;数据库&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<img data-src="/2022/10/15/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%AC%AC%E5%9B%9B-%E4%BA%94%E7%AB%A0%E4%BD%9C%E4%B8%9A/image-20221015191444849.png" class>
<h4 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span>创建一张教授的表<span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `教授`(</span><br><span class="line">	`name` <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">		`money` <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">		<span class="keyword">PRIMARY</span> KEY(`name`)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `教授` <span class="keyword">VALUES</span>(<span class="string">&#x27;professor&#x27;</span>,<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 教授;</span><br><span class="line">#<span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span>定义一个触发器<span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span></span><br><span class="line">#注意：要对<span class="keyword">new</span>的数据进行修改和赋值，必须是BEFORE</span><br><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> IF <span class="keyword">EXISTS</span> AgeIncrease;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> AgeIncrease </span><br><span class="line">BEFORE <span class="keyword">UPDATE</span>  <span class="keyword">ON</span> `教授`</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">-- 	DECLARE sum int;</span></span><br><span class="line">	if new.`money` <span class="operator">&lt;</span> old.`money` <span class="keyword">then</span></span><br><span class="line">	<span class="keyword">set</span> new.`money`<span class="operator">=</span>old.`money`;</span><br><span class="line">	<span class="keyword">end</span> if;</span><br><span class="line"><span class="keyword">END</span>$$</span><br><span class="line">DELIMITER;</span><br></pre></td></tr></table></figure>
<p>当把教授的工资设置为2000时，</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> `教授`</span><br><span class="line"><span class="keyword">SET</span> `money`<span class="operator">=</span><span class="number">2000</span></span><br><span class="line"><span class="keyword">WHERE</span> `教授`.`name`<span class="operator">=</span><span class="string">&#x27;professor&#x27;</span>;</span><br></pre></td></tr></table></figure>
<img data-src="/2022/10/15/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%AC%AC%E5%9B%9B-%E4%BA%94%E7%AB%A0%E4%BD%9C%E4%B8%9A/image-20221015202401871.png" class>
<img data-src="/2022/10/15/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%AC%AC%E5%9B%9B-%E4%BA%94%E7%AB%A0%E4%BD%9C%E4%B8%9A/image-20221015202413947.png" class>
<p>设置成功。</p>
<p>如果此时把教授的工资重新改为1000，则会显示：</p>
<img data-src="/2022/10/15/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%AC%AC%E5%9B%9B-%E4%BA%94%E7%AB%A0%E4%BD%9C%E4%B8%9A/image-20221015202621973.png" class>
<img data-src="/2022/10/15/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%AC%AC%E5%9B%9B-%E4%BA%94%E7%AB%A0%E4%BD%9C%E4%B8%9A/image-20221015202634218.png" class>
<p>可见不起效果，工资只增不减。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>知识蒸馏</title>
    <url>/2022/10/08/%E7%9F%A5%E8%AF%86%E8%92%B8%E9%A6%8F/</url>
    <content><![CDATA[<h1 id="Distillation知识蒸馏"><a href="#Distillation知识蒸馏" class="headerlink" title="Distillation知识蒸馏"></a>Distillation知识蒸馏</h1><p>知识蒸馏用于模型压缩，用一个已经训练好的模型A去教另一个模型B。又称为老师-学生模型。通常A比B强，B可以突破自我。</p>
<img data-src="/2022/10/08/%E7%9F%A5%E8%AF%86%E8%92%B8%E9%A6%8F/image_9K_E_o6iJF.png" class>
<p>后面的矩阵<code>[0.7,0.29,0.01]</code>说明老师能够交给学生更多的东西：</p>
<p><code>[1,0,0]</code> 就像标准答案，而 <code>[0.7,0.29,0.01]</code> 就是解析。</p>
<p><strong>先介绍几个函数：</strong></p>
<ol>
<li><p><strong>softmax</strong></p>
<p>输出非负，0~1之间的概率分布</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">softmax</span>(<span class="params">x</span>):</span><br><span class="line">  x_exp = np.exp(x)</span><br><span class="line">  <span class="keyword">return</span> x_exp / np.<span class="built_in">sum</span>(x_exp)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(softmax(output))</span><br><span class="line"></span><br><span class="line">//增加了t  temperature</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">softmax</span>(<span class="params">x,t</span>):</span><br><span class="line">  x_exp = np.exp(x/t)</span><br><span class="line">  <span class="keyword">return</span> x_exp / np.<span class="built_in">sum</span>(x_exp)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(softmax(output,<span class="number">5</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可见t会使得概率分布更加平滑</p>
</li>
<li><p><strong>log_softmax</strong></p>
<p>输出全为负数</p>
</li>
<li><p><strong>NLLLoss</strong></p>
<p>输入：log_softmax(output),target</p>
<img data-src="/2022/10/08/%E7%9F%A5%E8%AF%86%E8%92%B8%E9%A6%8F/image_-klZEH7jQj.png" class>
<p>从NLLLoss中可以看出第三类最小，其实从 <code>[1.2,2,3]</code> 的得分中也可以看出第三类得分最高。</p>
</li>
<li><p><strong>CE交叉熵</strong></p>
<img data-src="/2022/10/08/%E7%9F%A5%E8%AF%86%E8%92%B8%E9%A6%8F/image_5Dx65-Zhw8.png" class>
<p>其中<code>qk</code> 是神经网络认为第k类的概率，并且是经过softmax的了。</p>
<p>确实只有当<code>py=1</code> 的时候，就可以简化为$-log (q_y)$</p>
<hr>
<img data-src="/2022/10/08/%E7%9F%A5%E8%AF%86%E8%92%B8%E9%A6%8F/image_XAPGkKp6Ic.png" class>
<p>可以发现CE可以一步到位。</p>
</li>
</ol>
<p><strong>softmax + nllloss = ce</strong></p>
<img data-src="/2022/10/08/%E7%9F%A5%E8%AF%86%E8%92%B8%E9%A6%8F/image_cTAMQZnOq2.png" class>
<p>上图：t = 1；下图：t = 10；</p>
<p>可见通过设置相应的temperature将暗部特征都蒸馏出来了.（其实就是将概率分布更加平滑）</p>
<p><strong>训练Teacher-Student网络</strong></p>
<img data-src="/2022/10/08/%E7%9F%A5%E8%AF%86%E8%92%B8%E9%A6%8F/image_7C1hV9J8U8.png" class>
<p><strong>说明：</strong></p>
<p><code>p</code> 是标准答案</p>
<p><code>q</code> 是学生的答案</p>
<p><code>q&#39;</code> 是老师的带有解析的答案</p>
<p><code>q&#39;&#39;</code> 是将老师的带有解析的答案经过蒸馏之后的结果（发现了这只猫实际上有点像狗狗）</p>
<p><code>Loss(p,q)</code> 是<code>Hard Loss</code> 因为p是<code>one-hot</code> 的</p>
<p><code>Loss(q,q&#39;&#39;)</code> 是 <code>soft Loss</code></p>
<p>最后minimize两个Loss之和</p>
<img data-src="/2022/10/08/%E7%9F%A5%E8%AF%86%E8%92%B8%E9%A6%8F/image_MMxkqdQ-xb.png" class>
<p><strong>KLDivLoss计算的是soft loss，cross_entropy计算的是hard loss</strong></p>
<p><strong>结果：</strong></p>
<img data-src="/2022/10/08/%E7%9F%A5%E8%AF%86%E8%92%B8%E9%A6%8F/image_UHjyK8d6oR.png" class>
<img data-src="/2022/10/08/%E7%9F%A5%E8%AF%86%E8%92%B8%E9%A6%8F/image_jZYADy5qk8.png" class>
<p><code>prior</code> 是先验知识，人为地加入。而<code>KD</code> 不是人为地加入，而是通过一个老师模型来加入一些限制。</p>
]]></content>
      <tags>
        <tag>AI</tag>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>概率统计模型</title>
    <url>/2022/11/24/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="第七章-概率统计模型"><a href="#第七章-概率统计模型" class="headerlink" title="第七章-概率统计模型"></a>第七章-概率统计模型</h1><h3 id="习题1"><a href="#习题1" class="headerlink" title="习题1"></a>习题1</h3><p>$\mu$的一个置信水平为$1-\alpha$的置信区间为</p>
<img data-src="/2022/11/24/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1%E6%A8%A1%E5%9E%8B/image_pB9WPk2hhI.png" class>
<p>显著水平为$\alpha =0.1$,$\alpha /2=0.05$,$n=5$，服从正态分布，则其由给出的数据算得均值和方差，最后计算出$\mu$的置信水平为0.90的区间。</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = np.array([<span class="number">1050</span>,<span class="number">1100</span>,<span class="number">1120</span>,<span class="number">1250</span>,<span class="number">1280</span>])</span><br><span class="line">n = <span class="built_in">len</span>(d)</span><br><span class="line"><span class="comment"># 计算均值</span></span><br><span class="line">xb = d.mean()</span><br><span class="line"><span class="comment"># 计算标准差</span></span><br><span class="line">s = d.std(ddof=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 计算样本均值的标准差</span></span><br><span class="line">sm = sem(d)</span><br><span class="line">a = <span class="number">0.10</span></span><br><span class="line">ta = t.ppf(<span class="number">1</span>-a/<span class="number">2</span>,n-<span class="number">1</span>)</span><br><span class="line">L = [xb-sm*ta,xb+sm*ta]</span><br><span class="line"><span class="built_in">print</span>(L)</span><br></pre></td></tr></table></figure>
<p><strong>结果</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L=[<span class="number">1064.89955998421</span>, <span class="number">1255.10044001579</span>]</span><br></pre></td></tr></table></figure>
<h1 id="习题2-1"><a href="#习题2-1" class="headerlink" title="习题2-1"></a>习题2-1</h1><h2 id="构建样本点"><a href="#构建样本点" class="headerlink" title="构建样本点"></a>构建样本点</h2><p>储存在points矩阵中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x=np.linspace(<span class="number">0</span>,<span class="number">10</span>,N)</span><br><span class="line">a = <span class="number">1.2</span></span><br><span class="line">b = <span class="number">3.5</span></span><br><span class="line">y0 = a * x + b</span><br><span class="line">y_noise = [np.random.normal(<span class="number">0</span>, <span class="number">0.1</span>) + y <span class="keyword">for</span> y <span class="keyword">in</span> y0]</span><br><span class="line">points = []</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x0 <span class="keyword">in</span> x :</span><br><span class="line">    points.append([x0,np.random.normal(<span class="number">0</span>, <span class="number">0.1</span>) + a * x0 + b])</span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line">points = np.array(points)</span><br></pre></td></tr></table></figure>
<h2 id="leastsq拟合"><a href="#leastsq拟合" class="headerlink" title="leastsq拟合"></a>leastsq拟合</h2><p>先尝试用sklearn的leastsq拟合（此方法用的是最小二乘）得到结果作为验证。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p0 = np.random.randn(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># t=[a,b]</span></span><br><span class="line">fun = <span class="keyword">lambda</span> t, x : t[<span class="number">0</span>] * x + t[<span class="number">1</span>]</span><br><span class="line">err = <span class="keyword">lambda</span> t, x, z: fun(t,x) - z</span><br><span class="line">p2 = leastsq(err, p0, args=(x,y_noise))[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h3 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h3><img data-src="/2022/11/24/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1%E6%A8%A1%E5%9E%8B/image_PPNIpUkCh2.png" class>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">leastsq拟合: [<span class="number">1.20330845</span> <span class="number">3.48951605</span>]</span><br><span class="line">a = <span class="number">1.20330845</span></span><br><span class="line">b = <span class="number">3.48951605</span></span><br></pre></td></tr></table></figure>
<h2 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h2><p>接下去分别用设置不同的损失函数实现最小二乘法、最小绝对偏离估计、最小最大偏离估计用于线性回归的分析。</p>
<h3 id="定义损失函数"><a href="#定义损失函数" class="headerlink" title="定义损失函数"></a>定义损失函数</h3><h4 id="最小二乘法"><a href="#最小二乘法" class="headerlink" title="最小二乘法"></a><strong>最小二乘法</strong></h4><p>对应的损失函数为：</p>
<script type="math/tex; mode=display">
f=\sum (ax_j+b_j-y_j)^2</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">computer_cost</span>(<span class="params">w, b, points</span>):</span><br><span class="line">    total_cost = <span class="number">0</span></span><br><span class="line">    M = <span class="built_in">len</span>(points)</span><br><span class="line">    <span class="comment"># 逐点计算平方损失误差，然后求平均数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(M):</span><br><span class="line">        x = points[i][<span class="number">0</span>]</span><br><span class="line">        y = points[i][<span class="number">1</span>]</span><br><span class="line">        total_cost += (y - w * x - b) ** <span class="number">2</span></span><br><span class="line">    <span class="comment"># 取平均</span></span><br><span class="line">    <span class="keyword">return</span> total_cost / M</span><br></pre></td></tr></table></figure>
<h4 id="最小绝对偏离估计"><a href="#最小绝对偏离估计" class="headerlink" title="最小绝对偏离估计"></a>最小绝对偏离估计</h4><p>损失函数：</p>
<script type="math/tex; mode=display">
f=\sum|sx_j+b_j-y_j|</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">computer_cost_B</span>(<span class="params">w, b, points</span>):</span><br><span class="line">    total_cost = <span class="number">0</span></span><br><span class="line">    M = <span class="built_in">len</span>(points)</span><br><span class="line">    <span class="comment"># 逐点计算平方损失误差，然后求平均数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(M):</span><br><span class="line">        x = points[i][<span class="number">0</span>]</span><br><span class="line">        y = points[i][<span class="number">1</span>]</span><br><span class="line">        total_cost += <span class="built_in">abs</span>(y - w * x - b)</span><br><span class="line">    <span class="comment"># 取平均</span></span><br><span class="line">    <span class="keyword">return</span> total_cost / M</span><br></pre></td></tr></table></figure>
<h4 id="最小最大偏离估计"><a href="#最小最大偏离估计" class="headerlink" title="最小最大偏离估计"></a>最小最大偏离估计</h4><p>损失函数：</p>
<script type="math/tex; mode=display">
f=max|sx_j+b_j-y_j|</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">computer_cost_C</span>(<span class="params">w, b, points</span>):</span><br><span class="line">    total_cost = <span class="number">0</span></span><br><span class="line">    M = <span class="built_in">len</span>(points)</span><br><span class="line">    <span class="comment"># 逐点计算平方损失误差，然后求平均数</span></span><br><span class="line">    maxCost = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(M):</span><br><span class="line">        x = points[i][<span class="number">0</span>]</span><br><span class="line">        y = points[i][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(y - w * x - b) &gt; maxCost:</span><br><span class="line">            maxCost = <span class="built_in">abs</span>(y - w * x - b)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">return</span> maxCost</span><br></pre></td></tr></table></figure>
<h3 id="定义迭代参数"><a href="#定义迭代参数" class="headerlink" title="定义迭代参数"></a>定义迭代参数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 步长</span></span><br><span class="line">alpha = <span class="number">0.0001</span></span><br><span class="line"><span class="comment"># 初始w</span></span><br><span class="line">initial_w = <span class="number">1</span></span><br><span class="line"><span class="comment"># 初始b</span></span><br><span class="line">initial_b = <span class="number">1</span></span><br><span class="line"><span class="comment"># 迭代次数</span></span><br><span class="line">num_iter = <span class="number">1000</span></span><br></pre></td></tr></table></figure>
<p>由于迭代下降最终的a和b结果的迭代结果在不同的损失函数下都是相同的，所以当<strong>cost小于等于1</strong>的时候进行截断，观察不同方法的拟合效果：</p>
<p>可见当前迭代未结束，相同cost情况下最小最大偏离估计的拟合速度更快：</p>
<img data-src="/2022/11/24/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1%E6%A8%A1%E5%9E%8B/image_BQkRZuYaPP.png" class>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">leastsq拟合: [<span class="number">1.20330845</span> <span class="number">3.48951605</span>]</span><br><span class="line">最小二乘法:</span><br><span class="line">a <span class="keyword">is</span> : <span class="number">1.4119904872895737</span></span><br><span class="line">b <span class="keyword">is</span> : <span class="number">2.1132899832906866</span></span><br><span class="line">cost <span class="keyword">is</span> : <span class="number">0.49050095850618497</span></span><br><span class="line">最小绝对偏离估计:</span><br><span class="line">a <span class="keyword">is</span> : <span class="number">1.3806101062114216</span></span><br><span class="line">b <span class="keyword">is</span> : <span class="number">2.321991385922966</span></span><br><span class="line">cost <span class="keyword">is</span> : <span class="number">0.49535272270004677</span></span><br><span class="line">最小最大偏离估计:</span><br><span class="line">a <span class="keyword">is</span> : <span class="number">1.2607599489963919</span></span><br><span class="line">b <span class="keyword">is</span> : <span class="number">3.119078452972342</span></span><br><span class="line">cost <span class="keyword">is</span> : <span class="number">0.4972349489227139</span></span><br></pre></td></tr></table></figure>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">leastsq拟合: [<span class="number">1.20330845</span> <span class="number">3.48951605</span>]</span><br><span class="line">最小二乘法:</span><br><span class="line">a <span class="keyword">is</span> : <span class="number">1.207278913671576</span></span><br><span class="line">b <span class="keyword">is</span> : <span class="number">3.4747646079211276</span></span><br><span class="line">cost <span class="keyword">is</span> : <span class="number">0.008561611307963823</span></span><br><span class="line">最小绝对偏离估计:</span><br><span class="line">a <span class="keyword">is</span> : <span class="number">1.207278913671576</span></span><br><span class="line">b <span class="keyword">is</span> : <span class="number">3.4747646079211276</span></span><br><span class="line">cost <span class="keyword">is</span> : <span class="number">0.07193785933645268</span></span><br><span class="line">最小最大偏离估计:</span><br><span class="line">a <span class="keyword">is</span> : <span class="number">1.207278913671576</span></span><br><span class="line">b <span class="keyword">is</span> : <span class="number">3.4747646079211276</span></span><br><span class="line">cost <span class="keyword">is</span> : <span class="number">0.25574581839753696</span></span><br></pre></td></tr></table></figure>
<p>可见最小二乘法拟合效果最好。</p>
<p>最终拟合结果，三种方法近乎相同：</p>
<img data-src="/2022/11/24/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1%E6%A8%A1%E5%9E%8B/image_L88pyt-ZUn.png" class>
<h1 id="习题2-2"><a href="#习题2-2" class="headerlink" title="习题2-2"></a>习题2-2</h1><p>随机将百分之十的数据y加减20后。</p>
<p>在<strong>cost为50的时候进行截断</strong>，可以发现第二种方法的拟合速度较快。</p>
<img data-src="/2022/11/24/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1%E6%A8%A1%E5%9E%8B/image_wYLmRoaBF3.png" class>
<p>最终的拟合结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 步长</span></span><br><span class="line">alpha = <span class="number">0.001</span></span><br><span class="line"><span class="comment"># 初始w</span></span><br><span class="line">initial_w = <span class="number">1</span></span><br><span class="line"><span class="comment"># 初始b</span></span><br><span class="line">initial_b = <span class="number">3</span></span><br><span class="line"><span class="comment"># 迭代次数</span></span><br><span class="line">num_iter = <span class="number">1000</span></span><br></pre></td></tr></table></figure>
<img data-src="/2022/11/24/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1%E6%A8%A1%E5%9E%8B/image_8aT5AnqrQC.png" class>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">leastsq拟合: [<span class="number">1.35707397</span> <span class="number">3.52990959</span>]</span><br><span class="line">最小二乘法:</span><br><span class="line">a <span class="keyword">is</span> : <span class="number">1.3728617616388785</span></span><br><span class="line">b <span class="keyword">is</span> : <span class="number">3.424909795319972</span></span><br><span class="line">cost <span class="keyword">is</span> : <span class="number">39.02051950964002</span></span><br><span class="line">最小绝对偏离估计:</span><br><span class="line">a <span class="keyword">is</span> : <span class="number">1.3728617616388785</span></span><br><span class="line">b <span class="keyword">is</span> : <span class="number">3.424909795319972</span></span><br><span class="line">cost <span class="keyword">is</span> : <span class="number">2.647783487811292</span></span><br><span class="line">最小最大偏离估计:</span><br><span class="line">a <span class="keyword">is</span> : <span class="number">1.3728617616388785</span></span><br><span class="line">b <span class="keyword">is</span> : <span class="number">3.424909795319972</span></span><br><span class="line">cost <span class="keyword">is</span> : <span class="number">21.373929585192865</span></span><br></pre></td></tr></table></figure>
<p>可见最小绝对偏离估计的cost最小，拟合速度最快，拟合效果也最好。但是另外两个函数对应的拟合损失较大。</p>
<h3 id="改进方法"><a href="#改进方法" class="headerlink" title="改进方法"></a>改进方法</h3><p>最小二乘法的方差能达到很小，但其估计量的方差不一定最小，于是是否可以找到一个有偏估计，使得虽然有微小的偏差，但其精度却能够大大高于无偏的估计量。其实就是<strong>岭回归</strong>，即将最小二乘法加一个范数，并乘以一定的权重，但能比最小二乘法稳定很多。</p>
<img data-src="/2022/11/24/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1%E6%A8%A1%E5%9E%8B/image_IOUD1GRM7l.png" class>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dataMat = np.array(points)</span><br><span class="line">X = dataMat[:,<span class="number">0</span>:<span class="number">1</span>]   <span class="comment"># 变量x</span></span><br><span class="line">y = dataMat[:,<span class="number">1</span>]   <span class="comment">#变量y</span></span><br><span class="line">model = Ridge(alpha=<span class="number">0.2</span>)</span><br><span class="line">model = RidgeCV(alphas=[<span class="number">0.1</span>, <span class="number">1.0</span>, <span class="number">500</span>])  <span class="comment"># 通过RidgeCV可以设置多个参数值，算法使用交叉验证获取最佳参数值</span></span><br><span class="line">model.fit(X, y)   <span class="comment"># 线性回归建模</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;系数矩阵:\n&#x27;</span>,model.coef_)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;线性回归模型:\n&#x27;</span>,model)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其结果如下图所示，可见可以达到很好的拟合效果：</p>
<img data-src="/2022/11/24/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1%E6%A8%A1%E5%9E%8B/image_lveBdaZLHz.png" class>
]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>软工作业2-软件案例分析</title>
    <url>/2023/03/04/%E8%BD%AF%E5%B7%A52/</url>
    <content><![CDATA[<h1 id="作业2"><a href="#作业2" class="headerlink" title="作业2"></a>作业2</h1><h1 id="软件案例分析-软工作业2"><a href="#软件案例分析-软工作业2" class="headerlink" title="软件案例分析[软工作业2]"></a>软件案例分析[软工作业2]</h1><h2 id="0-选题"><a href="#0-选题" class="headerlink" title="0 选题"></a>0 选题</h2><blockquote>
<p>现在许多人生活中都离不开音乐了，没有bgm就没有动力。大家也一定有十分熟悉的音乐软件，现在音乐软件提供的核心功能是什么？主要是为了满足人们什么需求？请选择两款常用的音乐软件进行使用并分析。 网易云音乐；QQ音乐；酷狗音乐</p>
</blockquote>
<h2 id="1-调研与测评"><a href="#1-调研与测评" class="headerlink" title="1 调研与测评"></a>1 调研与测评</h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h3><img data-src="/2023/03/04/%E8%BD%AF%E5%B7%A52/1.png" class>
<img data-src="/2023/03/04/%E8%BD%AF%E5%B7%A52/2.png" class>
<h3 id="1-2-软件测评"><a href="#1-2-软件测评" class="headerlink" title="1.2 软件测评"></a>1.2 软件测评</h3><h4 id="1-2-1-数据对比"><a href="#1-2-1-数据对比" class="headerlink" title="1.2.1 数据对比"></a>1.2.1 数据对比</h4><img data-src="/2023/03/04/%E8%BD%AF%E5%B7%A52/3.png" class>
<img data-src="/2023/03/04/%E8%BD%AF%E5%B7%A52/4.png" class>
<h4 id="1-2-2-用户体验"><a href="#1-2-2-用户体验" class="headerlink" title="1.2.2 用户体验"></a>1.2.2 用户体验</h4><h4 id="🎈优点"><a href="#🎈优点" class="headerlink" title="🎈优点"></a>🎈优点</h4><p>PC端相对手机端会少很多功能。所以主要从手机端的用户体验感来对其分析。当然功能实在太多了所以列举几个对我而言较为惊喜的：</p>
<ul>
<li>网易云音乐在随机播放中加入了【偏好】设置,使得用户当前想听的更具个性化和人性化.对比而言,QQ就没有此种设置.其次,两款APP都加入了【禅定/专注】模式,很显然,这和当前市面上的【番茄专注】等APP中的核心功能进行结合.&#x20;</li>
</ul>

<ul>
<li>除此之外,两款APP都加入了词谱曲库.但是相比而言,QQ音乐在这方面做的功能更多,包括演奏,节拍器,等功能,类似于【迷鹿音乐】APP中的类似功能.而网易云音乐的曲谱仅仅是类似于PDF，互动性较差．&#x20;</li>
</ul>

<ul>
<li>有很多个性化的推荐,例如【每日推荐】,【播客】等功能,使得每个人都有不同的体验感.但是我认为大数据推荐功能用户可以设置是否开启,因为并不是每个人都喜欢只局限于一种类型的音乐.我还发现网易云融入了类似【今日运势】等当下青年人十分流行的一些元素:</li>
</ul>

<h4 id="🎨缺点"><a href="#🎨缺点" class="headerlink" title="🎨缺点"></a>🎨缺点</h4><ul>
<li>除了手机端,PC端的体验感远不及手机端.例如当在网易云客户端点击查看对应的【音乐等级】的时候,会自动跳转到网页.不仅如此,包括【商城】等选项也会自动跳转到网页,而没有嵌入在客户端中,极大地降低了用户体验感.&#x20;</li>
</ul>
<img data-src="/2023/03/04/%E8%BD%AF%E5%B7%A52/8.png" class>
<ul>
<li>相信每个人用QQ音乐和网易云音乐都会发现,QQ音乐转到要唱歌的那一句歌词，只需要点一下那一句歌词一行的任意地方就行，但是网易云音乐却只能按左边的播放小三角．相比起来，Q音更加人性化．所以，操作简便是软件交互的一大重要因素．</li>
<li>在选择想要推荐的歌曲时候,不能<strong>多条件筛选</strong>,例如筛选了曲风,就不能筛选情绪或者场景,所以还有一定的局限性.&#x20;</li>
</ul>
<img data-src="/2023/03/04/%E8%BD%AF%E5%B7%A52/9.png" class>
<ul>
<li>QQ音乐和网易云音乐都加入了很多元素,例如【玩游戏】等和音乐没有关系的区域,我认为这可能增大该软件占用的内存空间,对于大多数人没有用,是冗余的功能:</li>
</ul>
<h4 id="1-2-2-改进意见"><a href="#1-2-2-改进意见" class="headerlink" title="1.2.2 改进意见"></a>1.2.2 改进意见</h4><ul>
<li>增加社交性,个性化设计的时候,简化功能,不要复杂化一个专门用于听音乐的APP</li>
<li>维护PC端的各项功能,并且有时会出现PC端和手机端出现不同步的现象</li>
<li>给大数据推荐一个开关,并且注重用户隐私的保护,不自动为用户添加删除某首歌或者某个音乐人</li>
<li>和其他APP的兼容性和生态环境的维护,一个好的生态环境有利于APP的持久发展</li>
</ul>
<h4 id="1-2-3-用户调研"><a href="#1-2-3-用户调研" class="headerlink" title="1.2.3 用户调研"></a>1.2.3 用户调研</h4><p><strong>采访人员信息:</strong> 一位北航计算机专业的同学,三位北航机械制造专业同学,一位哈工大机器人专业同学,一位华东师大西班牙语专业同学. <strong>选择原因:</strong> 选择这些人采访的原因是比较熟,并且可以了解到不同专业同学之间的想法. <strong>主要需求:</strong> 大部分人只有听音乐的需求,并且不希望听歌付费. <strong>实际使用:</strong> 大部分人使用的是QQ音乐 <strong>问题和亮点:</strong> 问题包括版权不互通,还有一些细节上和一些不知名但是无法复现的BUG等.亮点就是加入了例如心动模式,偏好设置等更加个性化,人性化的小功能,还有包括年度总结和汇报等依靠大数据生成的. <strong>改进之处:</strong> 希望版权互通,少花冤枉钱,界面更加简洁.&#x20;</p>

<h4 id="1-2-4-总结评分"><a href="#1-2-4-总结评分" class="headerlink" title="1.2.4 总结评分"></a>1.2.4 总结评分</h4><div class="table-container">
<table>
<thead>
<tr>
<th>类别</th>
<th>描述</th>
<th>网易云</th>
<th>QQ音乐</th>
</tr>
</thead>
<tbody>
<tr>
<td>基本功能</td>
<td>音乐曲库是否充足</td>
<td>３</td>
<td>４</td>
</tr>
<tr>
<td>基本功能</td>
<td>音质是否满足需求</td>
<td>４</td>
<td>４</td>
</tr>
<tr>
<td>用户体验</td>
<td>人性化与否,是否考虑到特殊人群的需求</td>
<td>３</td>
<td>４</td>
</tr>
<tr>
<td>权限管理</td>
<td>退出APP的时候还要弹窗消息</td>
<td>３</td>
<td>４</td>
</tr>
<tr>
<td>内存管理</td>
<td>占用内存，降低手机启动速度</td>
<td>３</td>
<td>３</td>
</tr>
<tr>
<td>隐私保护</td>
<td>保护隐私，不随机窃取手机信息</td>
<td>４</td>
<td>３</td>
</tr>
<tr>
<td>生态环境</td>
<td>与其他APP兼容性</td>
<td>３</td>
<td>４</td>
</tr>
<tr>
<td>总评</td>
<td>综合评价</td>
<td>3.43</td>
<td>3.71</td>
</tr>
</tbody>
</table>
</div>
<p>总体而言,网易云音乐和QQ音乐都值得<code>d)好,不错</code>的评价.</p>
<h3 id="1-3-BUG分析"><a href="#1-3-BUG分析" class="headerlink" title="1.3 BUG分析"></a>1.3 BUG分析</h3><p>🌍<strong>BUG严重性</strong> 首先给出BUG严重性的量化指标：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>影响</th>
<th>星级</th>
</tr>
</thead>
<tbody>
<tr>
<td>致命性系统故障</td>
<td>5</td>
</tr>
<tr>
<td>严重系统故障</td>
<td>4</td>
</tr>
<tr>
<td>轻微系统故障</td>
<td>3</td>
</tr>
<tr>
<td>不造成系统故障，但给用户带来不便</td>
<td>2</td>
</tr>
<tr>
<td>影响用户体验</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p>🥡<strong>测试环境:</strong> Windows10,Google浏览器 🥗<strong>手机端:</strong></p>
<ul>
<li><strong>BUG1【必然发生】</strong>:在筛选-&gt;选择属性-&gt;中看似有这么多类别可以选,实际上【场景】【曲风流派】等多标签的都不能选择,我本以为是自己所选歌单的问题,但是后来发现别人也同样不能选择,可见这只是硬编码,只是一个样式而已,并没有后端的接口,所以才会显示”当前筛选没有数据哦”。</li>
<li><strong>BUG2【必然发生】</strong>:在点开每个新的未听过的故事的时候,都会显示中间图片,但是没过半秒,就会显示右图,突然多出了一个【设为铃声】的选项,并且这个BUG每次都会出现.&#x20;</li>
</ul>

<ul>
<li><strong>BUG3【必然发生】</strong> :在编辑歌单信息的时候,我在选择第四个标签的时候,会出现”最多可选三个标签”的选项,但是过了一秒左右,原本不能选上的LABEL竟然突然变红选上了,所以可以依靠这种方法选择任意多个LABEL,但是在点击【完成】的时候依然不能成功.&#x20;</li>
</ul>
<img data-src="/2023/03/04/%E8%BD%AF%E5%B7%A52/12.png" class>
<ul>
<li><strong>BUG4【偶尔发生】:</strong> 当从【全屏】模式拖动成【小窗口】模式的时候，当鼠标在拖动的过程中，网易云音乐界面是全白的，当松开鼠标时，恢复正常。但是当我推出重新登录之后，就不会出现上述BUG。 🍥<strong>BUG复现流程图</strong> 红色方块为BUG出现的情况：&#x20;</li>
</ul>
<img data-src="/2023/03/04/%E8%BD%AF%E5%B7%A52/13.png" class>
<ul>
<li>BUG1：没有写【场景】/【曲风流派】的后端接口</li>
<li>BUG2：重定向可能出现问题，没有直接LINK</li>
<li>BUG3：前端或者后端在选择【标签】的时候只给了提示，可能是由于前端给后端数据未经过验证，导致系统反应迟钝。但是奇怪的是，最后前端页面确实自动选上，可能在选择的时候没有做[不少于三个标签]的验证，但是在[完成]按钮的地方进行了验证。</li>
<li>BUG4：可能是由于前端在[持续按住]这种情况没有写相应的前端代码，也可能是我电脑和网络的原因 🚌<strong>BUG严重性</strong></li>
<li>BUG1【2星】：系统功能缺失，不影响安全性，用户体验降低</li>
<li>BUG2【2星】：对系统功能无影响，不影响安全性，用户体验下降</li>
<li>BUG3【3星】：轻微影响系统功能，会出现客户端卡顿的现象，不影响安全性，用户体验下降</li>
<li>BUG4【1星】：轻微影响用户体验，其余不影响 我认为上述BUG可能是因为这些功能很少用户会用到和遇到，所以可能就不维护了，也可能是开发人员粗心大意导致的。</li>
</ul>
<h2 id="2-质量和工作量分析"><a href="#2-质量和工作量分析" class="headerlink" title="2 质量和工作量分析"></a>2 质量和工作量分析</h2><h3 id="2-1-工作量分析"><a href="#2-1-工作量分析" class="headerlink" title="2.1 工作量分析"></a>2.1 工作量分析</h3><p>我认为可能大概需要半年-1年的时间。因为这个音乐APP中的功能实在是太多了。我预计基本功能，例如构建曲库，基本的听歌需求可能一个月就能实现。但是除此之外的其他功能，例如小游戏，KTV，听播客，直播等等其他很多衍生功能需要花上很多时间。由于有专业UI的支持，所以前端界面部分不需要画上大量时间． 包括大数据算法等功能,为了运行地更加稳定和快速,需要我们优化各种算法,不至于最后只是实现了功能,但是体验感极差.</p>
<h3 id="2-2-软件质量分析"><a href="#2-2-软件质量分析" class="headerlink" title="2.2 软件质量分析"></a>2.2 软件质量分析</h3><p>就网易云音乐这个软件而言. </p>
<p><strong>优势</strong>:</p>
<ul>
<li>对用户而言,包括听歌者和音乐人都较为友好,尤其对一些不知名的个人音乐人门槛较低</li>
<li>个性化和数据推荐方面我认为相较其他软件更优,并且年度汇报等具有很大的吸引力</li>
</ul>
<p><strong>劣势</strong>:</p>
<ul>
<li>缺失很多歌的版权,导致有很多歌不能听</li>
<li>缺失网易的生态环境,和QQ音乐在腾讯环境下比起来略逊一筹</li>
<li>和其他APP兼容能力较差，可能会出现在另一个APP中打不开网易云APP的情况</li>
<li>有些专辑价格较高,是否是平台攫取利益过多</li>
</ul>
<p><strong>排名:</strong> 暂列第二</p>
<h2 id="3-建议和规划"><a href="#3-建议和规划" class="headerlink" title="3 建议和规划"></a>3 建议和规划</h2><h3 id="3-1-市场概况"><a href="#3-1-市场概况" class="headerlink" title="3.1 市场概况"></a>3.1 市场概况</h3><p>在七麦数据上查询了三个音乐APP在全球的上架情况,发现网易云音乐和酷狗音乐只在中国上架了,并没有在别的国家上架.但是QQ音乐却在多达163个地区上架.很显然,QQ音乐的国际性市场占了主要地位.同时也对其用户对其评分进行了分析:&#x20;</p>
<img data-src="/2023/03/04/%E8%BD%AF%E5%B7%A52/14.png" class>
<p>可以发现,在APP STORE中三款APP的评分差不多，但是酷狗音乐的用户评分数量都远远高于网易云音乐和QQ音乐.从评分趋势来看,可以发现,网易云音乐的评分一星二星较多,属于正常趋势,但是QQ音乐会突然出现五星评分很多的情况,我猜测可能和水军刷评分有一定的关系. 总而言之,这三款APP在国内呈现的是一个三足鼎立的关系,但是在国际市场上,QQ音乐市场要远远大于另两款APP.</p>
<h3 id="3-2-市场现状"><a href="#3-2-市场现状" class="headerlink" title="3.2 市场现状"></a>3.2 市场现状</h3><p>目前市场有的听歌软件包括:网易云音乐，QQ音乐，酷狗音乐，APPLE MUSIC,咪咕音乐等等.除此之外,云音乐的形式近几年也十分流行.</p>
<blockquote>
<p>2019年9月6日，阿里确认以20亿美元收购网易考拉，同时阿里作为领投方参与了网易云音乐B2轮7亿美元的融资。这笔钱帮助网易云音乐在2020年腾讯音乐独家版权到期后，相继与华纳唱片、环球唱片、索尼唱片直接达成合作。2020年8月，网易云音乐“黑胶VIP”年卡权益纳入阿里“88VIP”生态。</p>
</blockquote>
<p>上述几款音乐类APP中网易和Q音的功能和定位相似,都加入了更多的社交功能,APPLE MUSIC相对更加简介纯粹,咪咕音乐和咪咕体育等生态的支持. 由于APPLEMUSIC只在IOS系统的苹果手机上，所以和安卓手机为主的用户没有太大的可比性，同时和网易Q音在国内没有激烈的竞争关系.但是网易云音乐和QQ音乐存在很强的竞争对立关系,版权不互通等等.酷狗音乐在市场也占有很大的地位,可能和有固定的受众有关,因为酷狗音乐在十年前占据市场主导地位,</p>
<h3 id="3-3-市场与产品生态"><a href="#3-3-市场与产品生态" class="headerlink" title="3.3 市场与产品生态"></a>3.3 市场与产品生态</h3><p><strong>核心用户群:</strong> 网易云和QQ音乐的核心用户都是青中年群体,包括年龄10~50等.典型用户就是学生,刚入职不久的青年等等.这些受众的收入不好评估,毕竟各个阶段都有,表面需求包括听歌等基本需求,潜在需求包括交友,数据推荐等个性化需求.酷狗音乐更多的是长辈等的固定受众,他们也不想更换听音乐软件,所以一直有稳定的受众群体.</p>
<p><strong>用户生态:</strong> 我认为通过相互作用二次构成特定用户生态的可能性极高,并且受众流动性也很强.例如,以前我用的网易云音乐较多,但是现在我基本用QQ音乐,原因一部分在于版权问题,一部分在于身边朋友的影响,其次,我认为所谓的固定受众也会出现变动,例如我给我父亲安利了网易云和QQ音乐等,他们可能也会倾向于用这些产品.</p>
<p><strong>子产品和产品生态:</strong> 网易云和QQ音乐中有很多子产品,例如前面列举过的结合了曲谱的在线播放,直播唱歌,小游戏等功能.但是我认为这些子产品构成生态环境的可能性较小.因为本身这只是这些APP的衍生产物，远不及其他专门做这方面的APP,所以不存在优势,我认为是这些APP的累赘.</p>
<h3 id="3-4-产品规划"><a href="#3-4-产品规划" class="headerlink" title="3.4 产品规划"></a>3.4 产品规划</h3><h4 id="3-4-1-新加功能"><a href="#3-4-1-新加功能" class="headerlink" title="3.4.1 新加功能"></a>3.4.1 新加功能</h4><p>我会加入分析当前歌曲,系统自动拆分出不同音轨,包括乐器,人声,鼓点声等编辑页面,类似于APPLESTORE中的【Medly】,用户可以自己随意更改编辑其中的某个节拍等,生成改编后的新音乐,增加新手小白就能创作音乐的新模式.</p>
<h4 id="3-4-2-NABCD分析"><a href="#3-4-2-NABCD分析" class="headerlink" title="3.4.2 NABCD分析"></a>3.4.2 NABCD分析</h4><p><strong>NEED:</strong> 当前市场存在很多编曲的APP，但是缺少教程，如果基于网易云音乐的大曲库，可以通过某些算法和模型就实现生成已知歌曲的多轨，那么听众不仅仅只是听这首歌，还可以改这首歌，增加互动性． <strong>APPROACH:</strong> 可以尝试通过机器学习,深度学习等,但是由于数据量很少,即能拿到的编曲数据少之又少,所以可以通过制造数据达到训练模型的效果. <strong>BENEFIT:</strong> 如果该功能能够上线,将是一个突破性的举措,可以吸引更多用户参与到改变歌曲当中来,带来更多的盈利和流量. <strong>COMPETITORS:</strong> 当前市场在这方面应该还不存在竞争者,因为这是一个难攻壳的技术难关. <strong>DELIVERY:</strong> 短视频广告,自制改变曲库等属性的加入</p>
<h4 id="3-4-3-配置角色-详细规划"><a href="#3-4-3-配置角色-详细规划" class="headerlink" title="3.4.3 配置角色+详细规划"></a>3.4.3 配置角色+详细规划</h4><p><strong>配置角色:</strong> 一个PM,一个美工,两个后端开发测试,两个前端开发测试 <strong>详细规划:</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>时间</th>
<th>任务</th>
</tr>
</thead>
<tbody>
<tr>
<td>1-2周</td>
<td>确定选题,分工和基本功能,确定代码规范和环境,美工和PM进行调研</td>
</tr>
<tr>
<td>3-4周</td>
<td>学习相关知识和技术,美工开始设计UI界面</td>
</tr>
<tr>
<td>5-7周</td>
<td>完成项目的DEMO和基本功能,一边开发一边完成单元测试,同时美工更进UI界面的设计</td>
</tr>
<tr>
<td>8-10周</td>
<td>完善功能细节，修复一些BUG，中期总结</td>
</tr>
<tr>
<td>11-13周</td>
<td>研究加入算法等实现数据推荐等功能,进行Beta测试</td>
</tr>
<tr>
<td>14-15周</td>
<td>美工宣传可以邀请同学内测,修复BUG</td>
</tr>
<tr>
<td>16周</td>
<td>终期汇报,发布产品</td>
</tr>
<tr>
<td>之后</td>
<td>根据用户数量决定是否一直维护</td>
</tr>
</tbody>
</table>
</div>
<p>🏁<strong>BUG可能成因</strong></p>
<p>🍱<strong>PC端:</strong></p>
<p>同时还通过近几年两款APP近期的版本迭代可以发现两款APP的定位不同，具体来看[由于七麦数据已经无法查找到近几年网易云音乐和QQ音乐的迭代数据]。这些APP的共同点是，在近几年越来越注重社区的建立和交互、加入【一起听】等功能。</p>
<p>可以发现两款软件PC端的UI界面大同小异，左栏显示了各种用户的自身属性，包括一些我喜欢、本地和下载、最近播放等栏目，右图主要是个性推荐、音乐馆等具有大数据推荐等功能。</p>
]]></content>
      <categories>
        <category>Program Project</category>
      </categories>
  </entry>
  <entry>
    <title>软工作业1-阅读与提问</title>
    <url>/2023/02/26/%E8%BD%AF%E5%B7%A5%E4%BD%9C%E4%B8%9A1-%E9%98%85%E8%AF%BB%E4%B8%8E%E6%8F%90%E9%97%AE/</url>
    <content><![CDATA[<div class="table-container">
<table>
<thead>
<tr>
<th>项目</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>这个作业属于哪个课程</td>
<td><a href="https://bbs.csdn.net/forums/buaa-ase2023">北航软工社区</a></td>
</tr>
<tr>
<td>这个作业的要求在哪里</td>
<td><a href="https://bbs.csdn.net/topics/613531493">作业1要求</a></td>
</tr>
<tr>
<td>我在这个课程的目标是</td>
<td>学会结对编程和敏捷开发</td>
</tr>
<tr>
<td>这个作业在哪个具体方面帮助我实现目标</td>
<td>结对编程和敏捷开发</td>
</tr>
</tbody>
</table>
</div>
<h1 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h1><h4 id="问题1：如果量化敏捷开发的效果？是否存在比敏捷开发更具效率的价值观和体系？"><a href="#问题1：如果量化敏捷开发的效果？是否存在比敏捷开发更具效率的价值观和体系？" class="headerlink" title="问题1：如果量化敏捷开发的效果？是否存在比敏捷开发更具效率的价值观和体系？"></a>问题1：如果量化敏捷开发的效果？是否存在比敏捷开发更具效率的价值观和体系？</h4><p>在《构建之法》的第六章中的第115页有：</p>
<blockquote>
<p>问：为啥很多研究都证明敏捷很有效果?<br>答：大多数被测试、被研究的新东西都很有效果，这是Hawthorne效应。例如你可以测试“给每一个程序员发毛绒玩具，然后测试劳动生产率”,你会发现毛绒玩具能提高劳动生产率!</p>
</blockquote>
<p>从上述文字中发现，敏捷能够提高生产率，但是这就是最佳的催化剂了吗？<br>虽然敏捷开发在很多情况下能够带给团队很大的效益，但是还是应该因地制宜，不是所有的团队都适用于敏捷开发，所以我认为也不存在一个标准的评价指标和体系，例如还有MSF等团队模型可以考虑其中。所以我觉得不存在普适的，适用于所有情况的最有效的价值观体系。敏捷开发能带来更多的效益是经验告诉我们的，没有科学依据。</p>
<h4 id="问题2：为什么”冒烟测试”仅仅是测试致命性bug"><a href="#问题2：为什么”冒烟测试”仅仅是测试致命性bug" class="headerlink" title="问题2：为什么”冒烟测试”仅仅是测试致命性bug?"></a>问题2：为什么”冒烟测试”仅仅是测试致命性bug?</h4><p>在《构建之法》的第十三章中的第244页有：</p>
<blockquote>
<p>问：有人提到一种“冒烟测试”,是怎么回事?<br>答：事实上这是一种基本验证测试，据说是从硬件设计行业流传过来<br>的说法。当年设计电路板的时候，很多情况下，新的电路板一插上电<br>源就冒起白烟，烧坏了。如果插上电源后没有冒烟，那就是通过了“冒<br>烟测试”,可以进一步测试电路板的功能了。我们正在讨论的BVT也<br>是一种冒烟测试。</p>
</blockquote>
<p>书中未对“冒烟测试”作详细介绍。<br>经过查阅资料,维基百科上对”冒烟测试”的解释如下:</p>
<blockquote>
<p>smoke testing is preliminary testing to reveal simple failures <strong>severe enough</strong> to, for example, reject a prospective software release. Smoke tests are a subset of [test cases] that <strong>cover the most important functionality</strong> of a component or system, used to aid assessment if main functions of the software appear to work correctly.When used to determine if a computer program should be subjected to further, more fine-grained testing, a smoke test may be called an intake test.Alternately, it is a set of tests run on each new build of a product to verify that the build is <strong>testable</strong> before the build is released into the hands of the test team. In the DevOps paradigm, use of a BVT step is one hallmark of the continuous integration maturity stage.</p>
</blockquote>
<p>冒烟测试就是在每日立会构建之后，对系统的基本功能进行简单的测,其重点在于 daily build，也就是说冒烟测试是随着每一次构建而产生的,而不是所说的测试阶段。<br>除此之外，《构建之法》中还提到了回归测试【在书中的28页】，两者比较来看。<br>经过查阅：</p>
<blockquote>
<p>冒烟测试测试的是致命性Bug。</p>
</blockquote>
<p>冒烟测试和回归测试的区别在于，冒烟测试是找的致命性bug，并且可以节约测试时间成本；但是回归测试就是在对旧代码更改引入的新代码进行测试，看看是否引入新的bug，或者退步。为什么冒烟测试仅仅测试的是致命性bug？虽然此种说法和书中的描述相似，即电路板插上电源是否会冒烟，有没有导致程序跑不动的问题。但是在多轮冒烟测试之后，是否一些小的bug在多轮冒烟测试时未及时检出，导致最后debug时由于bug年代较为久远而导致的效率太低？</p>
<h4 id="问题3：WBS细粒度是否会因为项目的规模而改变"><a href="#问题3：WBS细粒度是否会因为项目的规模而改变" class="headerlink" title="问题3：WBS细粒度是否会因为项目的规模而改变?"></a>问题3：WBS细粒度是否会因为项目的规模而改变?</h4><p>在《构建之法》的第十三章中的第244页有：</p>
<blockquote>
<p>问：所有的文档、工作计划也算在WBS中么?<br>答：如果这些文档是可交付给客户的，或者开发团队要掌控制作文档<br>的花费(人力),那么文档也可以算在WBS中。如果项目很小，或<br>者文档不是很复杂，那么文档工作就可算为项目管理的一部分，而不<br>必单列为一个交付件(Deliverable)。</p>
</blockquote>
<p>经过查阅：</p>
<blockquote>
<p>可见WBS分的细粒度如何,主要取决于项目的大小.但是往往由于某些原因会使得WBS和项目之间没有紧密的联系。</p>
</blockquote>
<p>于是产生疑问：为什么WBS的细粒度要根据项目的大小儿改变？不应该是基本两周的时间完成一个叶节点？这意味着WBS的细粒度应当是恒定的？对这个分解还是不太清楚并存疑。于是又查到：</p>
<blockquote>
<p>由于WBS不是一个事事巨细的覆盖整个项目的分解结构，所以很多细节都不会体现在WBS中。</p>
</blockquote>
<p>《构建之法》第170页:</p>
<blockquote>
<p>从结果出发构建WBS，而不是从团队的活动出发.</p>
</blockquote>
<p>所以结果导向的WBS分解，我觉得WBS的细粒度应当和需求相关，但是不应该因为需求的改变而改变WBS的细粒度。但是对于实际开发过程中是如何做的还有待考量。WBS体现主要是可交付成果，因此常常会被束之高阁。经过查阅,我还发现WBS可以与其他编码体系配合，体现不同的配置关系，比如WBS和OBS结合,就可以进行指责配置。同时我觉得如何分层分级也是一门技术活，层级多，难管理，层级少，难执行。</p>
<h4 id="问题4：小强地狱的出现是否是由于每日构建的质量门禁过低？"><a href="#问题4：小强地狱的出现是否是由于每日构建的质量门禁过低？" class="headerlink" title="问题4：小强地狱的出现是否是由于每日构建的质量门禁过低？"></a>问题4：小强地狱的出现是否是由于每日构建的质量门禁过低？</h4><p>在《构建之法》的第240页中对”每日构建”的定义中未提及每日构建的具体事务.<br>经过查阅,发现daily build就是<strong>把一个软件项目的所有的最新的代码从配置库中取出,然后从头进行编译,链接和运行</strong>。</p>
<blockquote>
<p>Daily build一般是每日下班后半夜进行,前提是员工check in 最新的code到配置库中.所以可以把daily build戏称为nightly build.然后在第二天上班时把错误给所属模块负责人并敦促解决.</p>
</blockquote>
<p>所以daily build是为了减少构建失败的次数,需要尽早发现问题,降低解决问题的成本.同时还可以最小化集成成本.</p>
<blockquote>
<p><strong>那么如何有效地进行Daily Build呢?</strong></p>
<ol>
<li>进行工具协同:固化流程,实时纠偏</li>
<li>制定标准:制定质量门禁</li>
<li>积跬步:在构建后进行冒烟测试</li>
</ol>
</blockquote>
<p>于是产生疑问：如果出现了小强地狱，是否意味着之前的每日构建设置的质量门禁过低？两者是否存在着直接的联系？并且我发现在每日构建之后进行的冒烟测试也仅仅是测试出了致命性的bug，对隐藏的小bug视而不见，是否会导致一直都有百分之十几到二十几的人在小强地狱？我觉得小强地狱的存在不利于团队的发展，所以测试和每日构建之重要不言而喻。</p>
<h4 id="问题5：什么是集成测试的合适时机"><a href="#问题5：什么是集成测试的合适时机" class="headerlink" title="问题5：什么是集成测试的合适时机?"></a>问题5：什么是集成测试的合适时机?</h4><p>在&lt;构建之法&gt;的P248中写道:</p>
<blockquote>
<p>在模块本身稳定之前就提早做集成测试，可能会报告出很多Bug,但是这些由于提早测试而发现的Bug,有点像汽车司机在等待绿灯时不耐烦而拼命地按喇叭—也就是说，有点像噪音。我们还是要等到适当的时机再开始进行集成测试。</p>
</blockquote>
<p>可见不是一个新的模块加进去就要进行集成测试.经过查阅之后:</p>
<blockquote>
<p>理论上，集成测试在单元测试之后,但是这样做效率太低。<br>实际上，单元测试和集成测试同步进行，在单元测试中先测试几个函数的功能，然后再集成测试一下这几个函数的接口。</p>
</blockquote>
<p>所以我产生疑问的是实际开发中集成测试是否和单元测试混为一谈，何为同步进行？较频繁地进行集成测试是否会导致效率太低？如何平衡测试和效率的问题？两者应该是互相制约和互相影响的。我觉得我应该会在之后的团队实践中得到答案。</p>
]]></content>
      <categories>
        <category>Program Project</category>
      </categories>
  </entry>
  <entry>
    <title>非线性规划、二次规划</title>
    <url>/2022/11/15/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E3%80%81%E4%BA%8C%E6%AC%A1%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h1 id="二次优化、凸优化和非线性规划"><a href="#二次优化、凸优化和非线性规划" class="headerlink" title="二次优化、凸优化和非线性规划"></a>二次优化、凸优化和非线性规划</h1><h2 id="非线性规划"><a href="#非线性规划" class="headerlink" title="非线性规划"></a>非线性规划</h2><p>目标函数或者约束条件的表达式中至少有一个非线性函数。</p>
<img data-src="/2022/11/15/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E3%80%81%E4%BA%8C%E6%AC%A1%E8%A7%84%E5%88%92/image_JmM58e7mPM.png" class>
<p>上述为非线性规划的<strong>一般形式，</strong> 还有向量形式。</p>
<ul>
<li>可行解的集合叫做可行域。</li>
<li>区分全局最优解和严格全局最优解</li>
<li>区分局部最优解和严格局部最优解</li>
</ul>
<p><strong>凸优化</strong>：局部最优解就是全局最优解【eg.线性规划、二次规划】</p>
<p><strong>二阶偏导数矩阵：</strong> 称为$f(x)$的Hesse矩阵</p>
<h4 id="无约束非线性规划局部最优解"><a href="#无约束非线性规划局部最优解" class="headerlink" title="无约束非线性规划局部最优解"></a>无约束非线性规划局部最优解</h4><ul>
<li><strong>必要条件</strong>：f(x)具有连续的一阶偏导数，且其一阶偏导数等于零。</li>
<li><strong>充分条件</strong>：f(x)具有连续的二阶偏导数，且一阶导为零，二阶导正定。</li>
</ul>
<p>【尽可能将非线性转换为线性，约束问题转换为无约束问题。】</p>
<h3 id="有等式约束的非线性规划的Lagrange乘子法"><a href="#有等式约束的非线性规划的Lagrange乘子法" class="headerlink" title="有等式约束的非线性规划的Lagrange乘子法"></a>有等式约束的非线性规划的Lagrange乘子法</h3><img data-src="/2022/11/15/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E3%80%81%E4%BA%8C%E6%AC%A1%E8%A7%84%E5%88%92/image_2xGdWFGDgL.png" class>
<p>拉格朗日的意义在于将问题转化为无约束问题求解，因为将约束都加入到了L函数中。</p>
<p>然后等式两边求导等于零：</p>
<img data-src="/2022/11/15/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E3%80%81%E4%BA%8C%E6%AC%A1%E8%A7%84%E5%88%92/image_AlrvBbGtZe.png" class>
<h3 id="有约束非线性规划的罚函数法"><a href="#有约束非线性规划的罚函数法" class="headerlink" title="有约束非线性规划的罚函数法"></a>有约束非线性规划的罚函数法</h3><p>由于一般形式的有约束非线性规划都会有<strong>不等式</strong>的约束，所以拉格朗日无效。</p>
<p>代表性：<strong>外点法</strong></p>
<img data-src="/2022/11/15/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E3%80%81%E4%BA%8C%E6%AC%A1%E8%A7%84%E5%88%92/image_cIxQkYj4Sv.png" class>
<p>不等和相等其实可以对应，在于什么函数让两者对应起来，这个函数就是max{}.</p>
<h3 id="凸函数和凸集的定义"><a href="#凸函数和凸集的定义" class="headerlink" title="凸函数和凸集的定义"></a>凸函数和凸集的定义</h3><p>对于n维欧氏空间里的点集，对于这个空间中的任意两点x1和x2，其<strong>连线</strong>上的所有点【$ax_1+(1-a)x_2$】也属于这个空间，那么就成这个点集时凸集。</p>
<p><strong>任何两个凸的交集也是凸集</strong>。</p>
<p><strong>有限个凸函数的飞赴线性组合也是凸函数。</strong></p>
<h3 id="凸函数的充要条件"><a href="#凸函数的充要条件" class="headerlink" title="凸函数的充要条件"></a>凸函数的充要条件</h3><ol>
<li>一种普通说法</li>
</ol>
<img data-src="/2022/11/15/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E3%80%81%E4%BA%8C%E6%AC%A1%E8%A7%84%E5%88%92/image_qVl5-80vsc.png" class>
<ol>
<li>f(x)的Hesse矩阵处处半正定。</li>
<li>f(x)的Hesse矩阵都是正定的 → <strong>严格凸函数</strong>。</li>
</ol>
<p>【<strong>正定：其矩阵特征值全为正</strong>】</p>
<h3 id="什么叫凸优化-凸规划【凸优化的判定】"><a href="#什么叫凸优化-凸规划【凸优化的判定】" class="headerlink" title="什么叫凸优化/凸规划【凸优化的判定】"></a>什么叫凸优化/凸规划【凸优化的判定】</h3><p>对于前面提出的非线性规划，f(x),g(x)是凸函数，h(x)是线性函数。</p>
<h3 id="关于是否是凸优化的求解方法"><a href="#关于是否是凸优化的求解方法" class="headerlink" title="关于是否是凸优化的求解方法"></a>关于是否是凸优化的求解方法</h3><img data-src="/2022/11/15/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E3%80%81%E4%BA%8C%E6%AC%A1%E8%A7%84%E5%88%92/image_qBRLYy_kMk.png" class>
<h3 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h3><img data-src="/2022/11/15/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E3%80%81%E4%BA%8C%E6%AC%A1%E8%A7%84%E5%88%92/image_KpmfvdIuUY.png" class>
<p>STEP1：判断是否是凸优化</p>
<p>方法：计算f(x)和g(x)的Hesse矩阵，如果都是大于等于零，且约束条件都是线性的。</p>
<p>STEP2：凸优化求解</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cvxpy <span class="keyword">as</span> cp</span><br><span class="line"></span><br><span class="line">x=cp.Variable(<span class="number">2</span>,pos=<span class="literal">True</span>)</span><br><span class="line">obj=cp.Minimize(<span class="built_in">sum</span>(x**<span class="number">2</span>)-<span class="number">4</span>*x[<span class="number">0</span>]+<span class="number">4</span>)</span><br><span class="line">con=[-x[<span class="number">0</span>]+x[<span class="number">1</span>]-<span class="number">2</span>&lt;=<span class="number">0</span>,</span><br><span class="line">     x[<span class="number">0</span>]**<span class="number">2</span>-x[<span class="number">1</span>]+<span class="number">1</span>&lt;=<span class="number">0</span>]</span><br><span class="line">prob = cp.Problem(obj, con)</span><br><span class="line">prob.solve()</span><br><span class="line"><span class="comment"># prob.solve(solver=&#x27;GUROBI&#x27;)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最优值为:&quot;</span>,<span class="built_in">round</span>(prob.value,<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最优解为：\n&quot;</span>, np.<span class="built_in">round</span>(x.value,<span class="number">4</span>))</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="KKT条件"><a href="#KKT条件" class="headerlink" title="KKT条件"></a>KKT条件</h3><p>【在SVM介绍过相关内容】</p>
<p>是非线性规划的必要条件，是凸优化的充要条件。</p>
<img data-src="/2022/11/15/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E3%80%81%E4%BA%8C%E6%AC%A1%E8%A7%84%E5%88%92/image_s11Hoy6ZL1.png" class>
<p>对于凸优化问题，若x满足KKT条件，则x必为凸优化的局部最优解，进而为全局最优解。【一般非线性规划只能找到局部最优解，于初始值相关】</p>
<h3 id="实际应用题解答方法"><a href="#实际应用题解答方法" class="headerlink" title="实际应用题解答方法"></a>实际应用题解答方法</h3><p>主要就是要写出这些变量和假设，以及目标函数是什么。</p>
<img data-src="/2022/11/15/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E3%80%81%E4%BA%8C%E6%AC%A1%E8%A7%84%E5%88%92/image_sGt4-6dX_9.png" class>
<p>最后发现f是凸函数，于是只需要求其一阶偏导=0就能求出最优解。</p>
<h3 id="灵敏性"><a href="#灵敏性" class="headerlink" title="灵敏性"></a>灵敏性</h3><img data-src="/2022/11/15/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E3%80%81%E4%BA%8C%E6%AC%A1%E8%A7%84%E5%88%92/image_Ni0B6PWnmP.png" class>
<p>注意在求dy/da的时候，可以用链式法则。</p>
<hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用plt.subplot来创建小图. plt.subplot(221)表示将整个图像窗口分为2行2列, 当前位置为1.</span></span><br><span class="line">plt.subplot(<span class="number">221</span>)</span><br><span class="line"><span class="comment"># plt.subplot(222)表示将整个图像窗口分为2行2列, 当前位置为2.</span></span><br><span class="line">plt.subplot(<span class="number">222</span>) <span class="comment"># 第一行的右图</span></span><br><span class="line"><span class="comment"># plt.subplot(223)表示将整个图像窗口分为2行2列, 当前位置为3.</span></span><br><span class="line">plt.subplot(<span class="number">223</span>)</span><br><span class="line"><span class="comment"># plt.subplot(224)表示将整个图像窗口分为2行2列, 当前位置为4.</span></span><br><span class="line">plt.subplot(<span class="number">224</span>)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="二次规划"><a href="#二次规划" class="headerlink" title="二次规划"></a>二次规划</h2><p>其一般形式为：</p>
<img data-src="/2022/11/15/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E3%80%81%E4%BA%8C%E6%AC%A1%E8%A7%84%E5%88%92/image_R5m2GjADTQ.png" class>
<p>二次规划模型是一种特殊的非线性规划模型，其<strong>Hesse矩阵</strong>为</p>
<img data-src="/2022/11/15/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E3%80%81%E4%BA%8C%E6%AC%A1%E8%A7%84%E5%88%92/image_Nivg7W3tPg.png" class>
<p>如果H正定，则模型为凸二次优化，凸二次规划局部最优解就是全局最优解。</p>
<h3 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h3><img data-src="/2022/11/15/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E3%80%81%E4%BA%8C%E6%AC%A1%E8%A7%84%E5%88%92/image_caVAtFxZl9.png" class>
<img data-src="/2022/11/15/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E3%80%81%E4%BA%8C%E6%AC%A1%E8%A7%84%E5%88%92/image_Jk_fC4YmT0.png" class>
<p><strong>总结：</strong> 二次规划相对于普通的非线性优化的特点：其目标函数f(x)<strong>没有0次项</strong>。</p>
<p>【<strong>注意！！如果是min f(x)则不是凸优化！！</strong>】</p>
<p>【***<strong>*\</strong>*计算的是x’W**<em>*<em>x的值</em></em>】</p>
<p><strong>a.shape[0]</strong> 行数大小；</p>
<p><strong>a.shape[1]</strong> 列数大小。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c2 = np.array([[-<span class="number">1</span>, -<span class="number">0.15</span>],[-<span class="number">0.15</span>, -<span class="number">2</span>]])</span><br><span class="line">c1 = np.array([<span class="number">98</span>, <span class="number">277</span>])</span><br><span class="line">a = np.array([[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>, -<span class="number">2</span>]])</span><br><span class="line">b = np.array([<span class="number">100</span>, <span class="number">0</span>])</span><br><span class="line">x = cp.Variable(<span class="number">2</span>, pos=<span class="literal">True</span>)</span><br><span class="line">obj =cp.Maximize(cp.quad_form(x,c2) + c1 @ x)</span><br><span class="line"><span class="comment"># obj =cp.Minimize(cp.quad_form(x,c2) + c1 @ x)</span></span><br><span class="line">con = [ a @ x &lt;= b]</span><br><span class="line">prob = cp.Problem(obj, con)</span><br><span class="line">prob.solve()</span><br><span class="line"><span class="comment"># prob.solve(solver=&#x27;GUROBI&#x27;)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;最优解为：&#x27;</span>, np.<span class="built_in">round</span>(x.value,<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;最优值为：&#x27;</span>, <span class="built_in">round</span>(prob.value,<span class="number">4</span>))</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="投资组合问题"><a href="#投资组合问题" class="headerlink" title="投资组合问题"></a>投资组合问题</h3><p>a.mean(axis=0)计算每一列的平均值；</p>
<p>a.mean(axis=1)计算每一行的平均值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.loadtxt(<span class="string">&#x27;data6_4.txt&#x27;</span>)</span><br><span class="line">mu = a.mean(axis=<span class="number">0</span>)   <span class="comment">#计算年平均收益</span></span><br><span class="line">F = np.cov(a.T)       <span class="comment">#计算协方差矩阵</span></span><br><span class="line">x = cp.Variable(<span class="number">3</span>, pos=<span class="literal">True</span>)</span><br><span class="line">ob1 = cp.Minimize(cp.quad_form(x,F))</span><br><span class="line">con1 = [ mu @ x &gt;= <span class="number">0.15</span>,</span><br><span class="line">        <span class="built_in">sum</span>(x) == <span class="number">1</span> ]</span><br><span class="line">prob1 = cp.Problem(ob1, con1)</span><br><span class="line">prob1.solve()</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="一般线性规划"><a href="#一般线性规划" class="headerlink" title="一般线性规划"></a>一般线性规划</h2><p>由于不是<strong>凸优化，\</strong>所以不能使用cvxpy来求解，需要用*<em>scipy.optimize*</em>的minimize来求解。</p>
<img data-src="/2022/11/15/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E3%80%81%E4%BA%8C%E6%AC%A1%E8%A7%84%E5%88%92/image_E3GadMHL2Y.png" class>
<p><strong>ps:约束条件大于等于零.</strong></p>
<hr>
<h3 id="例题3"><a href="#例题3" class="headerlink" title="例题3"></a>例题3</h3><img data-src="/2022/11/15/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E3%80%81%E4%BA%8C%E6%AC%A1%E8%A7%84%E5%88%92/image_czI-sF-Y22.png" class>
<p>不是凸优化，因为h(x)不是线性的.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> minimize</span><br><span class="line"></span><br><span class="line">obj=<span class="keyword">lambda</span> x: <span class="built_in">sum</span>(x**<span class="number">2</span>)+<span class="number">8</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">constr1</span>(<span class="params">x</span>):</span><br><span class="line">    x1, x2, x3 = x</span><br><span class="line">    <span class="keyword">return</span> [x1**<span class="number">2</span>-x2+x3**<span class="number">2</span>,</span><br><span class="line">            <span class="number">20</span>-x1-x2**<span class="number">2</span>-x3**<span class="number">2</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">constr2</span>(<span class="params">x</span>):</span><br><span class="line">    x1, x2, x3 = x</span><br><span class="line">    <span class="keyword">return</span> [-x1-x2**<span class="number">2</span>+<span class="number">2</span>, x2+<span class="number">2</span>*x3**<span class="number">2</span>-<span class="number">3</span>]</span><br><span class="line">con1=&#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;ineq&#x27;</span>, <span class="string">&#x27;fun&#x27;</span>: constr1&#125;</span><br><span class="line">con2=&#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;eq&#x27;</span>, <span class="string">&#x27;fun&#x27;</span>: constr2&#125;            </span><br><span class="line">con=[con1, con2]  <span class="comment">#构造全部约束条件</span></span><br><span class="line">bd = [(<span class="number">0</span>, np.inf) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line">res = minimize(obj, np.random.randn(<span class="number">3</span>), constraints=con, bounds=bd)</span><br><span class="line"><span class="built_in">print</span>(res)  <span class="comment">#输出解的信息</span></span><br></pre></td></tr></table></figure>
<p>注意：如果用sympy.optimize.minimize求解，则con是ineq的时候保证是<strong>大于等于零</strong>的。</p>
<hr>
<h3 id="例题4"><a href="#例题4" class="headerlink" title="例题4"></a>例题4</h3><img data-src="/2022/11/15/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E3%80%81%E4%BA%8C%E6%AC%A1%E8%A7%84%E5%88%92/image_dbX9FoEeQN.png" class>
<p>由于f(x)和g(x)是凸函数，且h(x)是线性的，所以是凸优化问题，可以用cvxpy求解。</p>
]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>非线性拟合</title>
    <url>/2022/11/15/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h3 id="（1）第一小题"><a href="#（1）第一小题" class="headerlink" title="（1）第一小题"></a>（1）第一小题</h3><img data-src="/2022/11/15/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/811a2ca30ddc50855736dfc987a8d78.png" class>
<h3 id="主要思路："><a href="#主要思路：" class="headerlink" title="主要思路："></a>主要思路：</h3><ol>
<li>先按规定生成数据，并随机选取采样的点【设置随机种子，具有可比性】；</li>
<li>对其分别用curve_fit和leastsq进行拟合。</li>
<li>并对不同的h噪声于N采用点的数量多次拟合，得出结论。</li>
</ol>
<p><strong>结论：</strong> 采样点过少拟合的误差很大，选取适当的采样点以及噪声。</p>
<h4 id="初始化值的影响（针对leastsq拟合）"><a href="#初始化值的影响（针对leastsq拟合）" class="headerlink" title="初始化值的影响（针对leastsq拟合）"></a>初始化值的影响（针对leastsq拟合）</h4><ol>
<li>迭代次数会受到影响，有些时候回出现找不到最优解的情况，即Runtime error。</li>
<li>若全为零，则无法收敛。【不清楚具体原因】</li>
</ol>
<p><strong>PS</strong>：结果中拟合得到的六个数分别对应：w1,w2,a1,a2,b1,b2.</p>
<hr>
<img data-src="/2022/11/15/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/image_xrO0vWpXC8.png" class>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">curve_fit拟合: [<span class="number">2.14069954</span> <span class="number">0.09444333</span> <span class="number">0.80681967</span> <span class="number">2.54152869</span> <span class="number">1.4323823</span>  <span class="number">0.19961187</span>]</span><br><span class="line">rmseTrain: <span class="number">0.26232178776291626</span></span><br><span class="line">rmseTest: <span class="number">0.18205567968308098</span></span><br><span class="line">leastsq拟合: [-<span class="number">3.87720452</span> -<span class="number">1.86011704</span>  <span class="number">1.11854247</span>  <span class="number">1.16788575</span> -<span class="number">1.04915769</span>  <span class="number">0.79268749</span>]</span><br><span class="line">rmseTrain: <span class="number">0.26429049990284564</span></span><br><span class="line">rmseTest: <span class="number">0.18608879973399017</span></span><br></pre></td></tr></table></figure>
<img data-src="/2022/11/15/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/image_TujqvE5XI3.png" class>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">curve_fit拟合: [ <span class="number">0.2408062</span>   <span class="number">2.91612327</span>  <span class="number">1.23109954</span> -<span class="number">0.03553431</span>  <span class="number">0.45438827</span>  <span class="number">2.25150756</span>]</span><br><span class="line">rmseTrain: <span class="number">0.2761896128805953</span></span><br><span class="line">rmseTest: <span class="number">0.17399649531553602</span></span><br><span class="line">leastsq拟合: [ -<span class="number">2.17240752</span>  <span class="number">10.4348742</span>    <span class="number">0.87428228</span> -<span class="number">30.76492902</span>  -<span class="number">1.42103926</span></span><br><span class="line">  -<span class="number">0.97720794</span>]</span><br><span class="line">rmseTrain: <span class="number">0.27848961091065344</span></span><br><span class="line">rmseTest: <span class="number">0.1737385154786153</span></span><br></pre></td></tr></table></figure>
<img data-src="/2022/11/15/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/image_mFEWpstNXJ.png" class>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">curve_fit拟合: [-<span class="number">0.32623604</span>  <span class="number">2.15315625</span>  <span class="number">1.41562053</span>  <span class="number">1.12582623</span>  <span class="number">0.50731064</span>  <span class="number">1.0224723</span> ]</span><br><span class="line">rmseTrain: <span class="number">0.282580308684162</span></span><br><span class="line">rmseTest: <span class="number">0.31526037040858185</span></span><br><span class="line">leastsq拟合: [ -<span class="number">69.65799634</span>   -<span class="number">2.95866311</span> -<span class="number">109.80769737</span>    <span class="number">0.86341004</span>  <span class="number">168.29283316</span></span><br><span class="line">   -<span class="number">1.53932051</span>]</span><br><span class="line">rmseTrain: <span class="number">0.2830336972922693</span></span><br><span class="line">rmseTest: <span class="number">0.3147838987502938</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="2-第二小题"><a href="#2-第二小题" class="headerlink" title="(2)第二小题"></a>(2)第二小题</h3><img data-src="/2022/11/15/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/4324816e032e055e860d3f8ffe882aa.png" class>
<p>和第一小题相似的思路，进行求解。此题我用的都是leastsq进行求解。</p>
<p><strong>结论：</strong> 当超参数K在超过20以后，过拟合的风险很大，在很多次情况下都出现了最后发散的情况，且通过分析结果可以发现最优解常常出现在K=15左右。</p>
<p><strong>PS</strong>：结果中拟合得到的矩阵分别对应K个参数。最终求总体最优解K的时候，K遍历了1~30.。</p>
<p>【h=0.3,N=100】</p>
<img data-src="/2022/11/15/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/image_mUY5BGuJFy.png" class>
<p>K = 15的时候其对应的参数值为（在所有的图中最优）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">leastsq拟合: [ <span class="number">7.90943650e-01</span> -<span class="number">6.07790255e+00</span>  <span class="number">3.40089032e+01</span> -<span class="number">8.23686304e+01</span></span><br><span class="line">  <span class="number">1.05477246e+02</span> -<span class="number">7.23628142e+01</span>  <span class="number">1.95321072e+01</span>  <span class="number">5.57225184e+00</span></span><br><span class="line"> -<span class="number">4.12774052e+00</span> -<span class="number">1.00151354e+00</span>  <span class="number">1.66736526e+00</span> -<span class="number">6.90740502e-01</span></span><br><span class="line">  <span class="number">1.45205493e-01</span> -<span class="number">1.59276567e-02</span>  <span class="number">7.27046559e-04</span>]</span><br><span class="line">rmseTrain: <span class="number">0.2542274166735575</span></span><br><span class="line">rmseTest: <span class="number">0.3192894171457426</span></span><br></pre></td></tr></table></figure>
<p>总体最优：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">optimal result: trainRMSE=<span class="number">0.2528564533183719</span>,K=<span class="number">19</span></span><br></pre></td></tr></table></figure>
<p>【h=0.3,N=300】</p>
<img data-src="/2022/11/15/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/image_ashXYEC0CV.png" class>
<p>K = 10的时候最优:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">leastsq拟合: [ <span class="number">5.12963557e-01</span>  <span class="number">1.40887396e+00</span> -<span class="number">1.10781790e+01</span>  <span class="number">3.22315658e+01</span></span><br><span class="line"> -<span class="number">4.44401511e+01</span>  <span class="number">3.33253262e+01</span> -<span class="number">1.44297097e+01</span>  <span class="number">3.60636603e+00</span></span><br><span class="line"> -<span class="number">4.83266327e-01</span>  <span class="number">2.68884577e-02</span>]</span><br><span class="line">rmseTrain: <span class="number">0.27528636920045013</span></span><br><span class="line">rmseTest: <span class="number">0.25770065713597756</span></span><br></pre></td></tr></table></figure>
<p>总体最优：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">optimal result: trainRMSE=<span class="number">0.2812570739349669</span>,K=<span class="number">13</span></span><br></pre></td></tr></table></figure>
<p>【h=0.1,N=100】</p>
<img data-src="/2022/11/15/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/image_kqrDWVsxEb.png" class>
<p>K = 15的时候最优：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">leastsq拟合: [ <span class="number">6.60552408e-01</span> -<span class="number">4.02527344e+00</span>  <span class="number">2.30410493e+01</span> -<span class="number">5.46928875e+01</span></span><br><span class="line">  <span class="number">6.69070375e+01</span> -<span class="number">4.29674450e+01</span>  <span class="number">1.15661941e+01</span>  <span class="number">3.10549348e-01</span></span><br><span class="line">  <span class="number">1.28865085e+00</span> -<span class="number">2.74964237e+00</span>  <span class="number">1.70011749e+00</span> -<span class="number">5.49201917e-01</span></span><br><span class="line">  <span class="number">1.01626117e-01</span> -<span class="number">1.02609900e-02</span>  <span class="number">4.40780742e-04</span>]</span><br><span class="line">rmseTrain: <span class="number">0.07841776983416013</span></span><br><span class="line">rmseTest: <span class="number">0.06016607491515813</span></span><br></pre></td></tr></table></figure>
<p>总体最优：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">optimal result: trainRMSE=<span class="number">0.07898375450702452</span>,K=<span class="number">13</span></span><br></pre></td></tr></table></figure>
<p>【h=0.1,N=300】</p>
<img data-src="/2022/11/15/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/image_q663F7QS-M.png" class>
<p>K=15的时候最优：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">leastsq拟合: [ <span class="number">3.96417862e-01</span>  <span class="number">1.27325013e+00</span> -<span class="number">4.73253349e+00</span>  <span class="number">8.70217397e+00</span></span><br><span class="line"> -<span class="number">2.30403125e+00</span> -<span class="number">1.52860038e+01</span>  <span class="number">2.54845292e+01</span> -<span class="number">1.89155325e+01</span></span><br><span class="line">  <span class="number">6.98733737e+00</span> -<span class="number">5.94285184e-01</span> -<span class="number">5.72936217e-01</span>  <span class="number">2.64631449e-01</span></span><br><span class="line"> -<span class="number">5.28312267e-02</span>  <span class="number">5.26214966e-03</span> -<span class="number">2.11610332e-04</span>]</span><br><span class="line">rmseTrain: <span class="number">0.27732017692692773</span></span><br><span class="line">rmseTest: <span class="number">0.30649315630282625</span></span><br></pre></td></tr></table></figure>
<p>总体最优：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">optimal result: RMSE=<span class="number">0.09689352955521495</span>,K=<span class="number">15</span></span><br></pre></td></tr></table></figure>
<h3 id="3-第三小题"><a href="#3-第三小题" class="headerlink" title="(3)第三小题"></a>(3)第三小题</h3><img data-src="/2022/11/15/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/ed0579b360fb1f1f6de5d862a6d94b7.png" class>
<p>这题需要注意的是其参数的个数总共应该有<strong>K *(M+1)+2</strong>个，所以在初始化参数矩阵的时候需要设置成对应的维数，且第<code>t[K*(M+1)], t[K*(M+1)+1]</code>分别对应的是<code>ai,bi</code>.</p>
<p>此题遍历了K（1~5），M（1~5）。在拟合过程中，往往已经到达maxfev了还没有得到最优解，所以将maxfev设置成5000，但是到后面内存会炸… …因此图也就只画了最优解：</p>
<p>【h=0.2,N=100】</p>
<img data-src="/2022/11/15/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/image_dtfB764PkE.png" class>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">optimal result:<span class="number">0.17873822672400802</span>,K=<span class="number">4</span>,M=<span class="number">4</span></span><br><span class="line">拟合参数为(wij,ai,bi): [-<span class="number">5.23038785e+01</span>  <span class="number">1.18052581e+02</span>  <span class="number">5.45720103e+01</span>  <span class="number">6.73970159e+01</span></span><br><span class="line"> -<span class="number">1.97437971e+02</span> -<span class="number">1.42252056e+02</span> -<span class="number">5.82180336e+01</span> -<span class="number">4.27695564e+01</span></span><br><span class="line">  <span class="number">9.18709021e+01</span> -<span class="number">1.74421852e+02</span>  <span class="number">8.30403724e+01</span> -<span class="number">3.78627087e+01</span></span><br><span class="line">  <span class="number">2.28423291e+02</span>  <span class="number">4.96400605e+01</span>  <span class="number">5.97721900e+02</span>  <span class="number">1.00678402e+02</span></span><br><span class="line">  <span class="number">1.23770905e+01</span> -<span class="number">4.21183888e+02</span> -<span class="number">3.21158789e+01</span> -<span class="number">2.94345001e+02</span></span><br><span class="line"> -<span class="number">2.27769369e+00</span> -<span class="number">1.29106345e+00</span> -<span class="number">8.45080274e-02</span> -<span class="number">2.97361883e-01</span></span><br><span class="line">  <span class="number">4.17302005e-01</span>]</span><br></pre></td></tr></table></figure>
<p>【h=0.2,N=300】</p>
<img data-src="/2022/11/15/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/image_4zj_j1qf9h.png" class>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">optimal result:<span class="number">0.18118763840270755</span>,K=<span class="number">1</span>,M=<span class="number">4</span></span><br><span class="line">拟合参数为(wij,ai,bi): [ <span class="number">1.06746926</span> -<span class="number">0.23354976</span>  <span class="number">2.17369779</span> -<span class="number">2.09387451</span>  <span class="number">0.84513304</span>  <span class="number">0.33436772</span></span><br><span class="line">  <span class="number">0.87670918</span> -<span class="number">0.6949209</span>   <span class="number">0.5154138</span>  -<span class="number">1.11487105</span>]</span><br></pre></td></tr></table></figure>
<p>【h=0.2,N=1000】</p>
<img data-src="/2022/11/15/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/image_rnAgHWl7jh.png" class>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">optimal result:<span class="number">0.19286880337431161</span>,K=<span class="number">1</span>,M=<span class="number">4</span></span><br><span class="line">拟合参数为(wij,ai,bi): [ -<span class="number">8.09035471</span>  -<span class="number">9.53448948</span> -<span class="number">29.17412061</span>  <span class="number">21.14867643</span> -<span class="number">16.45334841</span></span><br><span class="line">  -<span class="number">2.31546224</span>  -<span class="number">1.34575906</span>   <span class="number">0.21633296</span>  -<span class="number">1.31420103</span>  -<span class="number">0.24180187</span></span><br></pre></td></tr></table></figure>
<p>【h=0.5，N=100】</p>
<img data-src="/2022/11/15/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/image_2o_kgBQkW_.png" class>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">optimal result:<span class="number">0.43966680795335106</span>,K=<span class="number">1</span>,M=<span class="number">4</span></span><br><span class="line">拟合参数为(wij,ai,bi): [-<span class="number">2.67613022e+02</span>  <span class="number">4.41099471e+02</span> -<span class="number">5.74683063e+02</span>  <span class="number">1.02026656e+03</span></span><br><span class="line"> -<span class="number">5.72899644e+02</span> -<span class="number">7.29986181e+00</span> -<span class="number">7.36054845e-01</span>  <span class="number">1.39984394e+00</span></span><br><span class="line"> -<span class="number">7.81911683e-01</span> -<span class="number">4.37508983e-01</span>]</span><br></pre></td></tr></table></figure>
<p>【h=0.5,N=300】</p>
<img data-src="/2022/11/15/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/image_Hj-adgh5qc.png" class>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">optimal result:<span class="number">0.4681035667876177</span>,K=<span class="number">2</span>,M=<span class="number">4</span></span><br><span class="line">拟合参数为(wij,ai,bi): [<span class="number">299.78797515</span>  <span class="number">28.87566283</span> -<span class="number">49.79908816</span>   <span class="number">8.91462082</span>  -<span class="number">1.8215882</span></span><br><span class="line"> <span class="number">298.53012447</span>  <span class="number">27.46238369</span> -<span class="number">81.20025633</span>   <span class="number">9.62740177</span>   <span class="number">2.38413704</span></span><br><span class="line">  <span class="number">39.09115188</span>  <span class="number">15.30831486</span>   <span class="number">1.46089238</span>   <span class="number">0.5924728</span>    <span class="number">1.19783084</span>]</span><br></pre></td></tr></table></figure>
<p>【h=0.5,N=1000】</p>
<img data-src="/2022/11/15/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/image_xsQq7RS6za.png" class>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">optimal result:<span class="number">0.489592101202918</span>,K=<span class="number">1</span>,M=<span class="number">4</span></span><br><span class="line">拟合参数为(wij,ai,bi): [-<span class="number">7.69013200e+03</span> -<span class="number">1.79048782e+05</span>  <span class="number">2.63642290e+05</span> -<span class="number">2.51621936e+05</span></span><br><span class="line">  <span class="number">4.04690946e+04</span> -<span class="number">1.03663719e+01</span> -<span class="number">2.47965800e+00</span>  <span class="number">2.16332958e-01</span></span><br><span class="line"> -<span class="number">1.31420103e+00</span> -<span class="number">2.41801865e-01</span>]</span><br></pre></td></tr></table></figure>
<p><strong>结论：</strong> 当采样点高到1000个的时候，拟合曲线极其平滑，且K与M大多分别取在1和4附近，能得到最优解。噪声越高，也会使得RMSE变高，精度下降。</p>
<hr>
<h3 id="（4）第四小题"><a href="#（4）第四小题" class="headerlink" title="（4）第四小题"></a>（4）第四小题</h3><img data-src="/2022/11/15/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/7914af659a59fd93567170c1764c20d.png" class>
<p>噪声和采样点数的影响与前三小题类似。</p>
<img data-src="/2022/11/15/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/image_IsiU7-mIoB.png" class>
<p>curve_fit拟合对应的分别为a,b,c.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">curve_fit拟合: [<span class="number">0.38197691</span> <span class="number">0.60783395</span> <span class="number">0.26275028</span>]</span><br><span class="line">rmseTrain: <span class="number">0.20056951038840645</span></span><br><span class="line">rmseTest: <span class="number">0.20317551977817713</span></span><br></pre></td></tr></table></figure>
<p>若将b设置成10000，则有</p>
<img data-src="/2022/11/15/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/image_zu_dAcPMlW.png" class>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">curve_fit拟合: [-<span class="number">0.01377563</span>  <span class="number">0.36384608</span>]</span><br><span class="line">rmseTrain: <span class="number">0.2993405343270346</span></span><br><span class="line">rmseTest: <span class="number">0.29352661180630557</span></span><br></pre></td></tr></table></figure>
<p>由结果知：a = -0.01377563,c = 0.36384608.且RMSE在测试集和训练集上均<strong>增加</strong>。</p>
<hr>
<h3 id="5-第五小题"><a href="#5-第五小题" class="headerlink" title="(5)第五小题"></a>(5)第五小题</h3><img data-src="/2022/11/15/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/de62783470ea9d93554412c0db0483e.png" class>
<p>对于（2）-（4）的三种模型，选取验证集上RMSE最小的，计算对应模型在测试集上的RMSE：</p>
<p>设置的h=0.3,N=500</p>
<p>结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">-------Model1------</span><br><span class="line">rmseTrain: <span class="number">0.290052586241592</span></span><br><span class="line">rmseCheck: <span class="number">0.27685893060069033</span></span><br><span class="line">rmseTest: <span class="number">0.29482945312589964</span></span><br><span class="line">-------Model2------</span><br><span class="line">rmseTrain: <span class="number">0.5209075125582714</span></span><br><span class="line">rmseCheck: <span class="number">0.509217190063768</span></span><br><span class="line">rmseTest: <span class="number">0.5711414271483303</span></span><br><span class="line">-------Model3------</span><br><span class="line">rmseTrain: <span class="number">0.2961863452096645</span></span><br><span class="line">rmseCheck: <span class="number">0.2863578974670555</span></span><br><span class="line">rmseTest: <span class="number">0.3048874158254555</span></span><br></pre></td></tr></table></figure>
<p>可见第二小题对应的模型比第四小题的模型略胜一筹，第三小题的模型相对误差较大。</p>
]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
</search>
